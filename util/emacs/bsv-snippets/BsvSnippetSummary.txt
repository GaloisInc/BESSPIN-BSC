Bit#(?)                                                                                           Bit =>
instance Connection#(a,b); mkConnection(a,b)... endinstance                               Connectable =>
instance DefaultValue#()... endinstance                                                           Def =>
instance DefaultValue#()... endinstance                                                  DefaultValue =>
FIFO#(type) name <- mkSizedFIFO(sz);                                                             FIFO =>
FIFO#(type) name <- mkSizedBRAMFIFO(sz);                                                         FIFO =>
FIFOF#(type) name <- mkSizedFIFOF(sz);                                                          FIFOF =>
FIFOF#(type) name <- mkSizedBRAMFIFOF(sz);                                                      FIFOF =>
PulseWire name <- mkPulseWire;                                                                  Pulse =>
RWire#(type) name <- mkRWire;                                                                   RWire =>
Reg#(type) name <- mkRegU;                                                                        Reg =>
Reg#(type) name <- mkReg(defaultValue);                                                           Reg =>
Reg#(type) name <- mkRegA(defaultValue);                                                          Reg =>
RegFile#(size,type) name <- mkRegFileFull;                                                    RegFile =>
Stmt name = seq {...} endseq; mkAutoFSM( name );                                                 Stmt =>
Vector#(num,Reg#(type)) name <- replicateM( mkRegU );                                          Vector =>
Reg#(type) name <- mkWire;                                                                       Wire =>
Reg#(type) name <- mkDWire(init);                                                                Wire =>
Reg#(type) name <- mkBypassWire;                                                                 Wire =>
action {...} endaction                                                                         action =>
actionvalue {...} endactionvalue                                                              actionv =>
actionvalue {...} endactionvalue                                                          actionvalue =>
begin {...} end                                                                                 begin =>
case ( cond ) {...} endcase                                                                      case =>
case ( cond ) matches tagged {...} endcase                                                       case =>
/* comment */                                                                                     com =>
$display($time, " %x", data);                                                                    disp =>
/** file name */                                                                                  doc =>
endmethod                                                                                       endme =>
for (Integer i=0; i<num; i=i+1) begin {...}  end                                                  for =>
fromInteger()                                                                                   fromI =>
instance FShow#(basetype) {....} endinstance                                                    fshow =>
instance FShow#(poly#(td)) {....} endinstance                                                   fshow =>
function Action { ... }                                                                      function =>
function ActionValue#(td) {...}                                                              function =>
function Rules {...}                                                                         function =>
function Stmt/FSM {...}                                                                      function =>
function value name { ... }                                                                  function =>
if ( cond ) {...} else {...}                                                                       if =>
if ( cond ) {...}                                                                                  if =>
import name :: *;                                                                              import =>
interface name; ... endmodule                                                               interface =>
interface type name ;                                                                       interface =>
matches tagged Desc .val                                                                      matches =>
method Action name ( args );                                                                   method =>
method value name ( args );                                                                    method =>
method ActionValue#(value) name ( args );                                                      method =>
method Action name ( args ) if ( cond ); <body>; endmethod                                     method =>
method value name ( args ) if (cond); <body>; endmethod                                        method =>
method ActionValue#(value) name ( args ) if (cond); <body>; endmethod                          method =>
module mkIfc ( Ifc ); body; endmodule                                                          module =>
module mkIfc#( params ) ( Ifc ); body; endmodule                                               module =>
module mIfc( Ifc#(td) ) provisos(..); body; endmodule                                          module =>
newfile basic                                                                                 newfile =>
newfile polymorphic                                                                           newfile =>
newfile testbench                                                                             newfile =>
par {...} endpar                                                                                  par =>
(* rules firing *)                                                                             pragma =>
(* rules ordering *)                                                                           pragma =>
repeat (num) .. ;                                                                              repeat =>
return                                                                                            ret =>
rule name (cond); body; endrule                                                                  rule =>
seq {...} endseq                                                                                  seq =>
typedef enum { ... } T                                                                        typedef =>
typedef struct { ... } T                                                                      typedef =>
typedef union tagged { ... } T                                                                typedef =>
