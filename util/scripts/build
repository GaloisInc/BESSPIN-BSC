#!/usr/bin/env python

#
# A build process utility
#
# Copyright Bluespec, Inc. 2009
#

# The purpose of this utility is to standardize a safe, repeatable process
# for building projects based on Bluespec's tools and infrastructure.
# The tool reads a description of the project layout and files and
# automatically generates and executes the sequence of commands required
# to build all of the various project targets.

import os
import os.path
import sys
import optparse
import subprocess
import glob
import random
import copy
import platform
import math
import re
import shutil
from subprocess import call

# ################################################################
# Global Variables
PROJECT_ROOT   = ""
CURRENT_TARGET = ""
JOBS           = 0
JOBS_QUICK     = 0
DEPENDENCIES   = { }
MAKE_ORDER     = []
SKIP_FPGA      = []
PARTITION_SPEC = ""
HAS_PARTITION  = 0

# ################################################################
# Option parsing

# Used for generating error messages due to incorrect option usage
class Usage(Exception):
  def __init__(self, status=0, msg=None):
    self.status = status
    self.msg = msg

# Subclass optparse.OptionParser to make it throw an exception
# instead of calling sys.exit()
class MyOptionParser(optparse.OptionParser):
  def exit(self, status=0, msg=None):
    raise Usage(status, msg)

# Create an option parser for this script
def mkOptionParser():
  parser = MyOptionParser(usage='usage: %prog [options] [build_targets...]',
                          version='%prog 1.0',
                          description='Build or rebuild targets based on a project description file.'
                         );
  parser.add_option('-d', '--doc',
                    action='store_true', dest='print_doc',
                    help='print documentation, then exit')
  parser.add_option('-i', '--init',
                    dest='init_file', default='',
                    help='read project initialization values from FILE and generate a project.bld file', metavar='FILE')
  parser.add_option('--transactor_build',
                    dest='transactor_build', default='',
                    help='transactor generator internal use', metavar='FILE')
  parser.add_option('--dry-run',
                    action='store_true', dest='dry_run', default=False,
                    help='echo commands to stdout but do not actually run them')
  parser.add_option('--no-depends',
                    action='store_true', dest='no_depends', default=False,
                    help='when using -j, do not rebuild depends files (dangerous)')
  parser.add_option('-f', '--from',
                    dest='first_stage', default='start',
                    help='begin building from STAGE', metavar='STAGE')
  parser.add_option('-t', '--to',
                    dest='last_stage', default='finish',
                    help='finish building after STAGE', metavar='STAGE')
  parser.add_option('-p', '--project',
                    dest='project_file', default='project.bld',
                    help='read project description from FILE', metavar='FILE')
  parser.add_option('-l', '--list',
                    action='store_true', dest='list_targets',
                    help='list targets and stages, then exit')
  parser.add_option('-v', '--verbose',
                    action='store_true', dest='verbose', default=False,
                    help='print verbose messages to stdout')
  parser.add_option('-j', '--jobs',
                    dest='make_jobs', default='0',
                    help='run JOBS simultaneous bsc compiles (or 0 to eliminate use of make dependencies)', metavar='JOBS')
  parser.add_option('--skip-fpga',
                    dest='skip_fpga', default='',
                    help='skip the build of specified FPGAs in multi-FPGA builds (dangerous)')

  return parser


# ##################################################################
# Project file parser

# The project file uses an INI-style format where sections are marked
# by a section header name in square brackets (eg. [bsim_dut]).
# Within each section there can be a number of directives, in one of
# these forms:
#
# bool-directive
# directive=value
# directive: value
#
# The result of parsing a project file is a map from section names
# to lists of (directive,value) tuples.
#

# exception used to signal an error in the project file syntax
class ProjectFileError(Exception):
  def __init__(self, name, line, text, message):
    self.filename = name
    self.lineno   = line
    self.text     = text
    self.msg      = message

# exception used to signal an error in the project file content
class DirectiveError(Exception):
  def __init__(self, message, section=None, name=None):
    self.section = section
    self.name    = name
    self.msg     = message

# Sections can include repeated uses of a directive, and can extend
# other sections which may also contain directives present in the
# local section.  There are many different strategies available
# for dealing with repeated directives in these situations, and
# these combiner functions are used to combine values together
# when there are multiple copies of a directive.

# use the local value if it exists
def override(base,local):
  if local == None:
    return base
  else:
    return local

# ignore the base value
def not_inherited(base,local):
  return local

# use whichever is defined.  if they are both defined, they must
# have the same value.
def only_once(base,local):
  if local == None:
    return base
  elif base == None or base == local:
    return local
  else:
    raise DirectiveError("conflicting uses")

# (for lists) use whichever is defined.  if they are both defined,
# prepend the local value to the list accumulated from the base.
def prepend(base,local):
  if local == None:
    return base
  elif base == None:
    return local
  else:
    return (local + base)

# (for lists) use whichever is defined.  if they are both defined,
# append the local value to the list accumulated from the base.
def append(base,local):
  if local == None:
    return base
  elif base == None:
    return local
  else:
    return (base + local)

# (for booleans) use whichever is defined.  if they are both defined,
# use the logical OR of the values.
def or_together(base,local):
  if local == None:
    return base
  elif base == None:
    return local
  else:
    return (local or base)

# Some directives require a choice from a set of descrete values.  These
# verifier functions are used to validate the directive values.

def verify_build_for(arg):
  if arg in ['bluesim',
             'verilog',
             'rtl',
             'rtllink',
             'arria10gx',
             'dn7002',
             'dn7006',
             'dn7406',
             'ml507',
             'ml605',
             'kc705',
             'vc707',
             'vc709',
             'kcu105',
             'vcu108',
             'dn10ghxtll',
             'dn10gk7ll',
             'dh2000tq',
             'b2000t',
             'pdv72kr2',
             'dnv7f2a',
             'rpp2',
             'rpp2split',
             'dnvuf4a',
             'klvuf4a',
             'xupv5',
             'c++',
             'systemc']:
    return True
  else:
    return False

def verify_build_for_multi_fpga(arg):
  if arg in ['dn7002', 'dn7006', 'dn7406']:
    return True
  else:
    return False

def verify_partition_for(arg):
  if arg in ['none', 'dn7002', 'dn7006', 'dn7406']:
    return True
  else:
    return False

def verify_altera_build_board_for(arg):
  if arg in ['7002', '7006', '7406']:
    return True
  else:
    return False

def verify_intel_build_board_for(arg):
  if arg in ["ARRIA10GX"]:
    return True
  else:
    return False

def verify_intel_build_board_for(arg):
  if arg in ['ARRIA10GX']:
    return True
  else:
    return False

def verify_xilinx_build_board_for(arg):
  if arg in ['ML507',
             'XUPV5',
             'ML605',
             'KC705',
             'VC707',
             'VC709',
             'KCU105',
             'VCU108',
             '10GHXTLL',
             '10GK7LL',
             'DH2000TQ',
             'B2000T',
             'PDV72KR2',
             'DNV7F2A',
             'RPP2',
             'RPP2SPLIT',
             'DNVUF4A',
             'KLVUF4A']:
    return True
  else:
    return False

def verify_vivado_build_board_for(arg):
  if arg in ['KC705',
             'VC707',
             'VC709',
             'KCU105',
             'VCU108',
             '10GK7LL',
             'DH2000TQ',
             'B2000T',
             'PDV72KR2',
             'DNV7F2A',
             'RPP2',
             'RPP2SPLIT',
             'DNVUF4A',
             'KLVUF4A']:
    return True
  else:
    return False

def verify_create_elab_sources_board_for(arg):
  if arg in ['ml605',
             'kc705',
             'vc707',
             'vc709',
             'kcu105',
             'vcu108',
             'dn10gk7ll',
             'dh2000tq',
             'b2000t',
             'pdv72kr2',
             'dnv7f2a',
             'rpp2',
             'rpp2split',
             'dnvuf4a',
             'klvuf4a']:
    return True
  else:
    return False

def get_xilinx_synth_strategy(section, config, board):
  arg = resolve(section,'xilinx-synth-strategy',config)
  if verify_vivado_build_board_for(board):
    if arg in ['TimingWithIOBPacking']:
      return '{Vivado Synthesis Defaults}'
    else:
      return arg
  else:
    return arg

def get_xilinx_impl_strategy(section, config, board):
  arg = resolve(section,'xilinx-impl-strategy',config)
  if verify_vivado_build_board_for(board):
    if arg in ['MapLogicOptParHighExtra']:
      return '{Vivado Implementation Defaults}'
    else:
      return arg
  else:
    return arg

def verify_bluenoc_only_build_for(arg):
  if arg in ['ARRIA10GX',
             'KC705',
             'VC707',
             'VC709',
             'KCU105',
             'VCU108',
             'DN10GK7LL',
             'DH2000TQ',
             'B2000T',
             'PDV72KR2',
             'DNV7F2A',
             'RPP2',
             'RPP2SPLIT',
             'DNVUF4A',
             'KLVUF4A']:
    return True
  else:
    return False

def verify_header_targets(args):
  for arg in args:
    if arg not in ['inputs','outputs','probes','all','none']:
      return False
  return True

def verify_scemi_type(arg):
  if arg in ['TCP',
             'PCIE_ARRIA10GX',
             'PCIE_DINI',
             'PCIE_VIRTEX5',
             'PCIE_VIRTEX6',
             'PCIE_KINTEX7',
             'PCIE_KINTEXU',
             'PCIE_VIRTEX7',
             'PCIE_VIRTEXU',
             'EVE',
             'SCEMI']:
    return True
  else:
    return False

def verify_scemi_infrastructure_style(arg):
  if arg in ['CLASSIC','BLUENOC']:
    return True
  else:
    return False

def verify_sodimm_style(arg):
  if arg in ['NONE','DDR2','DDR3','DDR4','SRAM']:
    return True
  else:
    return False

def lookup_sdram_style(board):
  return {
    'ARRIA10GX':     'NONE', # not supported yet
    '7002':          'DDR2',
    '7006':          'DDR2',
    '7406':          'DDR2',
    '10GHXTLL':      'DDR2',
    '10GK7LL':       'DDR3',
    'PDV72KR2':      'NONE', # not supported yet
    'DH2000TQ':      'DDR2',
    'B2000T':        'DDR3',
    'DNV7F2A':       'DDR3',
    'RPP2':          'DDR3',
    'RPP2SPLIT':     'DDR3',
    'DNVUF4A':       'NONE', # not supported yet
    'KLVUF4A':       'NONE', # not supported yet
    'ML507':         'DDR2',
    'ML605':         'DDR3',
    'KC705':         'DDR3',
    'VC707':         'DDR3',
    'VC709':         'DDR3',
    'KCU105':        'DDR4',
    'VCU108':        'NONE', # not supported yet
    'XUPV5':         'DDR2',
    }.get(board, 'NONE')

def sysc_libdir(bsdir):
  return subprocess.Popen([bsdir + '/bin/bsenv', 'sysc_libdir'], stdout=subprocess.PIPE).communicate()[0].strip()

def tcl_libdir(bsdir):
  return subprocess.Popen([bsdir + '/bin/bsenv', 'tcl_libdir'], stdout=subprocess.PIPE).communicate()[0].strip()

def cxx_family(bsdir):
  return subprocess.Popen([bsdir + '/bin/bsenv', 'c++_family'], stdout=subprocess.PIPE).communicate()[0].strip()

def is64(bsdir):
  return subprocess.Popen([bsdir + '/bin/bsenv', 'is64'], stdout=subprocess.PIPE).communicate()[0].strip() == "64"

def doingReadback(section,config):
  return resolve(section,'xilinx-readback',config) or resolve(section, 'xilinx-readback-jtag',config)

def isPartition(script):
  global PARTITION_SPEC
  if not file_exist(script):
    return False
  shcmd = "egrep -v '^$|^#' " + script
  scr = subprocess.Popen([shcmd, ""], shell=True, stdout=subprocess.PIPE).communicate()[0].strip()
  found = scr.find("partition")
  if found != -1:
    PARTITION_SPEC = scr[found:].split()
    PARTITION_SPEC = PARTITION_SPEC[2]
  eol = scr.count("\n")
  if found != -1 and eol > 0:
    return True
  return False

# This is the master list of directives.
#
# This list is used to describe the directives for documentation
# purposes, but also records default values and strategies for
# combining directive values.
#
# Each record in this format:
#
#   name:
#   (topic-group, value-desc, default-value, env-var, verifier-fn, combine-repeat, combine-extend,
#   long-desc)
#
# describes a directive with the following information:
#
#   name              name of the directive
#   topic-group       which topic to place this under generating the
#                     documentation (using --doc argument)
#   value-desc        a short description of the type of value expected
#                     with this directive (eg., 'bool' or 'list of files')
#   default-value     a default value to be used if this description is
#                     not present.  this value is used in the code and
#                     also shown in the generated documentation.
#                     use None if there is no default value for a
#                     directive.
#   env-var           an environment variable which will be used for a
#                     default value if it is set.  the name of the
#                     environment variable will be shown in the generated
#                     documentation, and its value will be used in the
#                     code.  use None if there is no environment variable
#                     for a directive.
#   verifier-fn       a function to check the validity of a directive
#                     value.  use None if there is no directive-specific
#                     validation required.
#   combine-extend    a combiner function used when a section extends
#                     another section
#   combine-repeat    a combiner function used for repeated directives
#                     within a single section
#   long-desc         a long textual description of a directives purpose
#                     and allowed values.  this text is used when
#                     generating the documentation for the directive.
directive_descriptions = {\
'default-targets':
('Build targets', 'list of targets', [], None, None, prepend, only_once,
"""This directive can be used only within the DEFAULT section to
define which targets should be rebuilt if no target is specified
on the command line."""),
\
'skip-target-when':
('Build targets', 'command', None, None, None, override, only_once,
"""When present, the given command will be run in a shell and if the
exit status of the command is 0, the target stages will be
skipped."""),
\
'skip-target-unless':
('Build targets', 'command', None, None, None, override, only_once,
"""When present, the given command will be run in a shell and if the
exit status of the command is not 0, the target stages will be
skipped."""),
\
'include-files':
('Build targets', 'list of files', [], None, None, append, prepend,
"""This directive permits the inclusion of other project description
files."""),
\
'bsc':
('Controlling bsc', 'executable name', 'bsc', 'BSC', None, override, only_once,
"""This is the name of the command to use for invoking the Bluespec
compiler."""),
\
'bsc-compile-options':
('Controlling bsc', 'list of options', [], None, None, append, prepend,
"""This directive can be used to supply options to the bsc
compilation stage."""),
\
'bsc-rts-options':
('Controlling bsc', 'list of options', [], None, None, append, prepend,
"""This directive can be used to supply RTS options to the bsc
compilation stage."""),
\
'bsv-define':
('Controlling bsc', 'list of definitions', [], None, None, append, prepend,
"""Specifies macro definitions (of the form <VAR> or <VAR>=<VAL>) to
be passed to the bsv compile stage using the -D option."""),
\
'bsc-link-options':
('Controlling bsc', 'list of options', [], None, None, append, prepend,
"""This directive can be used to supply options to the bsc link
stage."""),
\
'link-top-module':
('Describing the project layout', 'module name', None, None, None, override, only_once,
"""The alternate name of the top-level verilog which will override the top-module directive
when linking ."""),
\
'build-for':
('Controlling bsc', 'platform', 'bluesim', None, verify_build_for, override, only_once,
"""Specifies whether to build for Bluesim, Verilog, FPGAs, etc.
Valid values are:
  bluesim       - build and link for Bluesim
  verilog       - build and link for Verilog simulation
  rtl           - build Verilog RTL but do not link for simulation
  rtllink       - link for Verilog simulation, but do not build Verilog RTL
  arria10gx     - build Verilog RTL and synthesize for an Intel Arria 10 GX board
  dn7002        - build Verilog RTL and synthesize for a Dini 7002 board
  dn7006        - build Verilog RTL and synthesize for a Dini 7006 board
  dn7406        - build Verilog RTL and synthesize for a Dini 7406 board
  dn10ghxtll    - build Verilog RTL and synthesize for a Dini PCIe_10G_HXT_LL board
  dn10gk7ll     - build Verilog RTL and synthesize for a Dini PCIe_10G_L7_LL(_QSFP) board
  dh2000tq      - build Verilog RTL and synthesize for a Hypersilicon VeriTiger-DH2000TQ board
  b2000t        - build Verilog RTL and synthesize for a Hypersilicon HyperHPC-B2000T board
  pdv72kr2      - build Verilog RTL and synthesize for a ProDesign FM-XC7V2000T-R2 board/module
  dnv7f2a       - build Verilog RTL and synthesize for a Dini DNV7F2A board
  rpp2          - build Verilog RTL and synthesize for a Cadence RPP2 board
  rpp2split     - build Verilog RTL and synthesize for a Cadence RPP2 board
  dnvuf4a       - build Verilog RTL and synthesize for a Dini DNVUF4A board
  klvuf4a       - build Verilog RTL and synthesize for a Cadence KLVUF4A board
  ml507         - build Verilog RTL and synthesize for a Xilinx ML507 board
  ml605         - build Verilog RTL and synthesize for a Xilinx ML605 board
  kc705         - build Verilog RTL and synthesize for a Xilinx KC705 board
  vc707         - build Verilog RTL and synthesize for a Xilinx VC707 board
  vc709         - build Verilog RTL and synthesize for a Xilinx VC709 board
  kcu105        - build Verilog RTL and synthesize for a Xilinx KCU105 board
  vcu108        - build Verilog RTL and synthesize for a Xilinx VCU108 board
  xupv5         - build Verilog RTL and synthesize for a Xilinx XUPV5 board
  c++           - build software from C++ source code
  systemc       - build software from SystemC source code
"""),
\
'verilog-define':
('Controlling bsc', 'list of definitions', [], None, None, append, prepend,
"""Specifies macro definitions (of the form <VAR> or <VAR>=<VAL>) to
be passed to the Verilog simulator using the -D option, to the bsc
link stage and to the synthesis tools."""),
\
'verilog-simulator':
('Controlling bsc', 'simulator name', 'modelsim', 'BSC_VERILOG_SIM', None, override, only_once,
"""This directive can be used to specify which simulator is used for
Verilog simulation."""),
\
'cosim-verilog-simulator':
('Controlling bsc', 'cosim simulator name', 'cvc', [], None, override, only_once,
"""This directive can be used to specify which simulator is used for
CoSim simulation."""),
\
'cosim-scd-file':
('Controlling bsc', 'cosim simulator input file path', 'dump.scd', [], None, override, only_once,
"""Specifies the filename used as input to the CoSimulation executable."""),
\
'imported-verilog-files':
('Controlling bsc', 'list of files', [], None, None, append, prepend,
"""Specifies a list of Verilog files to be included in the linking of the
Verilog simulation executable or synthesis."""),
\
'imported-systemverilog-files':
('Controlling bsc', 'list of files', [], None, None, append, prepend,
"""Specifies a list of SystemVerilog files to be included in the linking of the
SystemVerilog simulation executable or synthesis."""),
\
'imported-vhdl-files':
('Controlling bsc', 'list of files', [], None, None, append, prepend,
"""Specifies a list of VHDL files to be included in the linking of the
Verilog simulation executable or synthesis."""),
\
'imported-c-files':
('Controlling bsc', 'list of files', [], None, None, append, prepend,
"""Specifies a list of C source or object files to be included in the
linking of the Verilog or Bluesim simulation executable."""),
\
'target-root-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of root directory for a particular target where all the build input and output
data will reside."""),
\
'binary-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of output directory for Bluespec binary data files, which
becomes the -bdir option."""),
\
'bsv-source-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The directory containing the BSV source code.  This directory will
be added to the -p path during bsc compilations."""),
\
'bsv-source-directories':
('Describing the project layout', 'list of directories', [], None, None, prepend, prepend,
"""Alternative form of bsv-source-directories which allows multiple
source directories to be added to the -p path during bsc
compilations."""),
\
'bsv-generated-source-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of the output directory for generated BSV source files."""),
\
'exe-file':
('Describing the project layout', 'executable name', 'a.out', None, None, override, only_once,
"""The name of the executable file to generate, for Bluesim, Verilog
simulation or from a C++ compilation.  This is used with the -o
option."""),
\
'info-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of output directory for Bluespec compiler information
files, which becomes the -info-dir option."""),
\
'log-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of output directory for build logs."""),
\
'simulation-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of output directory for Bluesim code files, which becomes
the -simdir option."""),
\
'top-file':
('Describing the project layout', 'file name', 'Top.bsv', None, None, override, only_once,
"""The path to the top-level BSV file."""),
\
'top-module':
('Describing the project layout', 'module name', "'mk-' prefix used with the name derived from the top-level BSV file name", None, None, override, only_once,
"""The name of the top-level BSV module."""),
\
'verilog-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of output Verilog directory, which becomes the -vdir
option."""),
\
'verilog-lib-directories':
('Describing the project layout', 'list of directories', [], None, None, prepend, prepend,
"""A list of paths to search through for verilog files during bsc
compilation, verilog simulation, and fpga synthesis."""),
\
'verilog-inc-directories':
('Describing the project layout', 'list of directories', [], None, None, prepend, prepend,
"""A list of paths to search through for verilog include files for `include statement during
edithdl compilation, and fpga synthesis."""),
\
'c++-compiler':
('SCE-MI', 'executable name', 'g++', 'CXX', None, override, only_once,
"""Specifies the name of the C++ compiler to use."""),
\
'c++-define':
('SCE-MI', 'list of macro definitions', [], None, None, append, prepend,
"""Specifies macro definitions (of the form <VAR> or <VAR>=<VAL>) to
be passed to the C++ compiler using the -D option."""),
\
'c++-files':
('SCE-MI', 'list of source files', [], None, None, prepend, prepend,
"""Lists the C++ source files for the testbench.  If no c++-files
directive is given, all files in the c++-source-directory with
a .c, .cc, .cpp, or .cxx extension will be used."""),
\
'c++-generated-files':
('SCE-MI', 'list of source files', [], None, None, prepend, prepend,
"""Lists the generated C++ source files for the testbench.  The path
will be assumed relative to the c++-generated-source-directory."""),
\
'c++-options':
('SCE-MI', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the C++ compiler."""),
\
'c++-source-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""Specifies a directory from which to retrieve C++ source files."""),
\
'c++-generated-source-directory':
('Describing the project layout', 'directory', '.', None, None, override, only_once,
"""The name of the output directory for generated C++ source files."""),
\
'c++-header-directory':
('SCE-MI', 'directory', 'the c++-generated-source-directory', None, None, override, only_once,
"""The directory in which to write generated SceMi Header .h files.
Defaults value is the 'c++-generated-source-directory'."""),
\
'c++-header-types-package':
('SCE-MI', 'package name', 'the package of top-file', None, None, override, only_once,
"""The name of the top level package which defines the types needed
for probes.  The BSV source used for the probe types is found by
consulting the bsv-source-directory and bsv-source-directories
directives."""),
\
'c++-header-enum-prefix':
('SCE-MI', 'prefix string', 'e_', None, None, override, only_once,
"""The prefix used for enums in SceMi Message Header files."""),
\
'c++-header-member-prefix':
('SCE-MI', 'prefix string', 'm_', None, None, override, only_once,
"""The prefix used for class members in SceMi Message Header files."""),
\
'c++-header-targets':
('SCE-MI', 'list of targets', ['all'], None, verify_header_targets, append, prepend,
"""When generating SceMi header files, this directive defines the groups
of types that will be generated.  Valid values are:
  inputs
  outputs
  probes
  all
  none
"""),
\
'c++-header-probe-code':
('SCE-MI', 'bool', False, None, None, override, only_once,
"""This directive can be used to generate an additional include file
that will add all probes."""),
\
'c++-header-aliases':
('SCE-MI', 'bool', False, None, None, override, only_once,
"""This directive can be used to generate header files for any
relevant aliases for types that are being generated."""),
\
'c++-libraries':
('SCE-MI', 'list of c++ libraries', [], None, None, append, prepend,
"""This directive can be used to specify additional link libraries during
c++ linking step."""),
\
'c++-uses-readback':
('SCE-MI', 'bool', False, None, None, only_once, only_once,
"""Add readback library flags when building C++ testbench.  This flag is
assumed to be true when any 'xilinx-readback' directive is true."""),
\
'probe-vcd-file':
('SCE-MI', 'file name', "scemi_test.vcd", None, None, override, only_once,
"""This directive can be used to specify the VCD file that contains
probe waveforms."""),
\
'scemi-parameters-file':
('SCE-MI', 'file name', 'the value of top-module with a .params suffix', None, None, override, only_once,
"""The name to use when generating the SCE-MI parameters file.  This
becomes the --params option to scemilink."""),
\
'scemi-tb':
('SCE-MI', 'bool', False, None, None, only_once, only_once,
"""This directive is used to designate a target as being a SCE-MI
testbench."""),
\
'scemi-tcp-port':
('SCE-MI', 'number', 7381, None, None, override, only_once,
"""The TCP port number for the TCP link type.  This becomes the
--port option to scemilink, and is used only when scemi-type=TCP."""),
\
'scemi-type':
('SCE-MI', 'link type', None, None, verify_scemi_type, override, only_once,
"""When building a SCE-MI DUT, this directive defines the type of
SCE-MI link to use.  Valid values are:
  TCP
  PCIE_DINI
  PCIE_VIRTEX5
  PCIE_VIRTEX6
  PCIE_KINTEX7
  PCIE_KINTEXU
  PCIE_VIRTEX7
  PCIE_VIRTEXU
  EVE
  SCEMI
Bsc compilation will be passed a -D SCEMI_<scemi-type> definition
based on this directive.  Without this directive, a non-SCE-MI
DUT build target will be assumed, or an appropriate SCE-MI target
will be selected based on the build-for directive."""),
\
'scemi-infrastructure-style':
('SCE-MI', 'style', 'BLUENOC', None, verify_scemi_infrastructure_style, override, only_once,
"""When building a SCE-MI DUT, this directive defines the internal SCE-MI
architecture that is used.  Valid values are:
  CLASSIC
  BLUENOC
Bsc compilation will be passed a -D SCEMI_INFRA_<style> definition
based on this directive."""),
\
'scemilink-options':
('SCE-MI', 'list of options', [], None, None, append, prepend,
"""This directive can be used to supply options to the scemilink
utility."""),
\
'shared-lib':
('SCE-MI', 'shared libarary name', None, None, None, override, only_once,
"""This directive causes a shared library to be produced instead
of an executable file."""),
\
'systemc-home':
('SCE-MI', 'directory', None, 'SYSTEMC', None, override, only_once,
"""The root of the SystemC installation, used for -I and -L options when
a target built for SystemC uses the scemi-tb directive."""),
\
'tcl-home':
('SCE-MI', 'directory', '$BLUESPECDIR/tcllib', 'TCL_HOME', None, override, only_once,
"""The root of the TCL area, used when the uses-tcl directive
is supplied."""),
\
'uses-tcl':
('SCE-MI', 'bool', False, None, None, only_once, only_once,
"""This directive is used to indicate that a C++ testbench target
uses the TCL library."""),
\
'run-design-editor':
('RTL editing', 'bool', False, None, None, override, only_once,
"""This directive is usd to indicate that the edithdl will be used to
modified the verilog netlist."""),
\
'pin-file':
('Semu', 'file name', '', None, None, override, only_once,
"""The path to the pin file for the DUT."""),
\
'generate-semu-wrapper':
('Semu', 'bool', False, None, None, override, only_once,
"""This directive is used to indicate that BSV files should be generated
to import a Verilog DUT and connect it to a SceMi link, as indicated in
the pin file."""),
\
'generate-semu-testbench':
('Semu', 'bool', False, None, None, override, only_once,
"""This directive is used to indicate that C/C++ code and Tcl GUI code
should be generated to connect via SceMi to the DUT."""),
\
'semu-user-testbench':
('Semu', 'bool', False, None, None, override, only_once,
"""This directive indicates that a 'do_test' function will be provided
in the 'c++-files' and is to be integrated into the generated Tcl GUI."""),
\
'design-editor-partition-for':
('RTL editing', 'platform', None, None, verify_partition_for, override, only_once,
"""Specifies the FPGA system to build for.
Valid values are: (only dn7002 for now)
  none          - partitioning not active
  dn7002        - partitioning Verilog RTL for a Dini 7002 board
  dn7006        - partitioning Verilog RTL for a Dini 7006 board
  dn7406        - partitioning Verilog RTL for a Dini 7406 board
  dn10ghxtll    - partitioning Verilog RTL for a Dini PCIe_10G_HXT_LL board
  dn10gk7ll     - partitioning Verilog RTL for a Dini PCIe_10G_L7_LL(_QSFP) board
  dh2000tq      - partitioning Verilog RTL for a Hypersilicon VeriTiger-DH2000TQ board
  b2000t        - partitioning Verilog RTL for a Hypersilicon HyperHPC-B2000T board
  pdv72kr2      - partitioning Verilog RTL for a ProDesign FM-XC7V2000T-R2 board/module
  dnv7f2a       - partitioning Verilog RTL for a Dini DNV7F2A board
  rpp2          - partitioning Verilog RTL for a Cadence RPP2 board
  rpp2split     - partitioning Verilog RTL for a Cadence RPP2 board
  dnvuf4a       - partitioning Verilog RTL for a Dini DNVUF4A board
  klvuf4a       - partitioning Verilog RTL for a Cadence KLVUF4A board
  ml507         - partitioning Verilog RTL for a Xilinx ML507 board
  ml605         - partitioning Verilog RTL for a Xilinx ML605 board
  kc705         - partitioning Verilog RTL for a Xilinx KC705 board
  vc707         - partitioning Verilog RTL for a Xilinx VC707 board
  vc709         - partitioning Verilog RTL for a Xilinx VC709 board
  kcu105        - partitioning Verilog RTL for a Xilinx KCU105 board
  vcu108        - partitioning Verilog RTL for a Xilinx VCU108 board
  xupv5         - partitioning Verilog RTL for a Xilinx XUPV5 board
Currently only dn7002 is supported."""),
\
'design-editor-options':
('RTL editing', 'list of options', [], None, None, append, prepend,
"""This directive can be used to supply options to the edithdl
utility.  Note that default options start the graphical interface.
Set this option to -batch to run the tool in batch mode."""),
\
'design-editor-output-directory':
('RTL editing', 'directory', '.', None, None, override, only_once,
"""The name of output directory for the modified verilog source files.
The verilog files will have unique names and will not conflict with
the user's source files."""),
\
'design-editor-script':
('RTL editing', 'file name', 'replay_edits.script', None, None, override, only_once,
"""This directive can be used to specify the script for use with edithdl in modifying
the verilog source files.  The script is used when --batch option is supplied in
the design-editor-options."""),
\
'design-editor-edit-params':
('RTL editing', 'bool', False, None, None, only_once, only_once,
"""This directive is usd to indicate that the SceMi params file is to be
updated in the verilog source files editing flow."""),
\
'design-editor-output-params':
('RTL editing', 'file name', 'the value of top-module with a _EDITED.params suffix', None, None, override, only_once,
"""The name to use when generating the modified SCE-MI parameters file after completing the
edithdl flow."""),
\
'scemi-clk-signals':
('RTL editing', 'list of clk signals', [], None, None, override, only_once,
"""This directive is usd to indicate all the signals that will be controlled by scemi.
This value will be used to properly process and edit verilog files."""),
\
'scemi-reset-signals':
('RTL editing', 'list of reset signals', [], None, None, override, only_once,
"""This directive is usd to indicate all the signals that will be controlled by scemi.
This value will be used to properly process and edit verilog files."""),
\
'input-vcd-file':
('VCD player', 'file name', '', None, None, override, only_once,
"""This directive can be used to specify the input VCD file for the VCD player."""),
\
'input-vcd-dut-path':
('VCD player', 'file name', '', None, None, override, only_once,
"""This directive can be used to specify the hierchical path to the dut in the input VCD file
for the VCD player."""),
\
'board-top-module':
('Describing the project layout', 'module name', '', None, None, override, only_once,
"""The alternate name of the top-level verilog which will override the top-module directive
when synthesizing or linking a targeted fpga verilog that may contain the design."""),
\
'workstation-project-file':
('Workstation', 'file name', "project.bspec", None, None, override, only_once,
 """This directive can be used to specify the project file for use with
the Bluespec Workstation."""),
\
'create-workstation-project':
('Workstation', 'bool', False, None, None, only_once, only_once,
 """This directive is used to indicate that the Bluespec Workstation
will be used to assist in debug.  A default project file will be
generated for use in the Workstation."""),
\
'extends-target':
('Section composition', 'section name', None, None, None, not_inherited, only_once,
"""Incorporates the directives of the named section into this section.
If extension duplicates a directive, the conflict is resolved in a
directive-specific manner: either by using the local directive or by
merging the values of the directives."""),
\
'hide-target':
('Section composition', 'bool', False, None, None, not_inherited, only_once,
"""Do not allow targets based on this section to be named on the
command line or used as a default target.  This directive is not
inherited when the section is extended."""),
\
'post-targets':
('Section composition', 'list of targets', [], None, None, append, append,
"""This directive lists targets which should be run after the stages
for the current section."""),
\
'pre-targets':
('Section composition', 'list of targets', [], None, None, prepend, prepend,
"""This directive lists targets which should be run before the stages
for the current section."""),
\
'sub-targets':
('Section composition', 'list of targets', [], None, None, prepend, prepend,
"""This directive lists targets which should be run in sequence as the
action of the current section.  A section which uses the 'sub-targets'
directive will not be considered to build any direct products of its
own.  This directive can be used with an otherwise empty section to
create a meta-target which names a sequence of build targets."""),
\
'run-shell-<STAGE>-<N>':
('Explicit command targets', 'command', None, None, None, not_inherited, only_once,
"""Each run-shell-<STAGE>-<N> directive specifies a command to be
executed using the shell.  Commands are grouped by the <STAGE>
part of the name, and within each stage commands are executed in
ascending order of their numeric -<N> suffix."""),
\
'stage-order':
('Explicit command targets', 'list of stages', [], None, None, not_inherited, only_once,
"""When run-shell-<STAGE>-<N> directives are given for multiple
stages, this directive specifies the order in which stages are
to be executed.  If not given, the order is undefined."""),
\
'board-support-directory':
('FPGA Synthesis', 'directory', '$BLUESPECDIR/board_support', None, None, override, only_once,
"""The directory from which to retrieve board support files."""),
\
'altera-directory':
('FPGA Synthesis', 'directory', '.', None, None, override, only_once,
"""The directory in which to perform Quartus synthesis for Altera designs."""),
\
'intel-directory':
('FPGA Synthesis', 'directory', '.', None, None, override, only_once,
"""The directory in which to perform Quartus synthesis for Intel designs."""),
\
'board-top-fpga-file':
('FPGA Synthesis', 'file name', 'fpga_a.v', None, None, override, only_once,
 """This directive can be used to specify the top level verilog file that will be used
for Quartus fpga synthesis."""),
\
'board-top-fpga-file-a':
('FPGA Synthesis', 'file name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog file that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-file-a' directive
specifies the top level verilog file for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-file directive for
specifying top verilog file."""),
\
'board-top-fpga-file-b':
('FPGA Synthesis', 'file name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog file that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-file-a' directive
specifies the top level verilog file for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-file directive for
specifying top verilog file."""),
\
'board-top-fpga-file-d':
('FPGA Synthesis', 'file name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog file that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-file-a' directive
specifies the top level verilog file for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-file directive for
specifying top verilog file."""),
\
'board-top-fpga-file-e':
('FPGA Synthesis', 'file name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog file that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-file-a' directive
specifies the top level verilog file for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-file directive for
specifying top verilog file."""),
\
'board-top-fpga-module':
('FPGA Synthesis', 'module name', 'fpga_a', None, None, override, only_once,
 """This directive can be used to specify the top level verilog module that will be used
for Quartus fpga synthesis."""),
\
'board-top-fpga-module-a':
('FPGA Synthesis', 'module name', 'fpga_a', None, None, override, only_once,
 """This directive can be used to specify the top level fpga verilog module that will be
used for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level fpga verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-module directive for
specifying top fpga verilog module."""),
\
'board-top-fpga-module-b':
('FPGA Synthesis', 'module name', 'fpga_b', None, None, override, only_once,
 """This directive can be used to specify the top level fpga verilog module that will be
used for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level fpga verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-module directive for
specifying top fpga verilog module."""),
\
'board-top-fpga-module-d':
('FPGA Synthesis', 'module name', 'fpga_d', None, None, override, only_once,
 """This directive can be used to specify the top level fpga verilog module that will be
used for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level fpga verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-module directive for
specifying top fpga verilog module."""),
\
'board-top-fpga-module-e':
('FPGA Synthesis', 'module name', 'fpga_a', None, None, override, only_once,
 """This directive can be used to specify the top level fpga verilog module that will be
used for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level fpga verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-fpga-module directive for
specifying top fpga verilog module."""),
\
'board-top-module-a':
('FPGA Synthesis', 'module name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog module that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-module directive for
specifying top verilog module."""),
'board-top-module-b':
('FPGA Synthesis', 'module name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog module that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-module directive for
specifying top verilog module."""),
'board-top-module-d':
('FPGA Synthesis', 'module name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog module that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-module directive for
specifying top verilog module."""),
\
'board-top-module-e':
('FPGA Synthesis', 'module name', None, None, None, override, only_once,
 """This directive can be used to specify the top level verilog module that will be used
for Quartus fpga synthesis for each specific fpga on a board with multiple chips.
The 'X' can have different values that match the designations of the chip to be
synthesized (ie. 'a', 'b', etc...).  For example, 'board-top-fpga-module-a' directive
specifies the top level verilog module for running Quartus synthesis on the fpga_a.
When this directive is set, it overrides the board-top-module directive for
specifying top verilog module."""),
\
'use-quartus-sta':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
 """Use the new Quartus timing analyzer (quartus_sta) instead of the
classic timing analyzer (quartus_tan)."""),
\
'quartus-map-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Quartus map tool."""),
\
'quartus-fit-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Quartus fit tool."""),
\
'quartus-asm-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Quartus asm tool."""),
\
'quartus-tan-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Quartus tan tool."""),
\
'quartus-sta-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Quartus sta tool."""),
\
'quartus-drc-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Quartus drc tool."""),
\
'quartus-qsf-file':
('FPGA Synthesis', 'path to alternate QSF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate QSF file.  If provided, this
QSF file will be used instead of the default QSF file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-qsf-file-a':
('FPGA Synthesis', 'path to alternate QSF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate QSF file.  If provided, this
QSF file will be used instead of the default QSF file template for fpga_a.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-qsf-file-b':
('FPGA Synthesis', 'path to alternate QSF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate QSF file.  If provided, this
QSF file will be used instead of the default QSF file template for fpga_b.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-qsf-file-d':
('FPGA Synthesis', 'path to alternate QSF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate QSF file.  If provided, this
QSF file will be used instead of the default QSF file template for fpga_d.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-qsf-file-e':
('FPGA Synthesis', 'path to alternate QSF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate QSF file.  If provided, this
QSF file will be used instead of the default QSF file template for fpga_e.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-qsf-supplement-file':
('FPGA Synthesis', 'path to supplemental QSF file', None, None, None, override, only_once,
"""Specifies the path to a supplemental QSF file.  If provided, this
QSF file will be appended to the end of the default QSF file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-tcl-supplement-file':
('FPGA Synthesis', 'path to supplemental tcl file', None, None, None, override, only_once,
"""Specifies the path to a supplemental tcl file (uses in Quartus synthesis for Intel boards).
If provided, this tcl file will be appended to the end of the default tcl file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-sdc-file':
('FPGA Synthesis', 'path to alternate SDC template file', None, None, None, override, only_once,
"""Specifies the path to an alternate SDC file.  If provided, this
SDC file will be used instead of the default SDC file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-sdc-file-a':
('FPGA Synthesis', 'path to alternate SDC template file', None, None, None, override, only_once,
"""Specifies the path to an alternate SDC file.  If provided, this
SDC file will be used instead of the default SDC file template for fpga_a.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-sdc-file-b':
('FPGA Synthesis', 'path to alternate SDC template file', None, None, None, override, only_once,
"""Specifies the path to an alternate SDC file.  If provided, this
SDC file will be used instead of the default SDC file template for fpga_b.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-sdc-file-d':
('FPGA Synthesis', 'path to alternate SDC template file', None, None, None, override, only_once,
"""Specifies the path to an alternate SDC file.  If provided, this
SDC file will be used instead of the default SDC file template for fpga_d.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-sdc-file-e':
('FPGA Synthesis', 'path to alternate SDC template file', None, None, None, override, only_once,
"""Specifies the path to an alternate SDC file.  If provided, this
SDC file will be used instead of the default SDC file template for fpga_e.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'quartus-sdc-supplement-file':
('FPGA Synthesis', 'path to supplemental SDC file', None, None, None, override, only_once,
"""Specifies the path to a supplemental SDC file.  If provided, this
SDC file will be appended to the end of the default SDC file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'generate-qxp-file':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Generate a Quartus post-synthesis netlist file."""),
\
'generate-vo-file':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Generate a Quartus post-synthesis verilog simulation netlist file."""),
\
'on-fpga':
('FPGA Synthesis', 'list of fpgas', ['A'], None, None, override, only_once,
"""The designator of the FPGA on which the design will be loaded."""),
\
'program-fpga':
('FPGA Synthesis', 'bool', False, None, None, override, only_once,
"""If set, after FPGA synthesis an attempt will be made to program the
board.  If this directive is not used, then a file will be generated
which the user must manually load onto the FPGA."""),
\
'pre-program-command':
('FPGA Synthesis', 'command', None, None, None, override, only_once,
"""A command to be run before programming the FPGA.  This is useful,
for example, to shutdown a PCIE slot safely."""),
\
'post-program-command':
('FPGA Synthesis', 'command', None, None, None, override, only_once,
"""A command to be run after programming the FPGA.  This is useful,
for example, to initialize or re-enable a PCIE device."""),
\
'design-clock-frequency':
('FPGA Synthesis', 'float', 0.000, None, None, override, only_once,
"""If set, sets the target clock frequency (mhz) for the design.
This value will be used to determine the synthesis constraints and scemi clock."""),
\
'scemi-clock-period':
('FPGA Synthesis', 'float', 0.000, None, None, override, only_once,
"""If set, sets the reference clock period that SceMi uses to
create the uncontrolled and controlled clock domains.  This value
propagates into the synthesis constraints."""),
\
'memory-clock-period':
('FPGA Synthesis', 'float', 0.000, None, None, override, only_once,
"""If set, sets the reference clock period that is used to drive
the memory interface, if one exists.  This value propagates into
the synthesis constraints."""),
\
'sodimm-style':
('FPGA Synthesis', 'SODIMM style', 'NONE', None, verify_sodimm_style, override, only_once,
"""This directive controls the synthesis directives associated with a SODIMM
connector on this FPGA.  Valid values are:
  NONE
  DDR2
  DDR3
  DDR4
  SRAM
If you don't know your board's sodimm style, use any of the above values other than NONE
"""),
\
'xilinx-directory':
('FPGA Synthesis', 'directory', '.', None, None, override, only_once,
"""The directory in which to perform XST synthesis for Xilinx designs."""),
\
'xilinx-use-planahead':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Use the new Xilinx tool, PlanAhead, to synthesize the design."""),
\
'xilinx-use-precompiled':
('FPGA Synthesis', 'bool', False, None, None, override, only_once,
"""While using PlanAhead, use pre-synthesized ngc files for boilerplate blocks."""),
\
'xilinx-preserve-signals':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Set PlanAhead options so as to preserve signals for ChipScope debugging."""),
\
'xilinx-readback':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Direct PlanAhead to synthesize the RTL and generate ancillary files as
needed for readback debugging."""),
\
'xilinx-readback-jtag':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Direct PlanAhead to synthesize the RTL and generate ancillary files as
needed for readback debugging, using a jtag chain solution."""),
\
'xilinx-ooc-synthesis':
('FPGA Synthesis', 'bool', False, None, None, only_once, only_once,
"""Direct PlanAhead to synthesize the RTL as an out-of-context (OOC) module."""),
\
'xilinx-patcl-file':
('FPGA Synthesis', 'path to alternate PlanAhead TCL template file', None, None, None, override, only_once,
"""Specifies the path to an alternate PlanAhead TCL script.  If provided, this
TCL file will be used instead of the default TCL script template.  The special
identifiers '__BLUESPECDIR__', '__BOARD__', '__VDIRS__', '__TOP_MODULE__'
and '__SODIMM_STYLE__' will be replaced everywhere they occur in the given
file with appropriate substitutions."""),
\
'xilinx-patcl-supplement-file':
('FPGA Synthesis', 'path to supplemental PlanAhead TCL template file', None, None, None, override, only_once,
"""Specifies the path to an supplemental PlanAhead TCL script.  If provided, this
TCL file will be appended to the end of the default TCL script template.  The special
identifiers '__BLUESPECDIR__', '__BOARD__', '__VDIRS__', '__TOP_MODULE__'
and '__SODIMM_STYLE__' will be replaced everywhere they occur in the given
file with appropriate substitutions."""),
\
'xilinx-xst-options':
('FPGA Synthesis', 'list of options', ['-intstyle ise'], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx xst tool."""),
\
'xilinx-map-options':
('FPGA Synthesis', 'list of options', [ '-w', '-pr b', '-ol high', '-timing'
                                      , '-global_opt speed', '-logic_opt on'
                                      , '-register_duplication', '-retiming on'
                                      , '-equivalent_register_removal on'
                                      , '-xe n', '-lc auto'
                                      ], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx map tool."""),
\
'xilinx-trce-options':
('FPGA Synthesis', 'list of options', ['-e 3', '-u 3'], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx trce tool."""),
\
'xilinx-par-options':
('FPGA Synthesis', 'list of options', ['-w', '-ol high'], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx par tool."""),
\
'xilinx-ngdbuild-options':
('FPGA Synthesis', 'list of options', [ '-intstyle ise', '-dd ./_ngo'
                                      , '-nt timestamp', '-aut'
                                      ], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx ngdbuild tool."""),
\
'xilinx-bitgen-options':
('FPGA Synthesis', 'list of options', ['-w'], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx bitgen tool."""),
\
'xilinx-impact-options':
('FPGA Synthesis', 'list of options', [], None, None, append, prepend,
"""Specifies options to be passed to the Xilinx impact tool."""),
\
'xilinx-xdc-file':
('FPGA Synthesis', 'path to alternate XDC template file', None, None, None, override, only_once,
"""Specifies the path to an alternate XDC file.  If provided, this
XDC file will be used instead of the default XDC file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-xdc-supplement-file':
('FPGA Synthesis', 'path to supplemental XDC file', None, None, None, override, only_once,
"""Specifies the path to a supplemental XDC file.  If provided, this
XDC file will be appended to the end of the default XDC file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-ucf-file':
('FPGA Synthesis', 'path to alternate UCF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate UCF file.  If provided, this
UCF file will be used instead of the default UCF file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-ucf-supplement-file':
('FPGA Synthesis', 'path to supplemental UCF file', None, None, None, override, only_once,
"""Specifies the path to a supplemental UCF file.  If provided, this
UCF file will be appended to the end of the default UCF file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-xcf-file':
('FPGA Synthesis', 'path to alternate XCF template file', None, None, None, override, only_once,
"""Specifies the path to an alternate XCF file.  If provided, this
XCF file will be used instead of the default XCF file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-xcf-supplement-file':
('FPGA Synthesis', 'path to supplemental XCF file', None, None, None, override, only_once,
"""Specifies the path to a supplemental XCF file.  If provided, this
XCF file will be appended to the end of the default XCF file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-scr-file':
('FPGA Synthesis', 'path to alternate SCR template file', None, None, None, override, only_once,
"""Specifies the path to an alternate SCR file.  If provided, this
SCR file will be used instead of the default SCR file template.
The special identifiers '__BLUESPECDIR__', '__BOARD__',
'__VDIRS__', '__TOP_MODULE__' and '__SODIMM_STYLE__' will be
replaced everywhere they occur in the given file with appropriate
substitutions."""),
\
'xilinx-synth-strategy':
('FPGA Synthesis', 'strategy to employ for Xilinx synthesis', 'TimingWithIOBPacking', None, None, override, only_once,
"""Specifies the overall strategy to use for Xilinx
synthesis with PlanAhead/Vivado"""),
\
'xilinx-impl-strategy':
('FPGA Synthesis', 'strategy to employ for Xilinx implementation', 'MapLogicOptParHighExtra', None, None, override, only_once,
"""Specifies the overall strategy to use for Xilinx
implementation with PlanAhead/Vivado"""),
\
'prodesign-pcie-socket':
('FPGA Synthesis', 'ProDesign expansion socket used for PCIe connection', 'TB2', None, None, override, only_once,
"""Specifies the physical socket for the FMXC7V2000TR2
module connection via PCIe to the Host machine"""),
\
'pre-stage-compile_for_bluesim':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-compile_for_bluesim':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-compile_for_verilog':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-compile_for_verilog':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-generate_scemi_parameters':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-generate_scemi_parameters':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-edithdl_modify_verilog':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-edithdl_modify_verilog':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-link_for_bluesim':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-link_for_bluesim':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-link_for_verilog':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-link_for_verilog':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-link_for_cosim':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-link_for_cosim':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-build_systemc_tb':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-build_systemc_tb':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s)."""),
\
'pre-stage-build_c++_tb':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each pre-stage-<STAGE> directive specifies a command to be
executed before the stage command(s)."""),
\
'post-stage-build_c++_tb':
('Explicit command targets', 'command', None, None, None, override, only_once,
"""Each post-stage-<STAGE> directive specifies a command to be
executed after the stage command(s).""")
}

# check if a character is escaped by a backslash
def is_escaped(str,pos):
  esc = False
  n = 0
  for c in str:
    if n == pos:
      return esc
    if c == '\\':
      esc = not esc
    else:
      esc = False
    n = n + 1
  return False

# remove all of the backslashes used for escaping
# (applies to \, #, $ and end-of-line)
def elim_escapes(str):
  esc = False
  new_str = ''
  n = 0
  l = len(str)
  for c in str:
    if c == '\\':
      esc = not esc
      if esc:
        if n != l-1 and str[n+1] != '\\' and str[n+1] != '#' and str[n+1] != '$':
          new_str += c
      else:
        new_str += c
    else:
      esc = False
      new_str += c
    n = n + 1
  return new_str

# replace non-escaped ${VAR} with the value of VAR in
# the environment, or error if it is undefined
def subst_env_vars(section,str,pos=0):
  idx = str[pos:].find('${')

  # no ${ found
  if idx == -1:
    return ('ok',str)

  # false alarm because $ is escaped, process rest of string
  if is_escaped(str,pos+idx):
    return subst_env_vars(section,str,pos+idx+2)

  # we got ${ now find the matching }
  idx2 = str[pos+idx:].find('}')
  if idx2 == -1:
    return ('error', 'encountered ${ with no terminating }')
  else:
    def replace_and_resume():
      new_str = str[:pos+idx] + var_value + str[pos+idx+idx2+1:]
      new_pos = pos + idx + idx2 - len(var_name) + len(var_value) - 2
      return subst_env_vars(section,new_str,new_pos)

    # lookup the named variable
    var_name = str[pos+idx+2:pos+idx+idx2]
    if var_name in os.environ:
      var_value = os.getenv(var_name)
      # replace the ${..} with the value and resume parsing
      return replace_and_resume()
    elif var_name.lower() == 'project_root':
      var_value = PROJECT_ROOT
      # replace the ${..} with the value and resume parsing
      return replace_and_resume()
    elif var_name.lower() == 'build_section':
      var_value = section
      # replace the ${..} with the value and resume parsing
      return replace_and_resume()
    elif var_name.lower() == 'build_target':
      var_value = CURRENT_TARGET
      # replace the ${..} with the value and resume parsing
      return replace_and_resume()
    elif var_name.lower() == 'cxx_family':
      var_value = subprocess.Popen([os.getenv('BLUESPECDIR') + '/bin/bsenv', 'c++_family'], stdout=subprocess.PIPE).communicate()[0].strip()
      # replace the ${..} with the value and resume parsing
      return replace_and_resume()
    elif var_name.lower() == 'tcl_libdir':
      var_value = subprocess.Popen([os.getenv('BLUESPECDIR') + '/bin/bsenv', 'tcl_libdir'], stdout=subprocess.PIPE).communicate()[0].strip()
      # replace the ${..} with the value and resume parsing
      return replace_and_resume()
    else:
      return ('error', 'environment variable %s is not defined' % var_name);

def parse_one_line(project,section,l):

  # ignore leading whitespace
  l = l.lstrip()
  # remove trailing newline and whitespace
  l = l.rstrip()

  n = len(l)

  # ignore blank lines
  if n == 0:
    return ('no-action',None)

  # does this look like a section header?
  if l[0] == '[':
    if l[n-1] == ']':
      name=l[1:n-1].lower()
      if name in project:
        if name == 'default':
          # default section can have supplemental options.
          return ('update-section',name)
        else:
          # duplicate section name
          # todo: support duplicate section names (as supplemental/superceeding directives)
          return ('error', "section name '%s' duplicates a previous section" % name)
      else:
        return ('new-section',name)
    else:
      return ('error', "invalid section header format")
  elif section != None:
    # this is a directive
    first_colon = l.find(':')
    first_equal = l.find('=')
    invert_bool = False
    m1 = max(first_colon,first_equal)
    if first_colon == -1:
      m2 = first_equal
    else:
      m2 = first_colon
    if m1 == -1:
      # must be a boolean directive
      if l[0] == '!':
        var = l[1:]
        value = False
      else:
        var = l[:]
        value = True
    else:
      # using var=value or var: value syntax
      var = l[0:m2].strip()
      value = l[m2+1:].strip()
    # check variable name against allowed directives
    var = var.lower()
    if var in directive_descriptions:
      (category,type,defval,envvar,validator,extfn,parfn,text) = directive_descriptions[var]
      orig_value = value
      if type.startswith('list of'):
        if m1 == -1:
          return ('error', "%s directive requires a list of values" % var)
        value = value.split()
      elif m1 == -1 and type != 'bool':
        return ('error', "%s directive requires a value" % var)
    elif not var.startswith('run-shell'):
      return ('error', "'%s' is not a supported directive" % var)

    # If a sodimm-style directive exists with no explicit value,
    # use a temporary value that will be fixed up later per
    # target board to DDR2, DDR3, DDR4, SRAM, etc.
    if var == 'sodimm-style' and value == '': value = 'DDR3'

    return ('add-to-section',(var,value))
  else:
    # syntax error
    return ('error', "expected a section header or comment")

# Parse a project file using an INI-like syntax
# Returns a map from section names to lists of (directive,value) tuples.
def parse_project_file(project,file,filename):
  section = None
  line_no = 0
  accum_line = ''
  for orig_line in file:
    line_no = line_no + 1
    # strip out the comment, if any
    l = orig_line
    for n in range(len(orig_line)):
      if orig_line[n] == '#' and not is_escaped(orig_line,n):
        l = orig_line[0:n]
        break
    # if line ends with an unescaped backslash, this is a continuation
    l = l.rstrip()
    n = len(l)
    if n > 0 and l[-1] == '\\' and not is_escaped(l,n-1):
      # accumulate and process later
      accum_line += orig_line[0:n-1]
    else:
      # finished accumulating, call the parsing routine and handle the result
      l = accum_line + l
      accum_line = ''
      (action,value) = parse_one_line(project,section,l);
      if action == 'new-section':
        section = []
        project.update({value:section})
      elif action == 'add-to-section':
        section += [value]
      elif action == 'update-section':
        section = project[value]
      elif action == 'error':
        raise ProjectFileError(filename, line_no, orig_line.rstrip(),value);

  # if the file ends in an accumulation, attempt to process the remainder
  if accum_line != '':
    (action,value) = parse_one_line(project,section,accum_line);
    if action == 'new-section':
      section = []
      project.update({value:section})
    elif action == 'add-to-section':
      section += [value]
    elif action == 'update-section':
      section = project[value]
    elif action == 'error':
      raise ProjectFileError(filename, line_no, orig_line.rstrip(),value);

  return project

# ##################################################################
# Documentation and help

# When the --doc option is used, this function builds and prints the
# documentation text.  There is some header information describing
# the command line options and the project file format, followed by
# a listing of all of the directives (generated from the
# directive_descriptions above), and finally some examples of command
# line usage and project file construction.
def print_documentation():
  # extract out directive information
  topic_groups = {}
  for (name, desc) in directive_descriptions.items():
    (topic,type,defval,envvar,validator,extfn,parfn,text) = desc
    if topic in topic_groups:
      topic_groups[topic].update({name:(type,defval,envvar,text)})
    else:
      topic_groups[topic] = {name:(type,defval,envvar,text)}
  # print header
  print """\
OVERVIEW

  The 'build' utility codifies the rules for building Bluespec
  projects in a single place and eliminates most of the boilerplate
  involved in setting up a project, with the goal that sensible
  defaults are used and deviations from the defaults must only be
  specified once per project.

  It also allows for a repeatable build procedure with safe defaults,
  erring on the side of rebuilding too much rather than using a stale
  build product.

USAGE

  The 'build' utility reads a project description from a project
  configuration file, specified with the -p (or --project) option.  If
  none is given, it reads from 'project.bld' by default.

  The project description defines a number of build targets and
  provides directives that describe what the target is and how it
  should be rebuilt.  All arguments to the build utility are
  interpreted as targets which should be rebuilt.  If no targets are
  supplied, the build utility will try to determine a sensible default
  action based on the project description file.

  Each build target comprises a number of stages that are executed in
  sequence to rebuild that target.

  To see which targets are available in a project, and which stages
  are involved in rebuilding each target, use the -l (or --list)
  option.

  By default, all of the stages in a selected target are executed, so
  that the target is fully rebuilt from scratch.  The user can select
  a subset of stages to execute using the -t (or --to) and -f (or
  --from) options.

  The --dry-run option allows the commands executed in each stage to
  be displayed without actually executing any of them.

  As the build utility executes, it logs the output of commands into
  log files using the naming scheme <target>_<stage>.log.  If the -v
  (or --verbose) option is given, the command output is also displayed
  on the screen.

PROJECT FILES

  Project files use a simple configuration file syntax similar to a
  Windows .ini file syntax.  The file is divided into sections by
  target names enclosed in square brackets:

    [target1]
    ...

    [target2]
    ...

  Beneath each section header there can be a number of directives of
  the form:

    var: value

  or:

    var=value

  Values are typically strings, strings separated by spaces, or
  boolean values encoded as 'y'/'n', 'yes'/'no', '1'/'0',
  'true'/'false' or 'on'/'off'.  Boolean values can also use the
  alternate single-token syntax 'var' instead of 'var: true' and
  '!var' instead of 'var: false'.

  Values can contain environment variable references of the form
  ${VAR}.  The content of the named environment variable is
  substituted into the value string before it is processed.  It is an
  error if the named variable is not defined in the environment.

  The special variable ${PROJECT_ROOT} holds the name of the
  directory containing the project file.

  The special variable ${BUILD_TARGET} holds the top-level target
  used to run the given directive.

  The special variable ${BUILD_SECTION} holds the name of the
  section containing the current directive.

  The special variable ${CXX_FAMILY} holds the bsenv response to
  the cxx_family command -- A special path for library linkage.

  Comments begin with '#' and continue until the end of the line.

  The section headers define the various build targets and the
  directives within the sections describe the target and its build
  procedure.  The build utility constructs the required command
  sequence based on the supplied directives for each target.

  Sections can be hidden using the 'hide-target' directive.  Hidden
  sections cannot be used as targets directly.  However, they can be
  used to define other sections using the 'extends-target' mechanism.
  Any section can name another section in an
  'extends-target: <section>' directive, causing the directives of
  that section to be incorporated into the current section.  When a
  directive in the current section also appears in the extended
  section, the values are reconciled in a directive-dependent manner.

  The user can define defaults in a special section (using the special
  header [DEFAULT]), whose directives apply to all targets.  The
  DEFAULT section is treated as a hidden section which is extended by
  all other sections.

  It is possible to define targets which simply sequence the stages of
  other targets, using the 'sub-targets: <list of targets>' directive.
  A section which contains this directive will incorporate the
  sequence of stages for the listed targets, in order, and will not
  define any stages locally.  Thus, the 'sub-targets' directive allows
  the creation of "meta-targets".

  It is also possible to define targets which will run before and after
  the stages defined locally in a section using the 'pre-targets' and
  'post-targets' directives.

  Targets can be made conditional using the 'skip-target-when'
  directive.  This directive provides a command to be executed in a
  shell prior to building the target.  If the command returns an exit
  status of 0, the stages for the target will be skipped.  There is
  also a 'skip-target-unless' directive which will skip the target
  stages when the exit status is not 0.

  Some targets attempt to clean directories before they run.  If
  multiple targets are run and a later target wishes to clean a
  directory or file that an earlier target has already cleaned, the
  second cleaning will be suppressed.

  The backslash character is used in four escape sequences:
    \\# is interpreted as a single '#' character that does not
       start a comment.
    \\$ is interpreted as a single '$' character that does not
       introduce an environment variable name.
    \\\\ is interpreted as a single '\\' character that does not
       escape the following character.
    \\  at the end of a line is a continuation marker for values
       that span multiple lines.
"""
  # print directive data
  print "DIRECTIVES\n"
  topics = topic_groups.keys()
  topics.sort()
  for topic in topics:
    print '%s\n' % topic
    directives = topic_groups[topic].keys()
    directives.sort()
    for d in directives:
      (type,defval,envvar,text) = topic_groups[topic][d]
      print '  %s: <%s>\n' % (d,type)
      msg = text.splitlines()
      n = len(msg)
      show_default = True
      if defval == None and envvar == None:
        show_default = False
      if type.startswith('list of') and (defval == None or defval == []):
        show_default = False
      if show_default:
        # properly format default value string
        if defval != None and envvar != None:
          defstr = "Default value is '%s' or uses $%s if defined." % (defval,envvar)
        elif type == 'number' and defval != None:
          defstr = "Default value is %d." % defval
        elif type == 'bool' and defval != None:
          if defval:
            defstr = "Default value is true."
          else:
            defstr = "Default value is false."
        elif type.startswith('list of') and isinstance(defval,list):
          defstr = "Default list is: %s." % ' '.join(defval)
        elif defval != None and ' ' in str(defval):
          defstr = "Default value is %s." % defval
        elif defval != None:
          defstr = "Default value is '%s'." % defval
        else:
          defstr = "Default value is $%s." % envvar
        # check if the default string will fit on the last line
        strlen = len(defstr)
        txtlen = len(msg[n-1])
        if txtlen > 65:
          m = 0
        else:
          m = min(strlen,65-txtlen)
        if text.endswith('\n'):
          # when the text ends with a newline, always put the default
          # string on the next line
          first_line = ''
          next_line = defstr
        elif m == strlen:
          # there is space for it on the last line of text
          first_line = defstr
          next_line = ''
        else:
          # figure out how much of the defautl string will fit
          # on the last line of text, and put the rest on the
          # line below
          break_at = defstr[0:m].rfind(' ')
          if break_at == -1:
            first_line = ''
            next_line = defstr
          else:
            first_line = defstr[0:break_at]
            next_line = defstr[break_at:].lstrip()
        if len(first_line) != 0:
          msg[n-1] += '  ' + first_line
        if len(next_line) != 0:
          msg += [next_line]
      print '   ',
      print '\n    '.join(msg)
      print
  # print example
  print """\
EXAMPLES

  To completely rebuild the default targets using the project.bld
  file:

    build

  To completely rebuild the bsim_dut target using the demo.bld project
  file:

    build -p demo.bld bsim_dut

  To see what targets and stages are supported by the demo.bld project:

    build -p demo.bld --list

  To stop after generating RTL for the vlog_dut target of the demo.bld
  project:

    build -p demo.bld vlog_dut --to compile_for_verilog

  To continue the Dini 7002 build process starting with the synthesis step
  in the 7002 target of the demo.bld project:

    build -p demo.bld 7002 --from quartus_map

  To see what commands would be executed to rebuild the sw_tb target
  of the demo.bld project:

    build --dry-run -p demo.bld sw_tb

  The simplest possible projects file contains just a single target name:

    [dut]

  It defines a target named dut that builds a Bluesim executable for
  the mkTop module from a file called Top.bsv.

  A typical project file will define additional targets and provide
  more directives to specialize the build process.  For example, this
  project file defines a SCE-MI dut and two versions of a testbench
  for it, one in BSV and one in SystemC:

    [DEFAULT]
    default-targets:      bsim_dut bsim_tb
    bsc-compile-options:  -aggressive-conditions -keep-fires
    bsc-link-options:     -keep-fires

    # description of DUT

    [dut]
    hide-target
    top-file:             gcd/Bridge.bsv
    bsv-source-directory: gcd
    scemi-type:           TCP
    scemi-tcp-port:       3375
    verilog-directory:    vlog_dut
    binary-directory:     bdir_dut
    simulation-directory: simdir_dut
    info-directory:       info_dut
    exe-file:             gcd_dut

    [bsim_dut]
    hide-target
    extends-target: dut
    build-for:      bluesim

    [vlog_dut]
    extends-target:    dut
    build-for:         verilog
    verilog-simulator: cvc
    run-design-editor: False

    [edit_hdl]
    design-editor-partition-for:    dn7002
    design-editor-options:          --batch
    design-editor-output-directory: vlog_edited
    design-editor-script:           probe1.script
    design-editor-edit-params:      True

    # description of TB in BSV

    [bsv_tb]
    hide-target
    scemi-tb
    top-file:             gcd/Tb.bsv
    top-module:           mkTestBench
    verilog-directory:    vlog_tb
    binary-directory:     bdir_tb
    simulation-directory: simdir_tb
    info-directory:       info_tb
    exe-file:             gcd_tb

    [bsim_tb]
    extends-target: bsv_tb
    build-for:      bluesim

    [vlog_tb]
    extends-target:    bsv_tb
    build-for:         verilog
    verilog-simulator: cvc

    # description of TB in SystemC

    [sysc_tb]
    scemi-tb
    build-for: systemc
    c++-files: gcd/Tb.cpp
    exe-file:  gcd_tb
"""

# List supported targets and the stages of each one.
# This output is used when the --list option is given on the
# command line.  The config argument is the result of
# parsing the project file.
def list_targets(config, args):
  global CURRENT_TARGET

  # determine which targets are supported
  sorted_targets = []
  for section in config.keys():
    if section == 'default' or resolve(section,'hide-target',config):
      continue
    sorted_targets += [section]
  sorted_targets.sort()

  # determine which targets are default targets
  default_targets = resolve('default','default-targets',config)

  # print the stages for each supported target
  print 'Supported targets are:'
  for tgt in sorted_targets:
    if len(args) != 0 and tgt not in args:
      continue
    if tgt in default_targets:
      print '\n  %s (default)' % tgt
    else:
      print '\n  %s' % tgt
    print '  Stages:'
    CURRENT_TARGET = tgt
    stages = flatten_stage_list([build_stage_list(tgt,config)])
    for stg in stages:
      name = stg[0]
      if name != 'start' and name != 'finish':
        print '    %s' % name


# ##################################################################
# Core program logic -- building stage lists and executing commands

# Exception classes used to handle error conditions

class BadTarget(Exception):
  def __init__(self, name=None):
    self.target_name = name

class BadStage(Exception):
  def __init__(self, stage_name=None, purpose=None):
    self.stage_name = stage_name
    self.stage_purpose = purpose

class BuildError(Exception):
  def __init__(self, target_name, stage_name, command):
    self.target_name = target_name
    self.stage_name = stage_name
    self.command = command

class NoProjectBldFile(Exception):
  def __init__(self, name=None):
    self.target_name = name

class ProjectFileExist(Exception):
  def __init__(self, name=None):
    self.target_name = name

# The resolve function takes a section name, a directive name, and the
# configuration read from the project file and returns the value
# computed for that directive in that section.  The resolve function
# handles looking through all extended sections and the default
# section to try to resolve directive values.  It uses the information
# in the directive_descriptions to combine multiple values, and to
# determine a default value when no directive is present.
#
# The optional arguments base and use_base control how defaulting
# is handled.  If no directive is found and base is not None, then
# the supplied base value will override the default value determined
# by consulting the directive_descriptions.  If use_base is False
# then no default will be used and the function will return None
# if no directive was provided explicitly.
def resolve(section,name,config,base=None,use_base=True):

  section = section.lower()
  name    = name.lower()

  # get the directive description
  if name not in directive_descriptions:
    return None
  (topic_group,type,defvar,envvar,validator,extfn,parfn,text) = directive_descriptions[name]

  # gather all definitions within the section and its parents
  this_section = section
  all_directives = []
  while this_section in config:
    # lookup the directives in the section
    locals = [ copy_if_list(v) for (k,v) in config[this_section] if k == name ]
    all_directives = [locals] + all_directives

    # check if this section extends another section
    parent = None
    for (k,v) in config[this_section]:
      if k == 'extends-target':
        parent = v

    if parent:
      this_section = parent
    elif this_section != 'default':
      this_section = 'default'
    else:
      break

  # resolve all of the directives found into a final value
  try:
    all_directives = [ reduce(parfn,ds,None) for ds in all_directives ]
    value = reduce(extfn,all_directives,None)
  except DirectiveError, err:
    raise DirectiveError(err.msg, section, name)

  # apply the base value if needed
  if value == None and use_base:
    if base == None:
      if envvar and envvar in os.environ:
        value = os.getenv(envvar)
      else:
        value = defvar
    else:
      value = base

  elif isinstance(value,str):
    # handle environment variable lookups
    (status,res) = subst_env_vars(section,value)
    if status == 'ok':
      value = elim_escapes(res)
      if value == '':
        value = defvar
    else:
      raise DirectiveError(res, section, name)

  elif isinstance(value,list):
    for s in range(len(value)):
      (status,res) = subst_env_vars(section,value[s])
      if status == 'ok':
        value[s] = elim_escapes(res)
      else:
        raise DirectiveError(res, section, name)

  # apply the validation procedure now that the value is known
  if type == 'bool':
    if not isinstance(value,bool):
      if value.lower() in ['y','yes','1','true','on']:
        value = True
      elif value.lower() in ['n','no','0','false','off']:
        value = False
      else:
        msg = "%s directive requires a boolean value, but got '%s'" % (name,value)
        raise DirectiveError(msg, section, name)
  elif type == 'number':
    try:
      value = int(value)
    except ValueError, err:
       msg = "%s directive requires an integer value, but got '%s'" % (name,value)
       raise DirectiveError(msg, section, name)

  if value != None and validator != None and not validator(value):
    msg = "'%s' is not a valid value for the %s directive" % (value,name)
    raise DirectiveError(msg, section, name)

  return value

# We don't want to mutate shared copies of lists, so we use
# this utility function.
def copy_if_list(x):
  if isinstance(x,list):
    return x[:]
  else:
    return x

# List all targets which can be specified as build targets on the
# command line.  These are all targets in the project file which are
# not the default target and are not marked as hidden using the
# hide-target directive.
def valid_targets(config):
  targets = []
  for section in config.keys():
    if section != 'default' and not resolve(section,'hide-target',config):
      targets += [section]
  return targets

def all_targets(config):
  targets = []
  for section in config.keys():
    targets += [section]
  return targets

# Utility function to expand variables and normalize paths for a file
def fix_path(p0):
  if p0 == None:
    return None
  p1 = os.path.expanduser(p0)
  p2 = os.path.expandvars(p1)
  p3 = os.path.normpath(p2)
  p4 = os.path.realpath(p3)
  return p4

# Utility function to expand variables and normalize paths for a command
def fix_cmd(p0):
  p1 = os.path.expanduser(p0)
  p2 = os.path.expandvars(p1)
  p3 = os.path.normpath(p2)
  return p3

# Utility function to add path from target1 to target2
#  if target2 already has a path in it then do nothing
def copy_path(tg1,tg2):
  first_slash = tg2.find('/')
  if first_slash != -1:
    return tg2
  last_slash = tg1.rfind('/')
  if last_slash == -1:
    return tg2
  path = tg1[:last_slash]
  tg2new = path + '/' + tg2
  return tg2new

# Utility function to determine the param filename
# If the _EDITED version of the file exists, then use that
# otherwise stay with the given name
def determine_param_filename(name):
  dot = name.rfind('.')
  if dot == -1:
    retname = name + '_EDITED'
  else:
    prefix = name[:dot]
    retname = prefix + '_EDITED' + name[dot:]
  # open the params file
  try:
    openfile = file(retname)
  # handle file / IO errors
  except IOError, ioerror:
    retname = name
  else:
    if (openfile):
      openfile.close()

  return retname


# Utility function to check if a file exist
def file_exist(name):
  # open the file
  try:
    openfile = file(name)
  # handle file / IO errors
  except IOError, ioerror:
    return False
  else:
    if (openfile):
      openfile.close()
  return True

# Utility function to create a default init file
def write_default_init_file():
  if file_exist('init.bld'):
    return True

  # open the file
  try:
    f = open('init.bld', 'w')
  # handle file / IO errors
  except IOError, ioerror:
    return False
  else:
    bsdir = os.getenv('BLUESPECDIR')
    f.write('[DEFAULT]\n')
    f.write('# The verilog file containing the top module\n')
    f.write('top-file: \n\n')
    f.write('# The name of the top module\n')
    f.write('top-module: \n\n')
    f.write('# The target clock frequency (mhz) of the design\n')
    f.write('design-clock-frequency: 10\n\n')
    f.write('# Default verilog simulator\n')
    f.write('verilog-simulator: cvc\n\n')
    f.write('# If the DUT uses the memory\n')
    f.write('#sodimm-style:\n')
    f.write('# Indicate that the hardware uses readback\n')
    f.write('xilinx-readback: true\n\n')
  return True

# Utility function to saving an existing project file
def save_project_bld_file(project_file):

  i = 1
  save_file = '%s~%d' % (project_file,i)
  while file_exist(save_file):
    i += 1
    save_file = '%s~%d' % (project_file,i)

  print 'build: saving original project file %s into %s' % (project_file, save_file)
  shutil.copy2(project_file, save_file);

def write_project_bld_file(config,project_file,init_file):

  v2scemi = -1
  sverilog = 0;

  if (file_exist(project_file)):
    save_project_bld_file(project_file)

  # open the file
  try:
    f = open(project_file, 'w')
  # handle file / IO errors
  except IOError, ioerror:
    f.close()
    return False
  else:
    section = 'default'
    top_file = resolve(section,'top-file',config)
    top_path = os.path.dirname(top_file)
    top_module = resolve(section,'top-module',config)
    build_for = resolve(section,'build-for',config).lower()
    log_dir = resolve(section,'log-directory',config)
    if log_dir == '.':
      log_dir = 'logs'
    bsv_gen_src_dir = resolve(section,'bsv-generated-source-directory',config)
    if bsv_gen_src_dir == '.':
      bsv_gen_src_dir = 'bsv'
    cpp_gen_src_dir = resolve(section,'c++-generated-source-directory',config)
    if cpp_gen_src_dir == '.':
      cpp_gen_src_dir = 'build/cpp'

    # bsc defaults
    bsc_link_options = resolve(section,'bsc-link-options',config)
    if '-keep-fires' not in bsc_link_options:
      bsc_link_options += ['-keep-fires']

    # board/fpga support
    bsup_dir = resolve(section,'board-support-directory',config)

    # verilog defaults
    simulator = resolve(section,'verilog-simulator',config)
    verilog_define = resolve(section,'verilog-define',config)
    dump_define = 'BSV_DUMP_TOP=main.top.scemi_dut_dutIfc.ifc_raw'
    verilog_define += [dump_define]
    verilog_lib_directories = resolve(section,'verilog-lib-directories',config)
    verilog_inc_directories = resolve(section,'verilog-inc-directories',config)
    vhdl_files = resolve(section,'imported-vhdl-files',config)

    # c++ defaults
    cpp_compiler = resolve(section,'c++-compiler',config)
    cpp_define = [ '-D%s' % d for d in resolve(section,'c++-define',config) ]
    cpp_libraries = resolve(section,'c++-libraries',config)
    cpp_options = resolve(section,'c++-options',config)
    cpp_files = resolve(section,'c++-files',config)
    cpp_gen_files = []

    # Files needed for the C++ testbenches
    tcl_home = resolve(section,'tcl-home',config)
    cpp_files += [ os.path.join(tcl_home,'include','bsdebug_common.cpp') ]
    cpp_gen_files += [ 'Bsv%sXactor.cpp' % top_module ]

    # Calculate scemi clock period
    scemi_clock_period = get_scemi_clock_period(section,config)

    # memory setting
    sodimm_style = resolve(section,'sodimm-style',config)

    # open the file
    if (not file_exist(top_file)):
      print 'Verilog file %s does not exist' % top_file
      #return False

    v2scemi = top_file.find('.v')
    if v2scemi == -1:
      v2scemi = top_file.find('.sv')
      sverilog = 1;

    def_target = get_board(build_for)
    if def_target == None:
      if v2scemi != -1:
        def_target = 'sim'
      else:
        def_target = 'sim_dut'
    elif def_target == 'ARRIA10GX':
      def_target = 'arria10gx'
    elif def_target == 'ML605':
      def_target = 'ml605'
    elif def_target == 'KC705':
      def_target = 'kc705'
    elif def_target == 'VC707':
      def_target = 'vc707'
    elif def_target == 'VC709':
      def_target = 'vc709'
    elif def_target == 'KCU105':
      def_target = 'kcu105'
    elif def_target == 'VCU108':
      def_target = 'vcu108'
    elif def_target == 'ML507':
      def_target = 'ml507'
    elif def_target == '10GHXTLL':
      def_target = '10ghxtll'
    elif def_target == '10GK7LL':
      def_target = '10gk7ll'
    elif def_target == 'DH2000TQ':
      def_target = 'dh2000tq'
    elif def_target == 'B2000T':
      def_target = 'b2000t'
    elif def_target == 'PDV72KR2':
      def_target = 'pdv72kr2'
    elif def_target == 'DNV7F2A':
      def_target = 'dnv7f2a'
    elif def_target == 'RPP2':
      def_target = 'rpp2'
    elif def_target == 'RPP2SPLIT':
      def_target = 'rpp2split'
    elif def_target == 'DNVUF4A':
      def_target = 'dnvuf4a'
    elif def_target == 'KLVUF4A':
      def_target = 'klvuf4a'

    f.write('[DEFAULT]\n')
    f.write('default-targets:               %s\n' % def_target)
    f.write('bsc-compile-options:           -aggressive-conditions -keep-fires\n')
    f.write('bsc-link-options:              %s -vsearch %s:+' % (' '.join(bsc_link_options),top_path))
    if sverilog == 1:
        f.write(' -Xv +libext+.sv')
    f.write('\n')
    f.write('verilog-simulator:              %s\n' % simulator)
    if v2scemi != -1:
      f.write('pin-file:                       %s.pin\n' % top_module)
      f.write('generate-semu-wrapper:          true\n')
      f.write('generate-semu-testbench:        true\n')
    f.write('scemi-clock-period:             %s\n' % scemi_clock_period)
    f.write('cosim-scd-file:                 scemi_test.scd\n')
    if verilog_define != []:
      f.write('verilog-define:                 %s\n' % ' ' .join(verilog_define))
    if v2scemi != -1:
      verilog_lib_directories += [top_path]
    if verilog_lib_directories != []:
      f.write('verilog-lib-directories:        %s\n' % ' '.join(verilog_lib_directories))
    if verilog_inc_directories != []:
      f.write('verilog-inc-directories:        %s\n' % ' '.join(verilog_inc_directories))
    f.write('log-directory:                  logs\n')
    f.write('c++-generated-source-directory: %s\n' % cpp_gen_src_dir)
    f.write('c++-uses-readback\n')

    if cpp_compiler != '':
      f.write('c++-compiler:                   %s\n' % cpp_compiler)
    if cpp_define != []:
      f.write('c++-define:                     %s\n' % cpp_define)
    if cpp_options != []:
      f.write('c++-options:                    %s\n' % ' '.join(cpp_options))
    if cpp_files != []:
      f.write('c++-files:                      %s\n' % ' '.join(cpp_files))
    if cpp_gen_files != []:
      f.write('c++-generated-files:            %s\n' % ' '.join(cpp_gen_files))

    f.write('verilog-directory:              rtl\n')
    if vhdl_files != []:
      f.write('imported-vhdl-files:            %s\n' % ' '.join(vhdl_files))
    f.write('binary-directory:               obj\n')
    f.write('simulation-directory:           scripts\n')
    f.write('info-directory:                 info\n')
    f.write('exe-file:                       scripts/rundut\n')
    f.write('scemi-parameters-file:          scripts/scemi.params\n')
    f.write('bsv-generated-source-directory: %s\n' % bsv_gen_src_dir)
    f.write('\n')

    f.write('[dut]\n')
    f.write('hide-target\n')
    f.write('top-file:              %s\n' % os.path.join(bsv_gen_src_dir,'Bridge.bsv'))
    f.write('target-root-directory: build/sim\n')
    if doingReadback(section,config):
      if resolve(section, 'xilinx-readback-jtag',config):
        f.write('xilinx-readback-jtag:           true\n')
      else:
        f.write('xilinx-readback:                true\n')
    else:
      f.write('#xilinx-readback:                true\n')
    f.write('xilinx-use-precompiled:         true\n')
    f.write('\n')

    f.write('[sim]\n')
    f.write('sub-targets:           sim_dut sim_manualtb\n')
    f.write('\n')

    f.write('[emu]\n')
    if def_target != 'sim' and def_target != 'sim_dut':
      f.write('sub-targets:           %s emu_manualtb\n' % def_target)
    else:
      f.write('sub-targets:           emu_kc705 emu_manualtb\n')
    f.write('\n')

    f.write('[sim_dut]\n')
    f.write('extends-target:        dut\n')
    f.write('build-for:             verilog\n')
    f.write('scemi-type:            TCP\n')
    f.write('scemi-tcp-port:        0\n')
    f.write('verilog-lib-directories:  $BLUESPECDIR/board_support/bluenoc/xilinx/verilog\n')
    f.write('imported-verilog-files: %s\n' % top_file)
# This file needs to be explicitly mentioned, because it is not instantiated
# The ICAP simulation files will be found by searching in the above directory
    f.write('imported-verilog-files: $BLUESPECDIR/board_support/bluenoc/xilinx/verilog/glbl.v\n')
    f.write('\n')

    f.write('[c++_base]\n')
    f.write('hide-target\n')
    f.write('extends-target:        dut\n')
    f.write('build-for:             c++\n')
    f.write('scemi-tb\n')
    f.write('uses-tcl\n')
    f.write('c++-header-aliases\n')
    f.write('\n')

    f.write('[sim_manualtb]\n')
    f.write('extends-target:        c++_base\n')
    f.write('shared-lib:            libbsdebug.so\n')
    f.write('c++-generated-files:   TclTb.cpp\n')
    f.write('c++-options:           -O3\n')
    f.write('\n')

    #f.write('[sim_c++tb]\n')
    #f.write('extends-target:        c++_base\n')
    #f.write('exe-file:              playvcd\n')
    #if cpp_libraries != []:
    #  cpp_libraries += ['-lboost_regex']
    #  f.write('c++-libraries:         %s\n' % ' '.join(cpp_libraries))
    #else:
    #  f.write('c++-libraries:         -lboost_regex\n')
    #f.write('c++-generated-files:   playvcd.cpp VcdPlayer.cpp\n')
    #f.write('c++-options:           -O3 $BLUESPECDIR/tcllib/include/VcdUtils.cpp\n')
    #f.write('\n')

    write_board_init_boilerplate (config,f,sodimm_style,True)

    f.write('[emu_manualtb]\n')
    f.write('extends-target:        c++_base\n')
    f.write('shared-lib:            libbsdebug.so\n')
    f.write('c++-generated-files:   TclTb.cpp\n')
    f.write('c++-options:           -O3\n')
    f.write('target-root-directory: build/emu\n')
    f.write('\n')

    #f.write('[emu_c++tb]\n')
    #f.write('extends-target:        c++_base\n')
    #f.write('exe-file:              playvcd\n')
    #f.write('c++-libraries:         -lboost_regex\n')
    #f.write('c++-generated-files:   playvcd.cpp VcdPlayer.cpp\n')
    #f.write('c++-options:           -O3 $BLUESPECDIR/tcllib/include/VcdUtils.cpp\n')
    #f.write('target-root-directory: build/emu\n')

    f.close()

  if def_target in ['7002', '7006', '7406']:
    scemi_clock_frequency = get_scemi_clock_frequency(section,config)
    memory_clock_frequency = get_fpga_memory_frequency(section,config,build_for)
    write_program_fpga_script(def_target, scemi_clock_frequency, memory_clock_frequency)

  return True

def write_project_transactor_generator_bld_file(config,project_file,init_file):

  if (file_exist(project_file)):
    save_project_bld_file(project_file)

  # open the file
  try:
    f = open(project_file, 'w')
  # handle file / IO errors
  except IOError, ioerror:
    f.close()
    return False
  except:
    f.close()
    return False

  section = 'default'
  top_file = resolve(section,'top-file',config)
  build_for = resolve(section,'build-for',config).lower()
  tgenout   =   target_root_path = resolve(section,'target-root-directory',config)

  # verilog defaults
  simulator = resolve(section,'verilog-simulator',config)
  verilog_define = resolve(section,'verilog-define',config)
  verilog_lib_directories = resolve(section,'verilog-lib-directories',config)

  # c++ defaults
  cpp_compiler = resolve(section,'c++-compiler',config)
  cpp_define = [ '-D%s' % d for d in resolve(section,'c++-define',config) ]
  cpp_libraries = resolve(section,'c++-libraries',config)
  cpp_options = resolve(section,'c++-options',config)
  cpp_files = resolve(section,'c++-files',config)

  # memory setting
  sodimm_style = resolve(section,'sodimm-style',config)

  def_target = get_board(build_for)
  if def_target == None:
      def_target = 'sim'
  elif def_target == 'ARRIA10GX':
    def_target = 'arria10gx'
  elif def_target == 'ML605':
    def_target = 'ml605'
  elif def_target == 'KC705':
    def_target = 'kc705'
  elif def_target == 'VC707':
    def_target = 'vc707'
  elif def_target == 'VC709':
    def_target = 'vc709'
  elif def_target == 'KCU105':
    def_target = 'kcu105'
  elif def_target == 'VCU108':
    def_target = 'vcu108'
  elif def_target == 'ML507':
    def_target = 'ml507'
  elif def_target == '10GHXTLL':
    def_target = '10ghxtll'
  elif def_target == '10GK7LL':
    def_target = '10gk7ll'
  elif def_target == 'DH2000TQ':
    def_target = 'dh2000tq'
  elif def_target == 'B2000T':
    def_target = 'b2000t'
  elif def_target == 'DNV7F2A':
    def_target = 'dnv7f2a'
  elif def_target == 'RPP2':
    def_target = 'rpp2'
  elif def_target == 'RPP2SPLIT':
    def_target = 'rpp2split'
  elif def_target == 'DNVUF4A':
    def_target = 'dnvuf4a'
  elif def_target == 'KLVUF4A':
    def_target = 'klvuf4a'

  f.write('[DEFAULT]\n')
  f.write('default-targets:               %s\n' % def_target)

  # directory setup
  f.write('log-directory:                  %s/logs\n' % tgenout)
  f.write('verilog-directory:              %s/rtl\n' % tgenout)
  f.write('binary-directory:               %s/obj\n' % tgenout)
  f.write('simulation-directory:           %s/scripts\n' % tgenout)
  f.write('info-directory:                 %s/info\n' % tgenout)
  f.write('c++-header-directory:           %s/cheaders\n' %  tgenout)

  # bsc defaults
  f.write('bsv-source-directories:        %s\n' % ' '.join(resolve(section,'bsv-source-directories',config)))
  f.write('verilog-lib-directories:       %s\n' % ' '.join(resolve(section,'verilog-lib-directories',config)))
  bsc_comp_options = resolve(section,'bsc-compile-options',config)
  if '-keep-fires' not in bsc_comp_options:
    if '-no-keep-fires' not in bsc_comp_options:
      bsc_comp_options += ['-keep-fires']
  if '-aggressive-conditions' not in bsc_comp_options:
    if '-no-aggressive-conditions' not in bsc_comp_options:
      bsc_comp_options += ['-aggressive-conditions']
  f.write('bsc-compile-options:           %s\n' % ' '.join(bsc_comp_options))

  bsc_link_options = resolve(section,'bsc-link-options',config)
  if '-keep-fires' not in bsc_link_options:
    if '-no-keep-fires' not in bsc_link_options:
      bsc_link_options += ['-keep-fires']
  f.write('bsc-link-options:              %s\n' % ' '.join(bsc_link_options))
  f.write('exe-file:                      sim_dut.exe\n')


  # Scemi options
  scemilink_options = resolve(section,'scemilink-options',config)
  f.write('scemilink-options:             %s\n' % ' '.join(scemilink_options))
  # f.write('scemi-clock-period:            %s\n' % resolve(section, 'scemi-clock-period',config))

  f.write('\n')

  f.write('[dut]\n')
  f.write('hide-target\n')
  f.write('top-file:              %s\n' % top_file)
  f.write('top-module:            %s\n' % resolve(section,'top-module',config))
  f.write('\n')

  write_board_init_boilerplate (config, f, sodimm_style, False)


  f.write('[workstation]\n')
  f.write('extends-target:           sim_dut\n')
  f.write('bsv-source-directory:     $BLUESPECDIR/board_support/bluenoc/bridges\n')
  f.write('create-workstation-project:           true\n')
  f.write('\n')


  f.write('[sim]\n')
  f.write('sub-targets:           sim_dut\n')
  f.write('\n')

  f.write('[emu]\n')
  f.write('sub-targets:           emu_ml605\n')
  f.write('\n')

  f.write('[sim_dut]\n')
  f.write('extends-target:        dut\n')
  f.write('bsc-compile-options:   -keep-inlined-boundaries -keep-fires\n')
  f.write('bsc-link-options:      -keep-fires\n')
  f.write('build-for:             verilog\n')
  f.write('scemi-type:            TCP\n')
  f.write('scemi-tcp-port:        0\n')
  f.write('\n')

  f.write('[c++_base]\n')
  f.write('hide-target\n')
  f.write('extends-target:        dut\n')
  f.write('build-for:             c++\n')
  f.write('scemi-tb\n')
  f.write('c++-header-aliases\n')
  f.write('c++-options:           %s\n' %  ' '.join(resolve(section,'c++-options',config)))
  f.write('c++-files:             %s\n' %  ' '.join(resolve(section,'c++-files',config)))
  f.write('\n')


  f.write('[xactor_lib]\n')
  f.write('extends-target: c++_base\n')
  f.write('shared-lib:     lib%s.so\n'  % resolve(section,'top-module',config))
  f.write('c++-libraries:  -ltlmxtors\n')


  f.close()

  if def_target in ['7002', '7006', '7406']:
    scemi_clock_frequency = get_scemi_clock_frequency(section,config)
    memory_clock_frequency = get_fpga_memory_frequency(section,config,build_for)
    write_program_fpga_script(def_target, scemi_clock_frequency, memory_clock_frequency)

  return True


def write_board_init_boilerplate (config, f, sodimm_style, use_target_root):

  section = 'default'
  scemi_clock_period = get_scemi_clock_period(section,config)

  # xdc supplement constraint file
  xdc_supplement_file = resolve(section,'xilinx-xdc-supplement-file',config)

  f.write('\n')
  f.write('[quartus_base]\n')
  f.write('hide-target\n')
  f.write('extends-target:        dut\n')
  f.write('altera-directory:      quartus\n')
  f.write('intel-directory:       intel\n')
  f.write('scemi-type:            PCIE_DINI\n')
  f.write('scemi-clock-period:    %s\n' % scemi_clock_period)
  if use_target_root:
    f.write('target-root-directory: build/emu\n')
  f.write('\n')

  f.write('[emu_arria10gx]\n')
  f.write('extends-target:        quartus_base\n')
  f.write('build-for:             arria10gx\n')
  f.write('scemi-type:            PCIE_ARRIA10GX\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('ARRIA10GX'))
  f.write('\n')


  f.write('[emu_dn7002]\n')
  f.write('hide-target\n')
  f.write('extends-target:        quartus_base\n')
  f.write('build-for:             dn7002\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('7002'))
  f.write('\n')


  f.write('[emu_dn7006]\n')
  f.write('hide-target\n')
  f.write('extends-target:        quartus_base\n')
  f.write('build-for:             dn7006\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('7006'))
  f.write('\n')

  f.write('[emu_dn7406]\n')
  f.write('extends-target:        quartus_base\n')
  f.write('build-for:             dn7406\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('7406'))
  f.write('\n')

  f.write('[xilinx_base]\n')
  f.write('hide-target\n')
  f.write('extends-target:        dut\n')
  f.write('xilinx-directory:               xilinx\n')
  if resolve(section,'xilinx-ooc-synthesis',config):
    f.write('xilinx-ooc-synthesis:           true\n')
  if doingReadback(section,config):
    if resolve(section, 'xilinx-readback-jtag',config):
      f.write('xilinx-readback-jtag:           true\n')
    else:
      f.write('xilinx-readback:                true\n')
  else:
    f.write('#xilinx-readback:                true\n')
  f.write('xilinx-use-precompiled:         true\n')
  f.write('xilinx-use-planahead\n')
  f.write('scemi-type:            PCIE_DINI\n')
  f.write('scemi-clock-period:    %s\n' % scemi_clock_period)
  if doingReadback(section,config):
    f.write('xilinx-bitgen-options: -l\n')
  else:
    f.write('#xilinx-bitgen-options: -l\n')
  f.write('bsc-compile-options:   -opt-undetermined-vals -unspecified-to 0 -remove-dollar\n')
  if use_target_root:
    f.write('target-root-directory: build/emu\n')
  f.write('\n')
  if xdc_supplement_file != None:
      f.write('xilinx-xdc-supplement-file: %s\n' % xdc_supplement_file)

  f.write('[emu_ml507]\n')
  f.write('hide-target\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             ml507\n')
  f.write('scemi-type:            PCIE_VIRTEX5\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('ML507'))
  f.write('\n')

  f.write('[emu_ml605]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             ml605\n')
  f.write('scemi-type:            PCIE_VIRTEX6\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('ML605'))
  #f.write('xilinx-use-precompiled:  false\n')
  f.write('\n')

  f.write('[emu_kc705]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             kc705\n')
  f.write('scemi-type:            PCIE_KINTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('KC705'))
  f.write('\n')

  f.write('[emu_vc707]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             vc707\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('VC707'))
  f.write('\n')

  f.write('[emu_vc709]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             vc709\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('VC709'))
  f.write('\n')

  f.write('[emu_kcu105]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             kcu105\n')
  f.write('scemi-type:            PCIE_VIRTEXU\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('KCU105'))
  f.write('\n')

  f.write('[emu_vcu108]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             vcu108\n')
  f.write('scemi-type:            PCIE_VIRTEXU\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('VCU108'))
  f.write('\n')

  f.write('[emu_dn10ghxtll]\n')
  f.write('hide-target\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             dn10ghxtll\n')
  f.write('scemi-type:            PCIE_VIRTEX6\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('10GHXTLL'))
  f.write('\n')

  f.write('[emu_dn10gk7ll]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             dn10gk7ll\n')
  f.write('scemi-type:            PCIE_KINTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('10GK7LL'))
  f.write('\n')

  f.write('[emu_dnv7f2a]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             dnv7f2a\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('DNV7F2A'))
  f.write('\n')

  f.write('[emu_rpp2]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             rpp2\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('RPP2'))
  f.write('\n')

  f.write('[emu_rpp2split]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             rpp2split\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('RPP2SPLIT'))
  f.write('\n')

  f.write('[emu_dnvuf4a]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             dnvuf4a\n')
  f.write('scemi-type:            PCIE_VIRTEXU\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('DNVUF4A'))
  f.write('\n')

  f.write('[emu_klvuf4a]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             klvuf4a\n')
  f.write('scemi-type:            PCIE_VIRTEXU\n')
  f.write('bsc-compile-options:   -remove-dollar\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('KLVUF4A'))
  f.write('\n')

  f.write('[emu_dh2000tq]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             dh2000tq\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('DH2000TQ'))
  f.write('\n')

  f.write('[emu_b2000t]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             b2000t\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('B2000T'))
  f.write('\n')

  f.write('[emu_pdv72kr2]\n')
  f.write('extends-target:        xilinx_base\n')
  f.write('build-for:             pdv72kr2\n')
  f.write('scemi-type:            PCIE_VIRTEX7\n')
  if sodimm_style != 'NONE':
    f.write('sodimm-style:          %s\n' % lookup_sdram_style('PDV72KR2'))
  f.write('\n')

# Utility function to create a default replay edit files
def write_program_fpga_script(target, scemi_clock_freq, memory_clock_freq):

  script = 'program_fpga'

  # open the file
  try:
    f = open(script, 'w')
  # handle file / IO errors
  except IOError, ioerror:
    f.close()
    return False
  else:
    f.write('#!/bin/bash\n')
    f.write('\n')
    f.write('%s --clear --fpga-a quartus/fpga_a/fpga_a.rbf --g0 %2.3f --g1 %2.3f --g2 100\n' % (target, scemi_clock_freq, memory_clock_freq))
    call(['chmod', '+x', script])
    f.close()

  return True

# Utility function to convert a list of relative paths to absolute paths
def make_abs(root,paths):
  result = []
  for f in paths:
    if os.path.isabs(os.path.expandvars(f)):
      result += [f]
    elif f.find('/') == 0:
      result += [f]
    else:
      result += [os.path.join(root,f)]
  return result

# Utility function to return the relative path to a file from a startpoint
def relpath(target, base=os.curdir):
    """
    Return a relative path to the target from either the current dir or an optional base dir.
    Base can be a directory specified either as absolute or relative to current dir.
    """
    if target == '.':
      return target

    base_list = (os.path.abspath(base)).split(os.sep)
    target_list = (os.path.abspath(target)).split(os.sep)

    # On the windows platform the target may be on a completely different drive from the base.
    if os.name in ['nt','dos','os2'] and base_list[0] <> target_list[0]:
        raise OSError, 'Target is on a different drive to base. Target: '+target_list[0].upper()+', base: '+base_list[0].upper()

    # Starting from the filepath root, work out how much of the filepath is
    # shared by base and target.
    for i in range(min(len(base_list), len(target_list))):
        if base_list[i] <> target_list[i]: break
    else:
        # If we broke out of the loop, i is pointing to the first differing path elements.
        # If we didn't break out of the loop, i is pointing to identical path elements.
        # Increment i so that in all cases it points to the first differing path elements.
        i+=1

    rel_list = [os.pardir] * (len(base_list)-i) + target_list[i:]
    return os.path.join(*rel_list)

def add_rel_path(path, start):
#  print "path:  %s" % path
#  print "start: %s" % start
#  print "rel:   %s" % relpath(path,start)
#  print " "
  return relpath(path, start)
#  return os.path.relpath(path, start)

# Extract the stage and command number from a run-shell-<STAGE>-<N> directive name
def parse_shell_directive(name):
  if name == 'run-shell':
    stage_name = 'run-shell'
    cmd_number = 1
  else:
    try:
      without_pfx = name[10:]
      last_dash = without_pfx.rindex('-')
      stage_name = without_pfx[:last_dash]
      suffix = without_pfx[last_dash+1:]
      cmd_number = int(suffix)
    except ValueError:
      stage_name = without_pfx
      cmd_number = 1
  return (stage_name,cmd_number)

# Get the sub-dir name to add to the path
def get_additional_scemi_library_path(section,config):
  style = resolve(section,'scemi-infrastructure-style',config)
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  if style == 'BLUENOC':
    return "%s/Libraries/BlueNoC" % bsdir
  else:
    return "%s/Libraries/Classic" % bsdir

def get_scemi_style_mixed(section,config):
  style = resolve(section,'scemi-infrastructure-style',config)
  if style == 'BLUENOC':
    return 'BlueNoC'
  else:
    return 'Classic'

# Get the name of the FPGA board (if any) based on the build-for directive
def get_board(build_for):
  if build_for == 'arria10gx':
    return 'ARRIA10GX'
  if build_for == 'dn7002':
    return '7002'
  elif build_for == 'dn7006':
    return '7006'
  elif build_for == 'dn7406':
    return '7406'
  elif build_for == 'dn10ghxtll':
    return '10GHXTLL'
  elif build_for == 'dn10gk7ll':
    return '10GK7LL'
  elif build_for == 'dh2000tq':
    return 'DH2000TQ'
  elif build_for == 'b2000t':
    return 'B2000T'
  elif build_for == 'pdv72kr2':
    return 'PDV72KR2'
  elif build_for == 'dnv7f2a':
    return 'DNV7F2A'
  elif build_for == 'rpp2':
    return 'RPP2'
  elif build_for == 'rpp2split':
    return 'RPP2SPLIT'
  elif build_for == 'dnvuf4a':
    return 'DNVUF4A'
  elif build_for == 'klvuf4a':
    return 'KLVUF4A'
  elif build_for == 'ml507':
    return 'ML507'
  elif build_for == 'ml605':
    return 'ML605'
  elif build_for == 'kc705':
    return 'KC705'
  elif build_for == 'vc707':
    return 'VC707'
  elif build_for == 'vc709':
    return 'VC709'
  elif build_for == 'kcu105':
    return 'KCU105'
  elif build_for == 'vcu108':
    return 'VCU108'
  elif build_for == 'xupv5':
    return 'XUPV5'
  else:
    return None

# Get the default scemi period
def get_scemi_clock_period (section,config):

  scemi_clock_period = float(resolve(section,'scemi-clock-period',config))
  design_clock_frequency = float(resolve(section,'design-clock-frequency',config))

  # Calculate scemi clock period
  if scemi_clock_period == 0.0 and design_clock_frequency == 0.0:
    scemi_clock_period = 10.0
  elif design_clock_frequency != 0.0:
    scemi_clock_period_check = math.pow(10,3) * (1/(float(design_clock_frequency)*2))
    if scemi_clock_period == 0.0:
      scemi_clock_period = scemi_clock_period_check
    elif scemi_clock_period != scemi_clock_period_check:
      print 'Warning: both scemi-clock-period and design-clock-frequency are defined.'
      print '         using scemi-clock-period %s (ns)' % scemi_clock_period

  return scemi_clock_period

# Get the default scemi frequency
def get_scemi_clock_frequency (section,config):

  scemi_clock_period = get_scemi_clock_period(section,config)
  scemi_clock_frequency = math.pow(10,3) * (1/(float(scemi_clock_period)))

  return scemi_clock_frequency

# Get the default memory period
def get_fpga_memory_period(section,config,build_for):
  memoryperiod = float(resolve(section,'memory-clock-period',config))
  if memoryperiod != 0.0:
    return memoryperiod

  # If zero then get the default based on board type
  if build_for in ['ml507',
                   'ml605',
                   'kc705',
                   'vc707',
                   'vc709',
                   'kcu105',
                   'vcu108',
                   'xupv5',
                   'dn10ghxtll',
                   'dn10gk7ll',
                   'dh2000tq',
                   'b2000t',
                   'pdv72kr2',
                   'dnv7f2a',
                   'rpp2',
                   'rpp2split',
                   'dnvuf4a',
                   'klvuf4a']:
    return 5.0
  else:
    return 10.0

# Get the default memory frequency
def get_fpga_memory_frequency(section,config,build_for):
  memoryperiod = float(resolve(section,'memory-clock-period',config))
  if memoryperiod != 0.0:
    memory_frequency = math.pow(10,3) * (1/(float(memory_period)))
    return memory_frequency

  # If zero then get the default based on board type
  if build_for in ['ml507',
                   'ml605',
                   'kc705',
                   'vc707',
                   'vc709',
                   'kcu105',
                   'vcu108',
                   'xupv5',
                   'dn10ghxtll',
                   'dn10gk7ll',
                   'dh2000tq',
                   'b2000t',
                   'pdv72kr2',
                   'dnv7f2a',
                   'rpp2',
                   'rpp2split',
                   'dnvuf4a',
                   'klvuf4a']:
    return 200.0
  else:
    return 400.0

# Merge the bsc link options, excluding SCEMI_CLOCK_PERIOD and MEM_CLOCK_PERIOD
def merge_bsc_options(section,config):
  newoptions = []
  bsc_options = resolve(section,'bsc-link-options',config)
  found = False;
  for opt in bsc_options:
    if found == True:
      index = opt.find('SCEMI_CLOCK_PERIOD')
      if index == -1:
        index = opt.find('MEM_CLOCK_PERIOD')
      if index == -1:
        newoptions += ['-D ' + opt]
      found = False
    else:
      index = opt.find('+define+')
      if index != -1:
        index = opt.find('SCEMI_CLOCK_PERIOD')
        if index == -1:
          index = opt.find('MEM_CLOCK_PERIOD')
          if index == -1:
            newoptions += [opt]
      if opt == '-D':
        found = True
  return newoptions

def get_on_fpga(section,config):
  global SKIP_FPGA
  fpgas = resolve(section,'on-fpga',config)
  if len(SKIP_FPGA) > 0:
    for x in SKIP_FPGA:
      if x in fpgas:
        fpgas.remove(x)
  return fpgas

# Utility function to make path relative to the target_root_dir if it isn't already
def fix_rel_path(section,config,path):
  # the path needs to be expanded, to determine if it's absolute
  exp_path = os.path.expandvars(os.path.expanduser(path))
  if os.path.isabs(exp_path):
    return path
  target_root_path = resolve(section,'target-root-directory',config)
  if os.path.normpath(target_root_path) == '.':
    return path
  # XXX why would the target already be in the path?
  if path.find(target_root_path) == 0:
    return path
  return os.path.normpath(os.path.join(target_root_path,path))

# Get the location of the board_support directory
def get_board_support_directory_root(section,config):
  bsup_dir = resolve(section,'board-support-directory',config)
  return fix_path(bsup_dir)

# Get the location of the board_support directory
def get_board_support_directory(section,config,bsdir):
  bsup_dir = resolve(section,'board-support-directory',config)
  style = resolve(section,'scemi-infrastructure-style',config)

  if bsup_dir == '$BLUESPECDIR/board_support':
    return fix_path(os.path.join(bsdir,'board_support',style.lower()))
  else:
    return fix_path(bsup_dir)

# Get the location of the board_support directory
def get_board_support_subdirectory(section,config,bsdir,build_for):
  bsup_dir = resolve(section,'board-support-directory',config)
  style = resolve(section,'scemi-infrastructure-style',config)
  board = get_board(build_for)

  if bsup_dir == '$BLUESPECDIR/board_support':
    bsup_dir = os.path.join(bsdir,'board_support',style.lower())

  if build_for == 'arria10gx':
    bsup_subdir = os.path.join(bsup_dir,'intel',board)
  elif build_for == 'dn7002':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'dn7006':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'dn7406':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'dn10ghxtll':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'dn10gk7ll':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'dh2000tq':
    bsup_subdir = os.path.join(bsup_dir,'hypersilicon',board)
  elif build_for == 'b2000t':
    bsup_subdir = os.path.join(bsup_dir,'hypersilicon',board)
  elif build_for == 'pdv72kr2':
    bsup_subdir = os.path.join(bsup_dir,'prodesign',board)
  elif build_for == 'dnv7f2a':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'rpp2':
    bsup_subdir = os.path.join(bsup_dir,'cadence',board)
  elif build_for == 'rpp2split':
    bsup_subdir = os.path.join(bsup_dir,'cadence',board)
  elif build_for == 'dnvuf4a':
    bsup_subdir = os.path.join(bsup_dir,'dini',board)
  elif build_for == 'klvuf4a':
    bsup_subdir = os.path.join(bsup_dir,'cadence',board)
  elif build_for == 'ml507':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'ml605':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'kc705':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'vc707':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'vc709':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'kcu105':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'vcu108':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)
  elif build_for == 'xupv5':
    bsup_subdir = os.path.join(bsup_dir,'xilinx',board)

  return fix_path(bsup_subdir)



# Get the names of verilog files (if any) based on the design-editor-partition-for directive
def get_board_sim_vfiles(section,config,bsdir,build_for):
  if build_for == 'arria10gx':
    return ''
  elif build_for == 'dn7002':
    return get_board_sim_vfiles_dini(section,config,bsdir,build_for)
  elif build_for == 'dn7006':
    return get_board_sim_vfiles_dini(section,config,bsdir,build_for)
  elif build_for == 'dn7406':
    return get_board_sim_vfiles_dini(section,config,bsdir,build_for)
  elif build_for == 'dn10ghxtll':
    return ''
  elif build_for == 'dn10gk7ll':
    return ''
  elif build_for == 'dh2000tq':
    return ''
  elif build_for == 'b2000t':
    return ''
  elif build_for == 'pdv72kr2':
    return ''
  elif build_for == 'dnv7f2a':
    return ''
  elif build_for == 'rpp2':
    return ''
  elif build_for == 'rpp2split':
    return ''
  elif build_for == 'dnvuf4a':
    return ''
  elif build_for == 'klvuf4a':
    return ''
  elif build_for == 'ml507':
    return ''
  elif build_for == 'ml605':
    return ''
  elif build_for == 'kc705':
    return ''
  elif build_for == 'vc707':
    return ''
  elif build_for == 'vc709':
    return ''
  elif build_for == 'kcu105':
    return ''
  elif build_for == 'vcu108':
    return ''
  elif build_for == 'xupv5':
    return ''
  else:
    return ''

# Find verilog files associated with the given fpga board
def get_board_sim_vfiles_dini(section,config,bsdir,build_for):
  board = get_board(build_for)
  bsup_dir = get_board_support_directory(section,config,bsdir)
  lib_bsup_dir = get_board_support_subdirectory(section,config,bsdir,build_for)
  if build_for == 'dn7002':
    files = ['d7002_fpga_a.v','d7002_fpga_b.v']
  elif build_for == 'dn7006':
    files = ['d7006_fpga_a.v','d7006_fpga_b.v','d7006_fpga_d.v']
  elif build_for == 'dn7406':
    files = ['d7406_fpga_a.v','d7406_fpga_b.v','d7406_fpga_d.v','d7406_fpga_e.v']
  fpga_files = []
  for f in files:
    file = os.path.join(bsup_dir,f)
    if file_exist(file):
      fpga_files += [file]
      continue
    file = os.path.join(lib_bsup_dir,f)
    if file_exist(file):
      fpga_files += [file]
  return fpga_files

# Get the location simulation directories for the board
def get_board_verilog_lib_directories(section,config,build_for):
  bs_dir = []
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)
  bsup_dir = get_board_support_directory(section,config,bsdir)
  if build_for == 'arria10gx':
    return ''
  elif build_for == 'dn7002':
    bs_dir += ['$QUARTUS_ROOTDIR/eda/sim_lib',
               bsup_dir + '/altera/verilog',
               bsup_dir + '/altera/verilog/StratixIII',
               bsup_dir + '/dini/7002',
               bsup_dir + '/dini/verilog']
    return bs_dir
  elif build_for == 'dn7006':
    bs_dir += ['$QUARTUS_ROOTDIR/eda/sim_lib',
               bsup_dir + '/altera/verilog',
               bsup_dir + '/altera/verilog/StratixIII',
               bsup_dir + '/dini/7006',
               bsup_dir + '/dini/verilog']
    return bs_dir
  elif build_for == 'dn7406':
    bs_dir += ['$QUARTUS_ROOTDIR/eda/sim_lib',
               bsup_dir + '/altera/verilog',
               bsup_dir + '/altera/verilog/StratixIII',
               bsup_dir + '/altera/verilog/StratixIV',
               bsup_dir + '/dini/7406',
               bsup_dir + '/dini/verilog']
    return bs_dir
  elif build_for == 'dn10ghxtll':
    return ''
  elif build_for == 'dn10gk7ll':
    return ''
  elif build_for == 'dh2000tq':
    return ''
  elif build_for == 'b2000t':
    return ''
  elif build_for == 'pdv72kr2':
    return ''
  elif build_for == 'dnv7f2a':
    return ''
  elif build_for == 'rpp2':
    return ''
  elif build_for == 'rpp2split':
    return ''
  elif build_for == 'dnvuf4a':
    return ''
  elif build_for == 'klvuf4a':
    return ''
  elif build_for == 'ml507':
    return ''
  elif build_for == 'ml605':
    return ''
  elif build_for == 'kc705':
    return ''
  elif build_for == 'vc707':
    return ''
  elif build_for == 'vc709':
    return ''
  elif build_for == 'kcu105':
    return ''
  elif build_for == 'vcu108':
    return ''
  elif build_for == 'xupv5':
    return ''
  else:
    return ''

# Get the name of the top fpga verilog file
def get_board_top_fpga_file(section,config,bsdir,board,build_for,suffix):
  if build_for == 'arria10gx':
    return ''
  elif build_for == 'dn7002':
    return get_board_top_fpga_file_dini(section,config,bsdir,board,suffix)
  elif build_for == 'dn7006':
    return get_board_top_fpga_file_dini(section,config,bsdir,board,suffix)
  elif build_for == 'dn7406':
    return get_board_top_fpga_file_dini(section,config,bsdir,board,suffix)
  elif build_for == 'dh2000tq':
    return ''
  elif build_for == 'b2000t':
    return get_board_top_fpga_file_hypersilicon(section,config,bsdir,board,suffix)
  elif build_for == 'pdv72kr2':
    return ''
  elif build_for == 'dn10gk7ll':
    return ''
  elif build_for == 'dn10ghxtll':
    return ''
  elif build_for == 'dnv7f2a':
    return ''
  elif build_for == 'rpp2':
    return ''
  elif build_for == 'rpp2split':
    return get_board_top_fpga_file_cadence(section,config,bsdir,board,suffix)
  elif build_for == 'dnvuf4a':
    return ''
  elif build_for == 'klvuf4a':
    return ''
  elif build_for == 'ml507':
    return ''
  elif build_for == 'ml605':
    return ''
  elif build_for == 'kc705':
    return ''
  elif build_for == 'vc707':
    return ''
  elif build_for == 'vc709':
    return ''
  elif build_for == 'kcu105':
    return ''
  elif build_for == 'vcu108':
    return ''
  elif build_for == 'xupv5':
    return ''
  else:
    return ''

# Get the name of the top verilog file for fpga synthesis on dini board
def get_board_top_fpga_file_dini(section,config,bsdir,board,suffix):
  directive = 'board-top-fpga-file'
  if suffix != '':
    directive += '-' + suffix
  else:
    suffix = 'a'
  top_fpga_file = resolve(section,directive,config)
  if top_fpga_file != None:
    return top_fpga_file

  # if hdledited was active then try to find edited fpga verilogs
  if verilog_modified(section, config):
    outdir = verilog_last(section, config)
    top_fpga_file = outdir + '/fpga_' + suffix + '_EDITED.v'
    top_fpga_file = fix_path(os.path.join(os.getcwd(),top_fpga_file))
    if file_exist(top_fpga_file):
      return top_fpga_file
    else:
      top_fpga_file = None

  # if still nothing found then use the default in board_support repository
  bsup_dir = get_board_support_directory(section,config,bsdir)
  if top_fpga_file == None:
    top_fpga_file = bsup_dir + '/dini/' + board + '/fpga_' + suffix + '.v'

  return top_fpga_file

# Get the name of the top verilog file for fpga synthesis on xilinx board
def get_board_top_fpga_file_hypersilicon(section,config,bsdir,board,suffix):
  directive = 'board-top-fpga-file'
  if suffix != '':
    directive += '-' + suffix
  else:
    suffix = 'a'
  top_fpga_file = resolve(section,directive,config)
  if top_fpga_file != None:
    return top_fpga_file

  # if hdledited was active then try to find edited fpga verilogs
  if verilog_modified(section, config):
    outdir = verilog_last(section, config)
    top_fpga_file = outdir + '/fpga_' + suffix + '_EDITED.v'
    top_fpga_file = fix_path(os.path.join(os.getcwd(),top_fpga_file))
    if file_exist(top_fpga_file):
      return top_fpga_file
    else:
      top_fpga_file = None

  # if still nothing found then use the default in board_support repository
  bsup_dir = get_board_support_directory(section,config,bsdir)
  if top_fpga_file == None:
    top_fpga_file = bsup_dir + '/hypersilicon/' + board + '/fpga_' + suffix + '.v'

  return top_fpga_file

# Get the name of the top verilog file for fpga synthesis on xilinx board
def get_board_top_fpga_file_cadence(section,config,bsdir,board,suffix):
  directive = 'board-top-fpga-file'
  if suffix != '':
    directive += '-' + suffix
  else:
    suffix = 'a'
  top_fpga_file = resolve(section,directive,config)
  if top_fpga_file != None:
    return top_fpga_file

  # if hdledited was active then try to find edited fpga verilogs
  if verilog_modified(section, config):
    outdir = verilog_last(section, config)
    top_fpga_file = outdir + '/fpga_' + suffix + '_EDITED.v'
    top_fpga_file = fix_path(os.path.join(os.getcwd(),top_fpga_file))
    if file_exist(top_fpga_file):
      return top_fpga_file
    else:
      top_fpga_file = None

  # if still nothing found then use the default in board_support repository
  bsup_dir = get_board_support_directory(section,config,bsdir)
  if top_fpga_file == None:
    top_fpga_file = bsup_dir + '/cadence/' + board + '/fpga_' + suffix + '.v'

  return top_fpga_file

# Get the name of the top fpga module
def get_board_top_fpga_module(section,config,build_for,suffix):
  if build_for == 'arria10gx':
    return ''
  elif build_for == 'dn7002':
    return get_board_top_fpga_module_dini(section,config,suffix)
  elif build_for == 'dn7006':
    return get_board_top_fpga_module_dini(section,config,suffix)
  elif build_for == 'dn7406':
    return get_board_top_fpga_module_dini(section,config,suffix)
  elif build_for == 'dn10ghxtll':
    return ''
  elif build_for == 'dn10gk7ll':
    return ''
  elif build_for == 'dh2000tq':
    return ''
  elif build_for == 'b2000t':
    return get_board_top_fpga_module_hypersilicon(section,config,suffix)
  elif build_for == 'pdv72kr2':
    return ''
  elif build_for == 'dnv7f2a':
    return ''
  elif build_for == 'rpp2':
    return ''
  elif build_for == 'rpp2split':
    return get_board_top_fpga_module_cadence(section,config,suffix)
  elif build_for == 'dnvuf4a':
    return ''
  elif build_for == 'klvuf4a':
    return ''
  elif build_for == 'ml507':
    return ''
  elif build_for == 'ml605':
    return ''
  elif build_for == 'kc705':
    return ''
  elif build_for == 'vc707':
    return ''
  elif build_for == 'vc709':
    return ''
  elif build_for == 'kcu105':
    return ''
  elif build_for == 'vcu108':
    return ''
  elif build_for == 'xupv5':
    return ''
  else:
    return ''

# Get the name of the top module for fpga synthesis on dini7002 board
def get_board_top_fpga_module_dini(section,config,suffix):
  directive = 'board-top-fpga-module'
  if suffix != '':
    directive += '-' + suffix
  else:
    suffix = 'a'
  top_fpga_module = resolve(section,directive,config)
  # if nothing is specified then use fpga_{a,b,..} as default
  if top_fpga_module == None:
    top_fpga_module = 'fpga_' + suffix
  if verilog_modified(section, config):
    top_fpga_module += partition_verilog_suffix(section, config)

  return top_fpga_module

# Get the name of the top module for fpga synthesis on dini7002 board
def get_board_top_fpga_module_hypersilicon(section,config,suffix):
  directive = 'board-top-fpga-module'
  if suffix != '':
    directive += '-' + suffix
  else:
    suffix = 'a'
  top_fpga_module = resolve(section,directive,config)
  # if nothing is specified then use fpga_{a,b,..} as default
  if top_fpga_module == None:
    top_fpga_module = 'fpga_' + suffix
  if verilog_modified(section, config):
    top_fpga_module += partition_verilog_suffix(section, config)

  return top_fpga_module

# Get the name of the top module for fpga synthesis on dini7002 board
def get_board_top_fpga_module_cadence(section,config,suffix):
  directive = 'board-top-fpga-module'
  if suffix != '':
    directive += '-' + suffix
  else:
    suffix = 'a'
  top_fpga_module = resolve(section,directive,config)
  # if nothing is specified then use fpga_{a,b,..} as default
  if top_fpga_module == None:
    top_fpga_module = 'fpga_' + suffix
  if verilog_modified(section, config):
    top_fpga_module += partition_verilog_suffix(section, config)

  return top_fpga_module

# Get the name of the top module for fpga simulation
def get_board_top_module(section,config,build_for,suffix):
  if build_for == 'arria10gx':
    return None
  elif build_for == 'dn7002':
    return get_board_top_module_dini(section,config,suffix)
  elif build_for == 'dn7006':
    return get_board_top_module_dini(section,config,suffix)
  elif build_for == 'dn7406':
    return get_board_top_module_dini(section,config,suffix)
  elif build_for == 'dn10ghxtll':
    return None
  elif build_for == 'dn10gk7ll':
    return None
  elif build_for == 'dh2000tq':
    return None
  elif build_for == 'b2000t':
    return get_board_top_module_hypersilicon(section,config,suffix)
  elif build_for == 'pdv72kr2':
    return None
  elif build_for == 'dnv7f2a':
    return None
  elif build_for == 'rpp2':
    return None
  elif build_for == 'rpp2split':
    return get_board_top_module_cadence(section,config,suffix)
  elif build_for == 'dnvuf4a':
    return None
  elif build_for == 'klvuf4a':
    return None
  elif build_for == 'ml507':
    return None
  elif build_for == 'ml605':
    return None
  elif build_for == 'kc705':
    return None
  elif build_for == 'vc707':
    return None
  elif build_for == 'vc709':
    return None
  elif build_for == 'kcu105':
    return None
  elif build_for == 'vcu108':
    return None
  elif build_for == 'xupv5':
    return None
  else:
    return None

# Get the name of the top module for fpga synthesis on dini7002 board
def get_board_top_module_dini(section,config,suffix):
  directive = 'board-top-module'
  if suffix != '':
    directive += '-' + suffix
  top_module = resolve(section,directive,config)
  if top_module != None and top_module != '':
    return top_module
  # if nothing is specified then determine the name of the top design module
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_file = resolve(section,'top-file',config)
    (dirname,filename) = os.path.split(top_file)
    (root,ext) = os.path.splitext(filename)
    top_module = 'mk' + root
  # If the hdleditor flow is active then change the top_module to top_module_EDITED
  if verilog_modified(section, config):
    top_module += verilog_suffix(section, config)

  return top_module

# Get the name of the top module for fpga synthesis on dini7002 board
def get_board_top_module_hypersilicon(section,config,suffix):
  directive = 'board-top-module'
  if suffix != '':
    directive += '-' + suffix
  top_module = resolve(section,directive,config)
  if top_module != None and top_module != '':
    return top_module
  # if nothing is specified then determine the name of the top design module
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_file = resolve(section,'top-file',config)
    (dirname,filename) = os.path.split(top_file)
    (root,ext) = os.path.splitext(filename)
    top_module = 'mk' + root
  # If the hdleditor flow is active then change the top_module to top_module_EDITED
  if verilog_modified(section, config):
    top_module += verilog_suffix(section, config)

  return top_module

# Get the name of the top module for fpga synthesis on dini7002 board
def get_board_top_module_cadence(section,config,suffix):
  directive = 'board-top-module'
  if suffix != '':
    directive += '-' + suffix
  top_module = resolve(section,directive,config)
  if top_module != None and top_module != '':
    return top_module
  # if nothing is specified then determine the name of the top design module
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_file = resolve(section,'top-file',config)
    (dirname,filename) = os.path.split(top_file)
    (root,ext) = os.path.splitext(filename)
    top_module = 'mk' + root
  # If the hdleditor flow is active then change the top_module to top_module_EDITED
  if verilog_modified(section, config):
    top_module += verilog_suffix(section, config)

  return top_module

# Get the stratix part on the board (III or IV)
def get_altera_part_type_dini(build_for):
  if build_for == 'dn7002':
    return 'stratixiii'
  elif build_for == 'dn7006':
    return 'stratixiii'
  elif build_for == 'dn7406':
    return 'stratixiv'
  else:
    return ''

# Definitions of stage command builder routines.
#
# These functions take a section name and the configuration data
# read from the project file and generate command sequences grouped
# into execution stages.
#
# Each stage is either a 2-tuple:
#  (stage-name, command-list)
# or a 3-tuple:
#  (stage-name, delete-dir-list, delete-glob-pattern-list)



# This routine builds 2 stages:
#  delete_build_dirs   to delete any directories containing stale
#                      build products
#  make_build_dirs     to create empty directories to house future
#                      build products
def build_directory_stages(section,config):

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  del_dirs = []
  make_cmds = []
  if build_for != 'c++' and build_for != 'systemc':
    if build_for == 'bluesim':
      # bluesim may need to clean up a simulation-directory
      simdir = resolve(section,'simulation-directory',config)
      if simdir != '.':
        simdir = fix_rel_path(section,config,simdir)
        del_dirs += [simdir]
        make_cmds += ['mkdir -p %s' % simdir]
    else:
      simdir = resolve(section,'simulation-directory',config)
      if simdir != '.':
        simdir = fix_rel_path(section,config,simdir)
        del_dirs += [simdir]
        make_cmds += ['mkdir -p %s' % simdir]
      # verilog and FPGAs may need to clean up a verilog-directory
      vdir = resolve(section,'verilog-directory',config)
      if vdir != '.':
        vdir = fix_rel_path(section,config,vdir)
        del_dirs += [vdir]
        make_cmds += ['mkdir -p %s' % vdir]
      # verilog and FPGAs may need to clean up a verilog-directory
      edir = resolve(section,'design-editor-output-directory',config)
      if edir != '.':
        edir = fix_rel_path(section,config,edir)
        del_dirs += [edir]
        make_cmds += ['mkdir -p %s' % edir]

    # all bsc targets may need to clean up a binary-directory
    bdir = resolve(section,'binary-directory',config)
    if bdir != '.':
      bdir = fix_rel_path(section,config,bdir)
      del_dirs += [bdir]
      make_cmds += ['mkdir -p %s' % bdir]

    # all bsc targets may need to clean up an info-directory
    infodir = resolve(section,'info-directory',config)
    if infodir != '.':
      infodir = fix_rel_path(section,config,infodir)
      del_dirs += [infodir]
      make_cmds += ['mkdir -p %s' % infodir]

  # Semu wrapper generation needs to clean up a bsv-generated-source-directory
  if (resolve(section,'generate-semu-wrapper',config)):
    bsv_gen_src_dir = resolve(section,'bsv-generated-source-directory',config)
    if bsv_gen_src_dir != '.':
      bsv_gen_src_dir = fix_rel_path(section,config,bsv_gen_src_dir)
      del_dirs += [bsv_gen_src_dir]
      make_cmds += ['mkdir -p %s' % bsv_gen_src_dir]

  # several targets may need to clean up a c++-generated-source-directory
  # (scemilink header generation, Semu testbench generation)
  cpp_gen_src_dir = resolve(section,'c++-generated-source-directory',config)
  if cpp_gen_src_dir != '.':
    # The path is not duplicated per build target
    #cpp_gen_src_dir = fix_rel_path(section,config,cpp_gen_src_dir)
    del_dirs += [cpp_gen_src_dir]
    make_cmds += ['mkdir -p %s' % cpp_gen_src_dir]

  # several targets could create an executable in a directory
  outdir = os.path.dirname(resolve(section,'exe-file',config))
  if outdir != '.' and outdir != '':
    outdir = fix_rel_path(section,config,outdir)
    make_cmds += ['mkdir -p %s' % outdir]

  # generate the delete_build_dirs and make_build_dirs stages
  stages = []
  if len(del_dirs) != 0:
    stages += [('delete_build_dirs',del_dirs,[])]
  if len(make_cmds) != 0:
    stages += [('make_build_dirs',make_cmds)]

  return stages

# This routine is responsible for the create_bspec_file stage.  It
# allows a .bspec file to be generated based on the information in the
# project file.
def build_workstation_stages(section,config):

  # first test if the create-workstation-project directive was given
  genfile = resolve(section,'create-workstation-project',config)
  if not genfile:
    return []

  # get the name of the .bspec file to create
  proj_file = resolve(section,'workstation-project-file',config)

  top_module = resolve(section,'top-module',config)

  return create_bspec_file_stages('create_bspec_file',
                                  proj_file, top_module, '/main/top', 'GtkWave',
                                  section, config)

def build_cosim_bspec_stages(section,config):

  do_cosim = doing_cosim(section,config)
  if not do_cosim:
    return []

  # get the name of the .bspec file to create
  proj_file = 'cosim.bspec'

  top_module = resolve(section,'top-module',config)

  return create_bspec_file_stages('cosim_bspec_file',
                                  proj_file, top_module, '/main/top', 'GtkWave',
                                  section, config)

def build_pre_stage_cmd(section,config,stage):

  # get the pre stage command if it exists
  directive = 'pre-stage-' + stage
  cmd = resolve(section,directive,config)
  if cmd != None:
    return [(directive,[cmd])]
  return []

def build_post_stage_cmd(section,config,stage):

  # get the post stage command if it exists
  directive = 'post-stage-' + stage
  cmd = resolve(section,directive,config)
  if cmd != None:
    return [(directive,[cmd])]
  return []

def modify_for_bdw ( str ):
  # expected escape for BDW
  str = re.sub ('\$BLUESPECDIR', '${BLUESPECDIR}', str)
  # environments to $ to \$
  str = re.sub ('\$', '\\$', str)
  return str

def create_bspec_file_stages(label, proj_file, top_module, path, viewer, section, config):

  # determine the destination path for the workstation project file.
  bspec_path = os.path.dirname(proj_file)

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # get the BLUESPECDIR path, used as the root of other paths
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  # there is a template file located in this board_support directory
  bsup_dir = get_board_support_directory(section,config,bsdir)
  board_support_dir = os.path.join(bsup_dir,'..','workstation')

  # build up the command sequence needed to generate the .bspec file
  options = []
  cmds   = []

  cmds += ['echo "### Bluespec project file." > %s' % proj_file]
  cmds += ['echo "### Generated by build environment.\n" >> %s' % proj_file]
  cmds += ['echo "global PROJECT\n" >> %s' % proj_file]

  bsc_options = resolve(section,'bsc-compile-options',config)
  scemi_type = resolve(section,'scemi-type',config)
  if scemi_type:
    bsc_options += ['-D SCEMI_' + scemi_type]
  defines = [ '-D %s' % d for d in resolve(section,'bsv-define',config) ]
  bsc_options += defines
  options += ['set PROJECT(COMP_BSC_OPTIONS) "%s"' % modify_for_bdw(' '.join(bsc_options))]
  rts_options = resolve(section,'bsc-rts-options',config)
  options += ['set PROJECT(COMP_RTS_OPTIONS) "%s"' % ' '.join(rts_options)]
  bdir = resolve(section,'binary-directory',config)
  options += ['set PROJECT(COMP_BDIR) "%s"' % add_rel_path(bdir, bspec_path)]
  vdir = resolve(section,'verilog-directory',config)
  options += ['set PROJECT(COMP_VDIR) "%s"' % add_rel_path(vdir, bspec_path)]
  infodir = resolve(section,'info-directory',config)
  options += ['set PROJECT(COMP_INFO_DIR) "%s"' % add_rel_path(infodir, bspec_path)]
  simdir  = resolve(section,'simulation-directory',config)
  options += ['set PROJECT(COMP_SIMDIR) "%s"' % add_rel_path(simdir, bspec_path)]
  bsc_link_options = resolve(section,'bsc-link-options',config)
  options += ['set PROJECT(LINK_BSC_OPTIONS) "%s"' % ' '.join(bsc_link_options)]
  exe_outdir = os.path.dirname(resolve(section,'exe-file',config))
  if exe_outdir != '':
    cmds += ['mkdir -p %s' % exe_outdir]
  else:
    exe_outdir = '.'
  options += ['set PROJECT(LINK_OUTDIR) "%s"' % add_rel_path(exe_outdir, bspec_path)]
  exe_file = os.path.basename(resolve(section,'exe-file',config))
  options += ['set PROJECT(LINK_OUTNAME) "%s"' % exe_file]

  src_dirs = []
  src_dir = resolve(section,'bsv-source-directory',config)
  if src_dir != '.':
    src_dirs += [src_dir]
  src_dir = resolve(section,'bsv-generated-source-directory',config)
  src_dir = fix_rel_path(section,config,src_dir);
  if src_dir != '.':
    src_dirs += [src_dir]
  src_dirs += resolve(section,'bsv-source-directories',config)
  src_dirs += resolve(section,'verilog-lib-directories',config)
  if verilog_modified(section, config):
    src_dirs += [verilog_last(section, config)]

  rel_src_dirs = []
  for d in src_dirs:
    rel_src_dirs += [add_rel_path(re.sub('\$BLUESPECDIR', '%', d), bspec_path)]

  options += ['set PROJECT(PATHS) "%s"' % ('. %s %%/Prelude %%/Libraries %%/Libraries/%s' % (' '.join(rel_src_dirs), get_scemi_style_mixed(section,config)))]
  simulator = 'modelsim'
  top_file = add_rel_path(resolve(section,'top-file',config), bspec_path)
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)

  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root

  options += ['set PROJECT(TOP_FILE) "%s"' % modify_for_bdw(top_file)]
  options += ['set PROJECT(TOP_MODULE) "%s"' % top_module]

  if build_for != 'bluesim' and build_for != 'c++' and build_for != 'systemc':
    options += ['set PROJECT(COMP_BSC_TYPE) "%s"' % 'verilog']
    simulator = resolve(section,'verilog-simulator',config)
    options += ['set PROJECT(SIM_NAME) "%s"' % simulator]
  elif build_for == 'bluesim':
    options += ['set PROJECT(COMP_BSC_TYPE) "%s"' % 'bluesim']
  else:
    raise DirectiveError('c++ and systemc are unsupported configurations for generating workstation project files (for now)', section, 'create-workstation-project')

  options += ['::Waves::set_options {nonbsv_hierarchy} {%s}' % path]
  options += ['::Waves::set_options {viewer} {%s}' % viewer]

  for o in options:
    cmds += ['echo \'%s\' >> %s' % (o, proj_file)]
  cmds += ['cat %s/project.bspec.template >> %s' %(board_support_dir, proj_file)]

  # wrap up all of the commands into the create_bspec_file stage
  stages = [(label, cmds)]
  return stages

def create_bsc_compile_makefile(makefilename,target,top_file,make_path,bdir,bsccmd,bscopts):
  global DEPENDENCIES
  global MAKE_ORDER

  if bdir == '' or bdir == '.':
    print 'Warning: parallel make requested (-j) but bdir not set; this probably won\'t work'

  makefile = open(makefilename, 'w')

  makefile.write("TARGET=%s\n" % target);
  makefile.write("TOP=%s\n" % top_file);
  makefile.write("PATHS=%s\n" % make_path);
  makefile.write("BDIR=%s\n" % bdir);
  makefile.write("BSC=%s\n" % bsccmd);
  makefile.write("BSCFLAGS=%s\n" % bscopts);
  makefile.write("MAKEDEPEND=%s\n" % "bluetcl -exec makedepend");

  makefile.write("""
default: $(patsubst %.bsv,$(BDIR)/%.bo,$(notdir $(TOP)))

-include .$(TARGET).depend

bsv_depends ?= yes
ifeq ($(bsv_depends), yes)
.$(TARGET).depend: .$(TARGET).mk $(wildcard $(foreach dir,$(filter-out +,$(subst :, ,$(PATHS))),\"$(dir)/*.bsv\"))
\t$(MAKEDEPEND) $(BSCFLAGS) -o $@ $(TOP)
endif

$(BDIR)/%.bo:
\t$(BSC) $(BSCFLAGS) $<
""");

  makefile.close()

# This routine generates either compile_for_bluesim or
# compile_for_verilog stages.  The stages contain a single bsc command
# to perform bsc compilation (linking is a separate stage).
def build_bsc_compile_stages(section,config):
  global JOBS

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # nothing to do if this is not a BSV build
  if build_for == 'c++' or build_for == 'systemc' or build_for == 'rtllink':
    return []

  # Provide incompatible error if building classic on unsupported platform
  style = resolve(section,'scemi-infrastructure-style',config)
  if verify_bluenoc_only_build_for(build_for) and style == 'CLASSIC':
    return ('error', '%s is not support with CLASSIC scemi' % build_for);

  # determine if this is a SCE-MI build
  scemi_type = resolve(section,'scemi-type',config)

  # determine the BLUESPECDIR path
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  options = []
  make_path = []
  make_defs = []

  # setup -simdir and -vdir variables
  if build_for == 'bluesim':
    simdir = resolve(section,'simulation-directory',config)
    simdir = fix_rel_path(section,config,simdir);
    if simdir != '.':
      options += ['-simdir ' + simdir]
  else:
    vdir = resolve(section,'verilog-directory',config)
    vdir = fix_rel_path(section,config,vdir);
    if vdir != '.':
      options += ['-vdir ' + vdir]

  # setup the -bdir variable
  bdir = resolve(section,'binary-directory',config)
  bdir = fix_rel_path(section,config,bdir);
  if bdir != '.':
    options += ['-bdir ' + bdir]

  # setup the -info-dir variable
  infodir = resolve(section,'info-directory',config)
  infodir = fix_rel_path(section,config,infodir);
  if infodir != '.':
    options += ['-info-dir ' + infodir]

  # add compiler options from the user
  bsc_options = resolve(section,'bsc-compile-options',config)
  options += bsc_options

  # add RTS options from the user
  rts_options = resolve(section,'bsc-rts-options',config)
  if len(rts_options) > 0:
    options += ['+RTS ' + ' '.join(rts_options) + ' -RTS']

  # add BSV source directories to the -p path
  src_dirs = []
  src_dir = resolve(section,'bsv-source-directory',config)
  if src_dir != '.':
    src_dirs += [src_dir]
  gsrc_dir = resolve(section,'bsv-generated-source-directory',config)
  gsrc_dir = fix_rel_path(section,config,gsrc_dir);
  if gsrc_dir != '.':
    src_dirs += [gsrc_dir]
  src_dirs += resolve(section,'bsv-source-directories',config)
  src_dirs += resolve(section,'verilog-lib-directories',config)
  if len(src_dirs) != 0:
    options += ['-p %s:+' % ':'.join(src_dirs)]
    make_path += ['%s:+' % ':'.join(src_dirs)]
  else:
    make_path += ['+']

  bsup_dir = get_board_support_directory(section,config,bsdir)
  if scemi_type:
    options += ['-p +:%s/bridges' % bsup_dir]
    if get_scemi_style_mixed(section,config) == 'Classic':
      options += ['-scemi-classic']

  # Elaboration files are needed by various bluetcl scripts (for SceMi and
  # Xilinx FPGAs) and the Verilog link stage when importing foreign functions
  if '-elab' not in options:
    options += ['-elab']

  # when using SCE-MI automatically define SCEMI_TCP, SCEMI_DINI_PCIE,
  # etc.  these are standard macros used in SCE-MI bridge
  # implementations, for instance.
  scemi_type = resolve(section,'scemi-type',config)
  if scemi_type:
    options += ['-D SCEMI_' + scemi_type]
    make_defs += ['-D SCEMI_' + scemi_type]

  # Include the board's scemi clock period as a definition as well in
  # case it is needed in the BSV code.
  scemi_clock_period = get_scemi_clock_period(section,config)
  if scemi_clock_period:
    options += ['-D SCEMI_CLOCK_PERIOD=%d' % int(scemi_clock_period)]
    make_defs += ['-D SCEMI_CLOCK_PERIOD=%d' % int(scemi_clock_period)]

  memory_clock_period = get_fpga_memory_period(section,config,build_for)
  if memory_clock_period:
    options += ['-D MEMORY_CLOCK_PERIOD=%d' % int(memory_clock_period)]
    make_defs += ['-D MEMORY_CLOCK_PERIOD=%d' % int(memory_clock_period)]

  # when using a particular FPGA board, automatically define
  # BOARD_7002, etc.  Also, define DDR2_SODIMM_STYLE, etc. based on
  # the sodimm-style directive.  These macros can be used to ensure
  # that the right interfaces are being used in the BSV top-level.
  board = get_board(build_for)
  if board != None:
    options += ['-D BOARD_' + board]
    make_defs += ['-D BOARD_' + board]
    sodimm = resolve(section,'sodimm-style',config).upper()
    if sodimm != 'NONE':
      options += ['-D %s_SODIMM_STYLE' % sodimm]
      make_defs += ['-D %s_SODIMM_STYLE' % sodimm]

  # include any macro definitions from the user
  defines = [ '-D %s' % d for d in resolve(section,'bsv-define',config) ]
  options += defines
  make_defs += defines

  # use -sim or -verilog as appropriate
  if build_for == 'bluesim':
    options = ['-sim'] + options
  else:
    options = ['-verilog'] + options

  # find the bsc command path, the top BSV file and the top module in
  # the design and combine this with the options created above to make
  # the complete command line.
  bsc_cmd = fix_cmd(resolve(section,'bsc',config))
  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file);
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root

  cmd = []

  if int(JOBS) > 0:
    print "creating makefile for parallel bsc compile"
    create_bsc_compile_makefile(".%s.mk" % CURRENT_TARGET,CURRENT_TARGET,top_file,' '.join(make_path),bdir,bsc_cmd,' '.join(options))

    global JOBS_QUICK
    if JOBS_QUICK == 1:
      deps = 'bsv_depends=no'
    else:
      deps = 'bsv_depends=yes'

    cmd += ['make %s -f .%s.mk -j %s' % (deps, CURRENT_TARGET, str(JOBS))]

    # don't use -u
    cmd += ['%s %s -g %s %s' % (bsc_cmd,' '.join(options),top_module,top_file)]

  else:
    # if we are doing a single build, then here we are (with -u)
    cmd += ['%s %s -u -g %s %s' % (bsc_cmd,' '.join(options),top_module,top_file)]

  # generate the appropriately named stage with the bsc compile
  # command
  if build_for == 'bluesim':
    stages = build_pre_stage_cmd(section,config,'compile_for_bluesim')
    stages += [('compile_for_bluesim',cmd)]
    stages += build_post_stage_cmd(section,config,'compile_for_bluesim')
  else:
    stages = build_pre_stage_cmd(section,config,'compile_for_verilog')
    stages += [('compile_for_verilog',cmd)]
    stages += build_post_stage_cmd(section,config,'compile_for_verilog')

  return stages

# This routine creates the generate_scemi_paramters stage, consisting
# of a single scemilink command.
def build_scemi_link_stages(section,config):

  # identify build platform( bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # nothing to do if this is not a BSV build
  if build_for == 'c++' or build_for == 'systemc':
    return []

  # nothig to do if this is not a SCE-MI design
  scemi_type = resolve(section,'scemi-type',config)
  if scemi_type == None:
    return []

  # determine the top BSV file
  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file);
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)

  # determine the top design module
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root

  options = []

  # if we are in classic mode, set the classic flag
  scemi_style = get_scemi_style_mixed(section,config)
  if scemi_style == 'Classic':
    options += ['--scemi-classic']

  if build_for == 'bluesim':
    # for bluesim, use --simdir
    simdir = resolve(section,'simulation-directory',config)
    simdir = fix_rel_path(section,config,simdir)
    if simdir != '.':
      options += ['--simdir=' + simdir]
  else:
    # for verilog, use --vdir
    vdir = resolve(section,'verilog-directory',config)
    vdir = fix_rel_path(section,config,vdir)
    if vdir != '.':
      options += ['--vdir=' + vdir]

  # use --path to locate .ba files
  bdir = resolve(section,'binary-directory',config)
  bdir = fix_rel_path(section,config,bdir)
  if bdir != '.':
    options += ['--path=' + bdir + ':+']

  # for the TCP link type, the user can specify the port number
  if scemi_type == "TCP":
      port = resolve(section,'scemi-tcp-port',config)
      if port == 0:
        port = random.randrange(2048, 50000)
      options += ['--port=%s' % port]

  # the user can specify the name of the parameters file

  scemi_params = resolve(section,'scemi-parameters-file',config)
  if not scemi_params.startswith('the value of top-module'):
    scemi_params = fix_rel_path(section,config,scemi_params)
    options += ['--params=' + scemi_params]

  # include any scemilink options from the user
  # XXX We currently require the user to specify the -p argument
  # XXX but we could construct it as we do elsewhere in 'build'
  scemilink_opts = resolve(section,'scemilink-options',config)
  options += scemilink_opts

  # use --sim or --verilog as appropriate
  if build_for == 'bluesim':
    options = ['--sim'] + options
  elif build_for == 'verilog' or build_for == 'rtllink':
    options = ['--verilog'] + options

  # find the scemilink command path
  bsc_cmd = fix_cmd(resolve(section,'bsc',config))
  (dirname,filename) = os.path.split(bsc_cmd)
  if dirname != '':
    scemilink_cmd = os.path.join(dirname,'scemilink')
  else:
    scemilink_cmd = 'scemilink'

  # make the full command
  cmd = '%s %s %s' % (scemilink_cmd,' '.join(options),top_module)

  stages = build_pre_stage_cmd(section,config,'generate_scemi_parameters')
  stages += [('generate_scemi_parameters',[cmd])]
  stages += build_post_stage_cmd(section,config,'generate_scemi_parameters')
  return stages


# This routine runs the edithdl flow to modify the verilog source files
# starting either the gui application or running the script specified by
# design-editor-script directive.
# The SceMi params file may also be generated at the end of the flow.
def build_partition_edithdl_stages(section,config):
  global HAS_PARTITION


  run_design_editor = resolve(section,'run-design-editor',config)
  if not run_design_editor:
    return []

  # Check if there should be extra partition edithdl stage
  edit_script = resolve(section,'design-editor-script',config)

  HAS_PARTITION = isPartition(edit_script)
  if not HAS_PARTITION:
    return []

  stages = build_edithdl_stages(section,config,'partition')

  return stages;

# This routine runs the edithdl flow to modify the verilog source files
# starting either the gui application or running the script specified by
# design-editor-script directive.
# The SceMi params file may also be generated at the end of the flow.
def build_edithdl_stages(section,config,stage_prefix):
  global PARTITION_SPEC

  # first test if the run-design-editor directive was set
  run_design_editor = resolve(section,'run-design-editor',config)
  if (not run_design_editor) and stage_prefix == '':
    return []

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # nothing to do if this is bluesim or not a BSV build
  if build_for == 'bluesim' or build_for == 'c++' or build_for == 'systemc':
    return []

  # determine the BLUESPECDIR path
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)
  bsup_dir = get_board_support_directory(section,config,bsdir)

  # determine extra verilog files needed for partition
  partition_for = resolve(section,'design-editor-partition-for',config)
  if partition_for == None:
    if verify_build_for_multi_fpga(build_for):
      partition_for = build_for
  if partition_for != None:
    fpga_files = get_board_sim_vfiles(section,config,bsdir,partition_for)
  else:
    fpga_files = ''

  options = []

  # Add --partition edithdl option
  if stage_prefix == 'partition':
    options += ['--partition']

  # determine the edit script file
  orig_edit_script = resolve(section,'design-editor-script',config)
  edit_script = orig_edit_script
  options += ['--script ' + edit_script]

  # determine the edithdl option
  ed_options = resolve(section,'design-editor-options',config)
  editor_options = ed_options

  # determine the top BSV file
  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file);
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)

  # determine top module for -e option
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root
  editor_options += [ ( '-e %s' % top_module ) ]

  # Set various defines
  if build_for == 'dn7406' or partition_for == 'dn7406':
    editor_options += ['+define+BOARD_7406' ]
  #if stage_prefix == '':
  #  editor_options += merge_bsc_options(section,config)
  fpgas = get_on_fpga(section, config)
  for fpga in fpgas:
    if fpga.lower() != 'a':
      editor_options += ['+define+USING_%s' % fpga.upper()]

  editor_options += [ '+define+%s' % d for d in resolve(section,'verilog-define',config) ]

  edithdl_outputdir = resolve(section,'design-editor-output-directory',config)
  edithdl_outputdir = fix_rel_path(section,config,edithdl_outputdir);
  if partition_for != None:
    editor_options += ['+libext+.v']
    editor_options += ['+incdir+' + bsup_dir + '/dini/verilog']
    if HAS_PARTITION:
      editor_options += [ ( '-y %s' % edithdl_outputdir ) ]
    editor_options += [ ( '-y %s' % bsup_dir ) ]

  # determine verilog search libraries
  ysearchdirs = [ '-y %s' % d for d in resolve(section,'verilog-lib-directories',config) ]
  editor_options += ysearchdirs

  # determine verilog include directories
  ysearchdirs = [ '+incdir+%s' % d for d in resolve(section,'verilog-inc-directories',config) ]
  editor_options += ysearchdirs

  # if partitioning for an fpga
  if partition_for != None:
    # determine fpga verilog search libraries
    libs = get_board_verilog_lib_directories(section,config,partition_for)
    ysearchdirs = [ '-y %s' % d for d in libs ]
    editor_options += ysearchdirs

  # Add default bsc verilog lib directories
  if stage_prefix == 'partition':
    outputdir = edithdl_outputdir + '_partition'
  else:
    outputdir = edithdl_outputdir

  vdir = resolve(section,'verilog-directory',config)
  vdir = fix_rel_path(section,config,vdir)
  vdir_partition = outputdir
  editor_options += [ ( '-y %s/Verilog' % bsdir ) ]
  editor_options += [ ( '-y %s/Libraries' % bsdir ) ]
  editor_options += [ ( '-y %s' % get_additional_scemi_library_path(section,config)) ]
  if stage_prefix == 'partition':
    editor_options += [ ( '-y %s' % vdir ) ]

  # determine the imported verilog files
  imported_vlog_files = resolve(section,'imported-verilog-files',config)
  imported_svlog_files = resolve(section,'imported-systemverilog-files',config)

  # determine the verilog directory
  options += ['--ydir ' + vdir]

  # setup the binary-directory variable
  bdir = resolve(section,'binary-directory',config)
  bdir = fix_rel_path(section,config,bdir)
  # XXXXX not needed.....
  if bdir != '.':
    options += ['-p ' + bdir + ":+"]

  # Add edithdl output directory option
  options += ['--outputdir ' + outputdir]

  # determine the top BSV file
  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file);
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)

  # determine top module name
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root
  elif stage_prefix == '':
    options += ['-bsvmodule ' + top_module]

  top_vfile = top_module + '.v'
  if top_vfile.startswith('/') == 0:
    # open the top verilog file
    try:
      openfile = file(top_vfile)
    # handle file / IO errors
    except IOError, ioerror:
      if HAS_PARTITION and stage_prefix == 'partition':
        top_vfile = edithdl_outputdir + '/' + top_vfile
      else:
        top_vfile = vdir + '/' + top_vfile
    else:
      if (openfile):
        openfile.close()

  # determine whether to process scemi params file
  do_scemi_params = resolve(section,'design-editor-edit-params',config)
  if do_scemi_params:
    # set the input and output (edited) scemi params file
    input_scemi_params = resolve(section,'scemi-parameters-file',config)
    input_scemi_params = fix_rel_path(section,config,input_scemi_params);
    output_scemi_params = resolve(section,'design-editor-output-params',config)
    output_scemi_params = fix_rel_path(section,config,output_scemi_params);
    if output_scemi_params.startswith('the value of top-module'):
      output_scemi_params = top_module + '_EDITED.params'
    output_scemi_params = copy_path(input_scemi_params, output_scemi_params)
    if input_scemi_params.startswith('the value of top-module'):
      input_scemi_params = top_module + '.params'
    options += ['--params ' + input_scemi_params]
    options += ['--params-out ' + output_scemi_params]

  scemi_clock_period = get_scemi_clock_period(section,config)
  if scemi_clock_period:
    options += [('+define+SCEMI_CLOCK_PERIOD=%s' % scemi_clock_period)]
  mem_clock_period = get_fpga_memory_period(section, config, build_for)
  if mem_clock_period:
    options += [('+define+MEM_CLOCK_PERIOD=%s' % mem_clock_period)]

  # compose the edithdl command path
  bsdir = os.getenv('BLUESPECDIR')
  if bsdir:
    bsdir += '/bin/'
  edithdl_cmd = bsdir + 'bluetcl -exec edithdl'

  cmd = ''
  # make the full command
  cmd += '%s %s %s %s %s %s %s' % (edithdl_cmd,' '.join(options),' '.join(fpga_files),
                            ' '.join(editor_options),top_vfile,
                            ' '.join(imported_vlog_files),
                            ' '.join(imported_svlog_files))
  stages = build_pre_stage_cmd(section,config,'edithdl_modify_verilog')

  if stage_prefix != '':
    stage_name = stage_prefix + '_edithdl_modify_verilog'
  else:
    stage_name = 'edithdl_modify_verilog'
  stages += [(stage_name,[cmd])]

  if stage_prefix != '':
    stage_name = stage_prefix + '_edithdl_modify_verilog_cleanup'
  else:
    stage_name = 'edithdl_modify_verilog_cleanup'

  cmd = ''
  top_edited_module = top_module + '_EDITED'
  top_vfile = outputdir + '/' + top_module + '_EDITED.v'
  orig_outputdir = resolve(section,'design-editor-output-directory',config)
  orig_outputdir = fix_rel_path(section,config,orig_outputdir);
  orig_vfile = outputdir + '/' + top_module + '.v'
  if orig_outputdir != outputdir:
    if stage_prefix == 'partition' or stage_prefix == '':
      fragment_file = "%s/scemilink.vlog_fragment" % outputdir
      cmd += "cp %s %s ;" % (fragment_file, orig_outputdir)
      cmd += "cp %s/*.v %s ;" % (outputdir, orig_outputdir)
  cmd += "sed 's+%s+%s+' %s > %s ;" % (top_edited_module, top_module, top_vfile, orig_vfile)
  cmd += "cp %s/*.v %s ;" % (outputdir, edithdl_outputdir)
  #cmd += "cp %s/*.v %s ;" % (outputdir, vdir)
  if do_scemi_params:
    cmd += "cp %s %s ;" % (output_scemi_params, outputdir)
    if output_scemi_params != input_scemi_params:
      cmd += "cp %s %s ;" % (output_scemi_params, input_scemi_params)
  if cmd != '':
    stages += [(stage_name,[cmd])]

  stages += build_post_stage_cmd(section,config,'edithdl_modify_verilog')

  return stages

# This routine generates either link_for_bluesim or link_for_verilog
# stages.  The stages contain a single bsc command to perform bsc
# linking.
def build_bsc_link_stages(section,config):
  global HAS_PARTITION

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # nothing to do if this is not a bluesim or Verilog simulation build
  if build_for != 'bluesim' and build_for != 'verilog' and build_for != 'rtllink':
    return []

  options = []
  vfiles  = []
  svfiles = []
  cfiles  = []
  libraries = []

  # setup -simdir and -vdir variables
  partition_for = resolve(section,'design-editor-partition-for',config)
  if build_for == 'bluesim':
    simdir = resolve(section,'simulation-directory',config)
    simdir = fix_rel_path(section,config,simdir)
    if simdir != '.':
      options += ['-simdir ' + simdir]
  else:
    edit_script = resolve(section,'design-editor-script',config)
    if partition_for != None:
      vdir = verilog_last(section, config)
    else:
      vdir = verilog_last2(section, config)
    vdir = fix_rel_path(section,config,vdir)
    if vdir != '.':
      options += ['-vdir ' + vdir]

  # setup the -bdir variable
  bdir = resolve(section,'binary-directory',config)
  bdir = fix_rel_path(section,config,bdir)
  if bdir != '.':
    options += ['-bdir ' + bdir]

  # setup the -info-dir variable
  infodir = resolve(section,'info-directory',config)
  infodir = fix_rel_path(section,config,infodir)
  if infodir != '.':
    options += ['-info-dir ' + infodir]

  # add link options from the user
  bsc_options = resolve(section,'bsc-link-options',config)
  options += bsc_options

  # add fpga defines if exist
  scemiperiod  = get_scemi_clock_period(section,config)
  if scemiperiod:
    options += ['-D SCEMI_CLOCK_PERIOD=%s' % scemiperiod]
  memoryperiod = get_fpga_memory_period(section, config, build_for)
  if memoryperiod:
    options += ['-D MEM_CLOCK_PERIOD=%s' % memoryperiod]

  # SCE-MI designs need -scemi or -scemiTB during the link stage
  scemi_type = resolve(section,'scemi-type',config)
  if scemi_type:
    options += ['-scemi']
    if get_scemi_style_mixed(section,config) == "Classic":
      options += ['-scemi-classic']
  elif resolve(section,'scemi-tb',config):
    options += ['-scemiTB']
    if get_scemi_style_mixed(section,config) == "Classic":
      options += ['-scemi-classic']

  # add Verilog macro definitions from the user
  defines = [ '-D %s' % d for d in resolve(section,'verilog-define',config) ]
  options += defines

  # add defines to instantiate verilog module for the fpgas used
  if partition_for != None:
    fpgas = get_on_fpga(section, config)
    #fpgas = resolve(section,'on-fpga',config)
    for fpga in fpgas:
      if fpga.lower() != 'a':
        options += ['-D USING_%s' % fpga.upper()]

  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  # add any included verilog directories on the link command line
  vsearchdirs = resolve(section,'verilog-lib-directories',config)
  if len(vsearchdirs) != 0:
    vsearchdirs += ['+']
    options += ['-vsearch ' +  ':'.join(vsearchdirs)]

  # add another vsearch directory for modified verilog flow
  if verilog_modified(section, config):
    if partition_for != None:
      outdir = verilog_last2(section, config)
    else:
      outdir = verilog_last(section, config)
    outdir += ':+'
    options += ['-vsearch', outdir]

  # add incdirs
  options += [ '-Xv +incdir+%s' % d for d in resolve(section,'verilog-inc-directories',config) ]

  # if partitioning for an fpga
  if partition_for != None:
    bsup_dir = get_board_support_directory(section,config,bsdir)

    # partition verilog
    if HAS_PARTITION:
      edithdl_outputdir = resolve(section,'design-editor-output-directory',config)
      edithdl_outputdir = fix_rel_path(section,config,edithdl_outputdir)
      options += [ ( '-vsearch %s_partition:+' % edithdl_outputdir ) ]

    # determine the edithdl option
    options += [ ( '-vsearch +:%s' % bsup_dir ) ]

    # determine verilog search libraries
    libs = get_board_verilog_lib_directories(section,config,partition_for)
    vsearchdirs = [ '-vsearch +:%s' % d for d in libs ]
    options += vsearchdirs

  # include any imported Verilog files on the link command line
  if build_for == 'verilog' or build_for == 'rtllink':
    vfiles = [ '%s' % f for f in resolve(section,'imported-verilog-files',config) ]
    svfiles = [ '%s' % f for f in resolve(section,'imported-systemverilog-files',config) ]
    vhdfiles = [ '%s' % f for f in resolve(section,'imported-vhdl-files',config) ]
  else:
    vfiles = []
    svfiles = []
    vhdfiles = []

  # include any imported C files on the link command line
  cfiles = [ '%s' % f for f in resolve(section,'imported-c-files',config) ]

  # include any libraries needed to link
  libraries = [ '%s' % f for f in resolve(section,'c++-libraries',config) ]

  # determine the simulation executable file name
  exe_file = resolve(section,'exe-file',config)
  exe_file = fix_rel_path(section,config,exe_file)

  # add -sim or -verilog -vsim ... options as appropriate
  simulator = resolve(section,'verilog-simulator',config)
  if build_for == 'bluesim':
    options = ['-sim'] + options
  else:
    options = ['-verilog', '-vsim %s' % simulator] + options

  # find the bsc command path, the top BSV file and the top module in
  # the design and combine this with the options created above to make
  # the complete command line.
  bsc_cmd = fix_cmd(resolve(section,'bsc',config))
  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file)
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root
  # If the hdleditor flow is active then change the top_module to top_module_EDITED
  if verilog_modified(section, config):
    top_module += verilog_suffix(section, config)
  if partition_for != None:
    board_top_module = get_board_top_module(section,config,partition_for,'')
    if board_top_module != None:
      top_module = board_top_module
  link_top_module = resolve(section,'link-top-module',config)
  if link_top_module != None:
    top_module = link_top_module
  cmd = '%s %s -o %s -e %s %s %s %s %s %s' % (bsc_cmd,' '.join(options),exe_file,top_module,' '.join(vfiles),' '.join(svfiles),' '.join(vhdfiles),' '.join(cfiles), ' '.join(libraries))

  # generate the appropriately named stage with the bsc link command
  if build_for == 'bluesim':
    stages = build_pre_stage_cmd(section,config,'link_for_bluesim')
    stages += [('link_for_bluesim',[cmd])]
    stages += build_post_stage_cmd(section,config,'link_for_bluesim')
  else:
    stages = build_pre_stage_cmd(section,config,'link_for_verilog')
    stages +=[('link_for_verilog',[cmd])]
    stages += build_post_stage_cmd(section,config,'link_for_verilog')

  if (doingReadback(section,config) and simulator == 'modelsim'):
    sedcmd = "sed -i 's+\-c main \\$+\-c main glbl \\$+' %s" % exe_file
    stages += [('link_for_verilog',[sedcmd])]

  return stages


def build_semu_wrapper_stages(section,config):

  # first test if generate-semu-wrapper directive was set
  if (not resolve(section,'generate-semu-wrapper',config)):
    return []

  # nothing to do if this is not a BSV build
  build_for = resolve(section,'build-for',config).lower()
  if build_for == 'c++' or build_for == 'systemc' or build_for == 'rtllink':
    return []

  pin_file = resolve(section,'pin-file',config)
  if (pin_file == ''):
    return ('error', 'The project file does not specify the pin file.')

  gsrc_dir = resolve(section,'bsv-generated-source-directory',config)
  gsrc_dir = fix_rel_path(section,config,gsrc_dir)

  bsup_dir_root = get_board_support_directory_root(section,config)
  bsup_scripts_dir = os.path.join(bsup_dir_root,'scripts')
  gen_script = os.path.join(bsup_scripts_dir,'Generate_BSV_wrappers.py')

  cmd = ['%s %s %s' % (gen_script,pin_file,gsrc_dir)]

  # copy the bridge file to the local directory
  bsup_bnoc_dir = os.path.join(bsup_dir_root,'bluenoc')
  bsup_bnoc_bridges_dir = os.path.join(bsup_bnoc_dir,'bridges')
  bridge_file = os.path.join(bsup_bnoc_bridges_dir,'Bridge.bsv')
  cmd += ['%s %s %s' % ('cp',bridge_file,gsrc_dir)]

  stages = [('generate_semu_wrappers',cmd)]
  return stages


def build_semu_testbench_stages(section,config):

  # first test if generate-semu-testbench directive was set
  if (not resolve(section,'generate-semu-testbench',config)):
    return []

  pin_file = resolve(section,'pin-file',config)
  if (pin_file == ''):
    return ('error', 'The project file does not specify the pin file.')

  cpp_gen_src_dir = resolve(section,'c++-generated-source-directory',config)
  simdir = resolve(section,'simulation-directory',config)
  simdir = fix_rel_path(section,config,simdir)

  bsup_dir_root = get_board_support_directory_root(section,config)
  bsup_scripts_dir = os.path.join(bsup_dir_root,'scripts')
  gen_script = os.path.join(bsup_scripts_dir,'Generate_TestBench.py')

  cmd = '%s %s %s %s' % (gen_script,pin_file,simdir,cpp_gen_src_dir)
  if (resolve(section,'semu-user-testbench',config)):
    cmd += ' 1'

  stages = [('generate_semu_testbench',[cmd])]
  return stages


# For readback, we create a second version of the Verilog files using
# the 'edit_for_elab' script.  The files are placed in an 'elab_source'
# subdirectory, which is hardcoded in the 'prepare_pa_project' script.
#
def build_elab_source_stages(section,config):

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # nothing to do if this is not a bluesim or Verilog simulation build
  if not verify_create_elab_sources_board_for(build_for):
    return []

  partition_for = resolve(section,'design-editor-partition-for',config)

  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file)
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root
  # If the hdleditor flow is active then change the top_module to top_module_EDITED
  if verilog_modified(section, config):
    top_module += verilog_suffix(section, config)
  if partition_for != None:
    board_top_module = get_board_top_module(section,config,partition_for,'')
    if board_top_module != None:
      top_module = board_top_module

  xilinx_dir = resolve(section,'xilinx-directory',config)
  xilinx_dir = fix_rel_path(section,config,xilinx_dir)
  if build_for == 'b2000t' or build_for == 'rpp2split':
    top_fpga_module = get_board_top_fpga_module(section,config,build_for,'a')
    list_file = '%s/%s.files' % (xilinx_dir, top_fpga_module)
  else:
    top_fpga_module = top_module
    list_file = '%s/%s.files' % (xilinx_dir, top_module)

  elab_source_dir = os.path.join(xilinx_dir, 'elab_source')
  mkdir_cmd = 'mkdir -p %s' % elab_source_dir

  bsdir = os.getenv('BLUESPECDIR')

  exe_path = '%s/bin/edit_for_elab' % bsdir
  options = []
  options += ['-f ' + list_file]

  script_cmd = '%s %s %s/elab_source' % (exe_path,' '.join(options), xilinx_dir);

  # generate the appropriately named stage with the bsc link command
  stages = build_pre_stage_cmd(section,config,'create_elab_source')
  stages += [('create_elab_source', [mkdir_cmd, script_cmd])]
  stages += build_post_stage_cmd(section,config,'create_elab_source')
  return stages

# This routine generates either link_for_bluesim or link_for_verilog
# stages.  The stages contain a single bsc command to perform bsc
# linking.
def build_bsc_cosim_link_stages(section,config):

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()
  do_cosim = doing_cosim(section,config)

  if not do_cosim:
    return []

  if build_for == 'bluesim':
    return []

  options = []
  vfiles  = []
  svfiles = []
  cfiles  = []

  # setup -simdir and -vdir variables
  vdir = resolve(section,'verilog-directory',config)
  vdir = fix_rel_path(section,config,vdir)
  if vdir != '.':
    options += ['-y ' + vdir]

  # add Verilog macro definitions from the user
  defines = [ '-D %s' % d for d in resolve(section,'verilog-define',config) ]
#  options += defines

  # add any included verilog directories on the link command line
  vsearchdirs = [ '-y %s' % d for d in resolve(section,'verilog-lib-directories',config) ]
  options += vsearchdirs

  # add any included verilog directories on the link command line
  vsearchdirs = [ '+incdir+%s' % d for d in resolve(section,'verilog-inc-directories',config) ]
  options += vsearchdirs

  # add another vsearch directory for modified verilog flow
  if verilog_modified(section, config):
    outdir = verilog_last(section, config)
    options += ['-y ', outdir]
  # include any imported Verilog files on the link command line
  if build_for == 'verilog' or build_for == 'rtllink':
    vfiles = [ '%s' % f for f in resolve(section,'imported-verilog-files',config) ]
    svfiles = [ '%s' % f for f in resolve(section,'imported-systemverilog-files',config) ]
  else:
    vfiles = []
    svfiles = []

  # include any imported C files on the link command line
  cfiles = [ '%s' % f for f in resolve(section,'imported-c-files',config) ]

  # determine the simulation executable file name
  exe_file = 'cosim.exe'

  # get the BLUESPECDIR path, used as the root of other paths
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)
  style = get_scemi_style_mixed(section,config)

  filename = ( '%s/Verilog/main.v' % bsdir )
  vfiles += [ filename ]

  options += [ ( '-y %s/Verilog' % bsdir ) ]

  options += [ ( '-y %s/Libraries' % bsdir ) ]
  options += [ ( '-y %s/Libraries/%s' % (bsdir,style) ) ]

  lib = ( '%s/tcllib/%s/cosim.so' % (bsdir, tcl_libdir(bsdir)) )

  dirname = verilog_last(section, config)
  scd_file  = resolve(section,'cosim-scd-file',config)
  map_file  = ( '%s/path.map' % dirname )
  v_file    = ( '%s/'         % dirname )

  top_file = resolve(section,'top-file',config)
  top_file = fix_rel_path(section,config,top_file)
  (dirname,filename) = os.path.split(top_file)
  (root,ext) = os.path.splitext(filename)
  top_module = resolve(section,'top-module',config)
  if top_module.startswith("'mk-' prefix"):
    top_module = 'mk' + root

  top_module += cosim_suffix(section,config)

  v_file += top_module
  v_file += '.v'

  simulator = resolve(section,'cosim-verilog-simulator',config)

  work_dir  = 'work_'
  work_dir += top_module

  flag64   = ''
  if is64(bsdir):
    if simulator == 'vcs':
      flag64 = '-full64'

  cmds = []
  if simulator == 'modelsim':
    if which('vlib') == None:
      return []
    if which('vlog') == None:
      return []

    print "Linking with modelsim for cosim."
    cmds += ['if [ -e %s ]; then vlib %s; vlog -work %s +libext+.v +define+TOP=%s +define+NO_CLOCK %s %s %s %s; fi' % (v_file, work_dir,  work_dir, top_module, ' '.join(options),' '.join(vfiles),' '.join(svfiles),' '.join(cfiles))]
    cmds += ['if [ -e %s ]; then  rm -f %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "#!/bin/sh" > %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "vsim %s -quiet -novopt -lib %s -pli %s -do \\"run -all; quit\\" -c main +cosim_top=cosim +cosim_data=%s +cosim_map=%s \$*" >> %s; fi' % (v_file, flag64, work_dir, lib, scd_file, map_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "status=\$?" >> %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "if [ \\"\$status\\" != \\"0\\" ]; then" >> %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "    echo \\"ERROR: cannot simulate design\\" >&2" >> %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "    exit \$status" >> %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  echo "fi" >> %s; fi' % (v_file, exe_file)]
    cmds += ['if [ -e %s ]; then  chmod +x %s; fi' % (v_file, exe_file)]
  elif simulator == 'vcs':
    if which('vcs') == None:
      return []

    print "Linking with vcs for cosim."
    cmds += ['if [ -e %s ]; then vcs -V -o %s +v2k +libext+.v +define+TOP=%s +define+NO_CLOCK +plusarg_save %s +vpi +acc+2 %s -load %s +cosim_top=cosim +cosim_data=%s +cosim_map=%s %s %s %s %s; fi' % (v_file, exe_file, top_module, flag64, lib, lib, scd_file, map_file, ' '.join(options), ' '.join(vfiles), ' '.join(svfiles), ' '.join(cfiles))]
  else:
    if which('cvc') == None:
      return []

    print "Linking with cvc for cosim."
    cmds += ['if [ -e %s ]; then %s -o %s +acc+2 +libext+.v +define+TOP=%s +define+NO_CLOCK +loadvpi=%s:BCosim_boot +cosim_top=cosim +cosim_data=%s +cosim_map=%s %s %s %s %s; fi' % (v_file, 'cvc', exe_file, top_module, lib, scd_file, map_file, ' '.join(options),' '.join(vfiles),' '.join(svfiles), ' '.join(cfiles))]

  # generate the appropriately named stage with the bsc link command
  stages = build_pre_stage_cmd(section,config,'link_for_cosim')
  stages += [('link_for_cosim',cmds)]
  stages += build_post_stage_cmd(section,config,'link_for_cosim')

  return stages

def doing_cosim(section,config):
  build_for = resolve(section,'build-for',config).lower()
  if build_for == 'bluesim' or build_for == 'c++' or build_for == 'systemc':
    return False
  if (not resolve(section,'run-design-editor',config)):
    return False
  edit_script = resolve(section,'design-editor-script',config)
  if edit_script:
    try:
      cosim = False;
      openfile = file(edit_script)
      if (openfile):
        for line in openfile:
          index_comment = line.find('#')
          index_cosim   = line.find('addcosim')
          if (index_cosim != -1 and (index_comment == -1 or index_comment > index_cosim)):
            cosim = True
            break
        openfile.close()
      return cosim
    except IOError, ioerror:
      return False
  return False

# This routine builds the stages for C++ compilation.
def build_cpp_stages(section,config):

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()

  # nothing to do if this is not a C++ build
  if build_for != 'c++' and build_for != 'systemc':
    return []

  stages = []

  # get the BLUESPECDIR path
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  # find the C++ source directories
  cxx_src_dir = resolve(section,'c++-source-directory',config)
  cxx_gen_src_dir = resolve(section,'c++-generated-source-directory',config)

  # if we need to generate C++ header files for BSV types, we create
  # the gen_cxx_includes stage
  cxx_header_output_dir = '.'
  cxx_header_targets = [ t.lower() for t in resolve(section,'c++-header-targets',config) if t.lower() != 'none' ]
  if len(cxx_header_targets) != 0:
    cmds = []
    options = []

    # determine the top BSV file and the top design module
    top_file = resolve(section,'top-file',config)
    top_file = fix_rel_path(section,config,top_file)
    (dirname,filename) = os.path.split(top_file)
    (root,ext) = os.path.splitext(filename)
    top_module = resolve(section,'top-module',config)
    if top_module.startswith("'mk-' prefix"):
      top_module = 'mk' + root

    # determine where to write the generated header files
    cxx_header_output_dir = resolve(section,'c++-header-directory',config)
    if cxx_header_output_dir == 'the c++-generated-source-directory':
      cxx_header_output_dir = cxx_gen_src_dir
    #cxx_header_output_dir = fix_rel_path(section,config,cxx_header_output_dir)
    if cxx_header_output_dir != '.':
      cmds += ['mkdir -p %s' % cxx_header_output_dir]

    # figure out which package to use for obtaining BSV types
    cxx_header_types_pkg = resolve(section,'c++-header-types-package',config)
    if cxx_header_types_pkg == 'the package of top-file':
      cxx_header_types_pkg = root

    # setup the -bdir and -p path options
    bdir = resolve(section,'binary-directory',config)
    bdir = fix_rel_path(section,config,bdir)

    if bdir != '.':
      options += ['-bdir ' + bdir]
    src_dirs = []
    src_dir = resolve(section,'bsv-source-directory',config)
    if src_dir != '.':
      src_dirs += [src_dir]
    src_dir = resolve(section,'bsv-generated-source-directory',config)
    src_dir = fix_rel_path(section,config,src_dir)
    if src_dir != '.':
      src_dirs += [src_dir]
    src_dirs += resolve(section,'bsv-source-directories',config)
    src_dirs += resolve(section,'verilog-lib-directories',config)
    if verilog_modified(section, config):
      src_dirs += [verilog_last(section,config)]
    path = src_dirs
    if len(path) != 0:
      options += ['-p %s:+' % ':'.join(path)]
    if get_scemi_style_mixed(section,config) == 'Classic':
      options += ['-scemi-classic']

    # generated header files may go into a special output directory
    if cxx_header_output_dir != '.':
      options += ['-outdir %s' % cxx_header_output_dir]

    # set options to control what files to generate
    scemi_enum_prefix = resolve(section,'c++-header-enum-prefix',config)
    scemi_member_prefix = resolve(section,'c++-header-member-prefix',config)
    options += ['-enumPrefix %s' % scemi_enum_prefix]
    options += ['-memberPrefix %s' % scemi_member_prefix]
    cxx_header_probe_code = resolve(section,'c++-header-probe-code',config)
    if cxx_header_probe_code:
      options += ['-probe-code']
    cxx_header_aliases = resolve(section,'c++-header-aliases',config)
    if cxx_header_aliases:
      options += ['-aliases']
    probe_vcd_file = resolve(section,'probe-vcd-file',config)
    options += ['-vcd %s' % probe_vcd_file]
    options += ['-%s' % t for t in cxx_header_targets]

    # determine the SCE-MI parameters file name
    hdledit_scemi_params = resolve(section,'design-editor-edit-params',config)
    if hdledit_scemi_params:
      scemi_params = resolve(section,'design-editor-output-params',config)
      if scemi_params.startswith('the value of top-module'):
        scemi_params = top_module + '_EDITED.params'
      scemi_params = fix_rel_path(section,config,scemi_params)
    else:
      scemi_params = resolve(section,'scemi-parameters-file',config)
      if scemi_params.startswith('the value of top-module'):
        scemi_params = top_module + '.params'
      scemi_params = fix_rel_path(section,config,scemi_params)
      scemi_params = determine_param_filename(scemi_params)

    # put it all together to create the generateSceMiHeaders.tcl
    # command line
    cmds += ['%s/tcllib/bluespec/generateSceMiHeaders.tcl -package %s %s %s' % (bsdir,cxx_header_types_pkg,' '.join(options),scemi_params)]
    stages += [('gen_cxx_includes',cmds)]

  # get the list of user C++ files to compile
  cxx_files = resolve(section,'c++-files',config)
  if len(cxx_files) != 0:
    if cxx_src_dir == '.':
      usr_files = cxx_files
    else:
      usr_files = make_abs(cxx_src_dir, cxx_files)
  else:
    c_pattern   = '*.c'
    cc_pattern  = '*.cc'
    cpp_pattern = '*.cpp'
    cxx_pattern = '*.cxx'
    if cxx_src_dir != '.':
      c_pattern   = os.path.join(cxx_src_dir,c_pattern)
      cc_pattern  = os.path.join(cxx_src_dir,cc_pattern)
      cpp_pattern = os.path.join(cxx_src_dir,cpp_pattern)
      cxx_pattern = os.path.join(cxx_src_dir,cxx_pattern)
    usr_files = glob.glob(c_pattern) + glob.glob(cc_pattern) + glob.glob(cpp_pattern) + glob.glob(cxx_pattern)
    usr_files.sort()

  # get the list of generated C++ files to compile
  cxx_gen_files = resolve(section,'c++-generated-files',config)
  if len(cxx_gen_files) != 0:
    if cxx_gen_src_dir == '.':
      gen_files = cxx_gen_files
    else:
      gen_files = make_abs(cxx_gen_src_dir, cxx_gen_files)
  else:
    # Unlike for user files, we don't automatically include all generated files
    # if none of specifically specified
    gen_files = []

  # if the gen_cxx_includes stage created a SceMiProbes.cxx file, we
  # add it to the file list here.
  cxx_header_probe_code = resolve(section,'c++-header-probe-code',config)
  if (cxx_header_probe_code or 'all' in cxx_header_targets):
    if cxx_header_output_dir == '.':
      probe_cxx_file = 'SceMiProbes.cxx'
    else:
      probe_cxx_file = os.path.join(cxx_header_output_dir,'SceMiProbes.cxx')
    if probe_cxx_file not in gen_files:
      gen_files += [probe_cxx_file]

  # add in C preprocessor macro definitions from the user
  options = []
  defines = [ '-D%s' % d for d in resolve(section,'c++-define',config) ]
  options += defines

  # add in C++ compiler flags from the user
  cxx_flags = resolve(section,'c++-options',config)
  options += cxx_flags

  # determine the set of include directories, library location and libraries
  # to link against
  includes = []
  libdirs = []
  libraries = resolve(section,'c++-libraries',config)
  # source directory
  if cxx_src_dir != '.':
    includes += ['-I' + cxx_src_dir]
  if cxx_gen_src_dir != '.':
    includes += ['-I' + cxx_gen_src_dir]
  # generated header output directory
  if (cxx_header_output_dir != '.' and
      cxx_header_output_dir != cxx_src_dir and
      cxx_header_output_dir != cxx_gen_src_dir):
    includes += ['-I' + cxx_header_output_dir]
  # SystemC installation area
  if build_for == 'systemc':
    systemc_home = fix_path(resolve(section,'systemc-home',config))
    if systemc_home:
      includes += ['-I%s/include' % systemc_home]
      libdirs += ['-L%s/%s' % (systemc_home, sysc_libdir(bsdir))]
      libraries += ['-lsystemc']
    else:
      print 'Warning: unable to determine SystemC installation location -- set SYSTEMC or use systemc-home'
  # TCL installation area
  if resolve(section,'uses-tcl',config):
    tcl_home = fix_path(resolve(section,'tcl-home',config))
    options += ['-DUSE_TCL_STUBS']
    includes += ['-I%s/include' % tcl_home]
    libdirs += ['-L%s/%s' % (tcl_home, tcl_libdir(bsdir))]
    libraries += ['-ltclstub8.5']

  # SCE-MI area in BLUESPECDIR
  if resolve(section,'scemi-tb',config):
    scemi_home = os.path.join(bsdir, 'SceMi', get_scemi_style_mixed(section,config))
    options += ['-std=gnu++98']
    includes += ['-I' + scemi_home]
    libdirs += ['-L%s/%s' % (scemi_home, cxx_family(bsdir))]
    libraries += ['-lscemi', '-lpthread', '-ldl']  # SCE-MI needs libpthread and libdl, too
    if platform.system() != "Darwin":
      libraries += ['-lrt']

  # determine the C++ compiler
  cxx_cmd = resolve(section,'c++-compiler',config)

  # determine the executable or shared library name
  exe_file = resolve(section,'exe-file',config)
  shared_lib = resolve(section,'shared-lib',config)
  if shared_lib == None:
    # the command for generating an executable
    cmd = '%s -o %s %s %s %s %s %s %s' % (cxx_cmd,exe_file,' '.join(options),' '.join(usr_files),' '.join(gen_files),' '.join(includes),' '.join(libdirs),' '.join(libraries))
  else:
    # the command for generating a shared library
    readback = doingReadback(section,config) or resolve(section,'c++-uses-readback',config)
    if readback:
      readback_inc = os.path.join(bsdir, 'Readback')
      scemi_root = os.path.join(bsdir, 'SceMi')
      scemi_bsvxtors_inc = os.path.join(scemi_root, 'bsvxactors')
      scemi_capi_inc = os.path.join(scemi_root, 'capi')
      options += ['-std=gnu++98']
      includes += ['-I' + readback_inc,
                   '-I' + scemi_bsvxtors_inc,
                   '-I' + scemi_capi_inc]
      if is64(bsdir):
        libdirs += ['-L%s/tcllib/lib.linux64' % bsdir]
        libraries += ['-ldesign -lz', '-lsemucapi', '-lbsvxtors -lscemi']
      else:
        libdirs += ['-L%s/tcllib/lib.linux32' % bsdir]
        libraries += ['-ldesign -lz', '-lsemucapi', '-lbsvxtors -lscemi']
    shared_flag = subprocess.Popen([bsdir + '/bin/bsenv', 'c++_shared_flags'], stdout=subprocess.PIPE).communicate()[0].strip()
    cmd = '%s %s -fPIC -o %s %s %s %s %s %s %s' % (cxx_cmd,shared_flag,shared_lib,' '.join(options),' '.join(usr_files),' '.join(gen_files),' '.join(includes),' '.join(libdirs),' '.join(libraries))

  # use the command for a stage, named build_systemc_tb or
  # build_c++_tb as appropriate
  if build_for == 'systemc':
    stages += build_pre_stage_cmd(section,config,'build_systemc_tb')
    stages += [('build_systemc_tb',[cmd])]
    stages += build_post_stage_cmd(section,config,'build_systemc_tb')
  else:
    stages += build_pre_stage_cmd(section,config,'build_c++_tb')
    stages += [('build_c++_tb',[cmd])]
    stages += build_post_stage_cmd(section,config,'build_c++_tb')

  return stages


# This routine generates all of the stages to build .rbf file from
# Verilog source using the Altera Quartus tool flow.
def build_altera_stages(section,config):
  global JOBS

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()
  board = get_board(build_for)

  # this only applies to FPGA boards with Altera parts
  if not verify_altera_build_board_for(board):
    return []

  stages = []

  # determine the BLUESPECDIR path
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  # the path to the board-specific board support area
  bsup_dir = get_board_support_directory(section,config,bsdir)
  board_support_dir = get_board_support_subdirectory(section,config,bsdir,build_for)

  # determine the quartus synthesis area to use
  quartus_root_dir = resolve(section,'altera-directory',config)

  # get partition_for
  partition_for = resolve(section,'design-editor-partition-for',config)
  if partition_for == None:
    if verify_build_for_multi_fpga(build_for):
      partition_for = build_for

  # setup the paths to search for Verilog files
  vdir = resolve(section,'verilog-directory',config)
  vdir = fix_path(vdir)
  vlog_lib_dirs = make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'verilog-lib-directories',config)))
  vlog_inc_dirs = make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'verilog-inc-directories',config)))
  vlog_board_lib_dirs = get_board_verilog_lib_directories(section,config,partition_for)
  if verilog_modified(section, config):
    vlog_edithdl_dir = verilog_last(section,config)
    vlog_edithdl_dir = fix_path(vlog_edithdl_dir)
    vlog_dirs = ';'.join([vdir] + vlog_lib_dirs + vlog_inc_dirs + [vlog_edithdl_dir] + vlog_board_lib_dirs)
  else:
    vlog_dirs = ';'.join([vdir] + vlog_lib_dirs + vlog_inc_dirs + vlog_board_lib_dirs)

  # determine which FPGA on the board this design is targeting
  fpgas = get_on_fpga(section, config)
  #fpgas = resolve(section,'on-fpga',config)

  bsup_dir_root = get_board_support_directory_root(section,config)
  timing_script = os.path.join(bsup_dir_root,'scripts/altera_timing')

  if int(JOBS) > 1:
    print "creating makefile for parallel quartus compile"
    makefilename = ".%s_quartus.mk" % CURRENT_TARGET
    makefile = open(makefilename, 'w')

  # For each fpga
  for fpga in fpgas:

    fpga = fpga.lower()

    if int(JOBS) > 1:
      makefile.write("\ndefault: ")
      makefile.write("fpga_%s_build\n" % fpga)

    # determine the SODIMM style to use
    # TODO  XXX this attribuite should be on a per chip basis.
    sodimm = 'NONE'
    if fpga == 'a':
      sodimm = resolve(section,'sodimm-style',config).upper()

    # Cleanup and create directories for quartus synthesized data
    stages += setup_altera_dir(quartus_root_dir,fpga, sodimm)

    quartus_dir = quartus_root_dir + '/' + 'fpga_' + fpga

    # Name of top level fpga file
    top_fpga_file = get_board_top_fpga_file(section,config,bsdir,board,build_for,fpga)

    # Name of top level fpga module
    top_fpga_module = get_board_top_fpga_module(section,config,build_for,fpga)

    # Name of top bsv module
    top_module = get_board_top_module(section,config,build_for,fpga)


    # determine the clock period of the scemi clock and the memory clock (if used)
    scemiperiod  = get_scemi_clock_period(section,config)
    memoryperiod = get_fpga_memory_period(section, config, build_for)

    gen_qxp_file = resolve(section,'generate-qxp-file',config)
    gen_vo_file  = resolve(section,'generate-vo-file',config)

    # this group of commands creates the .qsf file which drives
    # the quartus synthesis.  It starts with a template file and
    # some SODIMM-specific constraint files in the board support area
    # and combines these -- modified by some substitutions via sed --
    # into the final .qsf file.
    sed_progs = ['s+__VDIRS__+%s+g' % vlog_dirs,
                 's+__VDIR__+%s+g' % vdir,
                 's+__BLUESPECDIR__+%s+g' % bsdir,
                 's+__BOARD__+%s+g' % board,
                 's+__TOP_FPGA_FILE__+%s+g' % top_fpga_file,
                 's+__TOP_FPGA_MODULE__+%s+g' % top_fpga_module,
                 's+__TOP_MODULE__+%s+g' % top_module,
                 's+__SODIMM_STYLE__+%s_SODIMM_STYLE+g' % sodimm,
                 's+__SCEMI_CLOCK_PERIOD__+%1.3f+g' % scemiperiod,
                 's+__SCEMI_CLOCK_PERIOD2__+%1.3f+g' % (scemiperiod/2),
                 's+__SCEMI_CLOCK_DBL_PERIOD__+%1.3f+g' % (scemiperiod*2),
                 's+__MEM_CLOCK_PERIOD__+%1.3f+g' % memoryperiod,
                 's+__MEM_CLOCK_PERIOD2__+%1.3f+g' % (memoryperiod/2)]

    syn_stages = []

    # Create qsf file
    stages += create_altera_qsf_file(section,config,bsdir,board_support_dir,build_for,
                                     board,quartus_dir,fpga,sodimm,sed_progs)

    # Create sdc file
    stages += create_altera_sdc_file(section,config,board_support_dir,board,
                                     quartus_dir,fpga,sodimm,sed_progs)

    # these stages run the quartus commands to synthesize all of the way
    # to a final .rbf file
    syn_stages += [(('quartus_sh_fpga_%s' % fpga),\
                      ['cd %s && quartus_sh --prepare fpga_%s' % (quartus_dir,fpga)])]

    common_opts = ['--read_settings_files=on', '--write_settings_files=off', 'fpga_%s' % fpga]
    if is64(bsdir):
      common_opts += ['--64bit']
    map_opts = common_opts + resolve(section,'quartus-map-options',config)
    syn_stages += [(('quartus_map_fpga_%s' % fpga),\
                      ['cd %s && quartus_map %s' % (quartus_dir,' '.join(map_opts))])]

    if gen_qxp_file:
      syn_stages += [(('quartus_qxp_fpga_%s' % fpga),\
                        ['cd %s && quartus_cdb %s --incremental_compilation_export=fpga_%s.qxp --incremental_compilation_export_partition_name=Top --incremental_compilation_export_post_synth=on --incremental_compilation_export_post_fit=off --incremental_compilation_export_routing=on' % (quartus_dir, ' '.join(common_opts), fpga)])]

    if gen_vo_file:
      syn_stages += [(('quartus_vo_fpga_%s' % fpga),\
                        ['cd %s && quartus_eda %s' % (quartus_dir, ' '.join(common_opts))])]

    if sodimm == 'DDR2':
      if get_altera_part_type_dini(build_for) == 'stratixiii':
        syn_stages += [(('quartus_ddr2_pins_fpga_%s' % fpga),['cd %s && quartus_sh -t %s fpga_%s' % (quartus_dir,os.path.join(bsup_dir,'altera','verilog','ddr2_v12_1','ddr2_v12_1','ddr2_v12_1_p0_pin_assignments.tcl'),fpga)])]
      elif get_altera_part_type_dini(build_for) == 'stratixiv':
        syn_stages += [(('quartus_ddr2_pins_fpga_%s' % fpga),['cd %s && quartus_sh -t %s fpga_%s' % (quartus_dir,os.path.join(bsup_dir,'altera','verilog','ddr2_v12_1_iv','ddr2_v12_1','ddr2_v12_1_p0_pin_assignments.tcl'),fpga)])]


    fit_opts = common_opts + resolve(section,'quartus-fit-options',config)
    syn_stages += [(('quartus_fit_fpga_%s' % fpga),\
                      ['cd %s && quartus_fit %s' % (quartus_dir,' '.join(fit_opts))])]

    drc_opts = common_opts + resolve(section,'quartus-drc-options',config)
    syn_stages += [(('quartus_drc_fpga_%s' % fpga),\
                      ['cd %s && quartus_drc %s' % (quartus_dir,' '.join(drc_opts))])]

    asm_opts = common_opts + resolve(section,'quartus-asm-options',config)
    syn_stages += [(('quartus_asm_fpga_%s' % fpga),\
                      ['cd %s && quartus_asm %s' % (quartus_dir,' '.join(asm_opts))])]

    sta_opts = ['--do_report_timing', '--sdc=fpga_%s.sdc' % fpga]

    if sodimm == 'DDR2':
      if get_altera_part_type_dini(build_for) == 'stratixiii':
        sta_opts += [' --sdc=%s' % os.path.join(bsup_dir, 'altera', 'verilog', 'ddr2_v12_1', 'ddr2_v12_1', 'ddr2_v12_1_p0.sdc')]
      elif get_altera_part_type_dini(build_for) == 'stratixiv':
        sta_opts += [' --sdc=%s' % os.path.join(bsup_dir, 'altera', 'verilog', 'ddr2_v12_1_iv', 'ddr2_v12_1', 'ddr2_v12_1_p0.sdc')]
    sta_opts += resolve(section,'quartus-sta-options',config)
    sta_opts += ['fpga_%s' % fpga]

    syn_stages += [(('quartus_sta_fpga_%s' % fpga),\
                  ['cd %s && quartus_sta %s' % (quartus_dir,' '.join(sta_opts))])]

    syn_stages += [(('quartus_timing_check_fpga_%s' % fpga),\
                  ['%s %s/fpga_%s.sta.summary %s/fpga_%s.sta.rpt' % (timing_script, quartus_dir, fpga, quartus_dir, fpga)])]

    # if multiple jobs then put the commands in a makefile and do parallel build
    if int(JOBS) > 1:
      create_quartus_compile_makefile(makefile,fpga,syn_stages)
    else:
      stages += syn_stages

  if int(JOBS) > 1:
    stages += [('quartus_parallel_synthesis',\
                  ['make -f .%s_quartus.mk -j %s' % (CURRENT_TARGET, str(JOBS))])]
    makefile.close()

  return stages


# This routine fill the content of the makefile to run parallel quartus
def create_quartus_compile_makefile(makefile, fpga, stages):

  first = True

  for stage in stages:
    if first == True:
      makefile.write("\nfpga_%s_build:\n" % fpga)
      makefile.write("\techo '*** make: %s'\n" % stage[1][0])
      makefile.write("\t%s\n" % stage[1][0])
      makefile.write("\techo '*** made: %s'\n" % stage[1][0])
      first = False
    else:
      cmd = stage[1][0]
      makefile.write("\techo '*** make: %s'\n" % cmd)
      makefile.write("\t%s\n" % cmd)
      makefile.write("\techo '*** made: %s'\n" % cmd)

  makefile.write("\n")

# This routine cleans up previously built altera data files and
# make sure that the alter directories are created for the next build
def setup_altera_dir(quartus_root_dir, fpga, sodimm):

  stages = []

  quartus_dir = quartus_root_dir + '/' + 'fpga_' + fpga

  # make cleanup stages to remove any remains of prior synthesis runs
  cleanup_extensions = ['rbf', 'rpt', 'pin', 'summary', 'sof', 'qsf', 'smsg', 'qpf', 'sdc']
  if quartus_dir != '.':
    stages += [('quartus_cleanup_fpga_%s' % fpga,\
                  [quartus_dir + '/db', quartus_dir + '/incremental_db'],\
                  ['%s/*.%s' % (quartus_dir,ext) for ext in cleanup_extensions])]
  else:
    stages += [('quartus_cleanup_fpga_%s' % fpga,\
                  ['db', 'incremental_db'],\
                  ['*.%s' % ext for ext in cleanup_extensions])]

  # a stage to create the quartus synthesis area
  if quartus_dir != '.':
    stages += [(('make_quartus_directory_fpga_%s' % fpga), ['mkdir -p %s' % quartus_dir])]

  return stages

def setup_intel_dir(quartus_root_dir, sodimm):

  stages = []

  quartus_dir = quartus_root_dir

  # make cleanup stages to remove any remains of prior synthesis runs
  cleanup_extensions = ['rbf', 'rpt', 'pin', 'summary', 'sof', 'qsf', 'smsg', 'qpf', 'sdc']
  if quartus_dir != '.':
    stages += [('intel_cleanups',\
                  [quartus_dir + '/qdb', quartus_dir + '/incremental_db'],\
                  ['%s/*.%s' % (quartus_dir,ext) for ext in cleanup_extensions])]
  else:
    stages += [('intel_cleanup',\
                  ['db', 'incremental_db'],\
                  ['*.%s' % ext for ext in cleanup_extensions])]

  # a stage to create the quartus synthesis area
  if quartus_dir != '.':
    stages += [(('make_quartus_directory'), ['mkdir -p %s' % quartus_dir])]

  return stages

# This routine create the altera qsf file
def create_altera_qsf_file(section,config,bsdir,board_support_dir,build_for,board,
                           quartus_dir,fpga,sodimm,sed_progs):

  upfpga = fpga.upper()
  fpga.lower()

  directive = 'quartus-qsf-file'
  if fpga != '':
    directive += '-' + fpga
  qsf_file = resolve(section,directive,config)
  if not qsf_file:
    qsf_file = resolve(section,'quartus-qsf-file',config)
  if qsf_file:
    add_sodimm_to_qsf = False
    add_pins_to_qsf   = False
  else:
    add_sodimm_to_qsf = True
    add_pins_to_qsf   = True
    qsf_file = os.path.join(board_support_dir,'fpga_%s.qsf.template' % fpga)

  qsf_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/fpga_%s.qsf' % (qsf_file,quartus_dir,fpga)]
  if add_pins_to_qsf:
    qsf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_%s_pin_assignments >> %s/fpga_%s.qsf' % (board_support_dir,board,upfpga,quartus_dir,fpga)]
  if sodimm != 'NONE' and add_sodimm_to_qsf:
    qsf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_%s_%s_pin_assignments >> %s/fpga_%s.qsf' % (board_support_dir,board,upfpga,sodimm,quartus_dir,fpga)]
    qsf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_sodimm_attributes >> %s/fpga_%s.qsf' % (board_support_dir,sodimm,quartus_dir,fpga)]
  qsf_supplement = resolve(section,'quartus-qsf-supplement-file',config)
  if qsf_supplement:
    qsf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/fpga_%s.qsf' % (qsf_supplement,quartus_dir,fpga)]
  fpgas = get_on_fpga(section, config)
  #fpgas = resolve(section,'on-fpga',config)
  for f in fpgas:
    if f != 'a' and f != 'A':
      qsf_cmds += ['echo "set_global_assignment -name VERILOG_MACRO USING_%s=1"' % f.upper() + ' >> %s/fpga_%s.qsf' % (quartus_dir,fpga)]

  # Add Macro 'board_7xxx=1'
  board = get_board(build_for)
  if board != None:
    qsf_cmds += ['echo "set_global_assignment -name VERILOG_MACRO BOARD_%s=1"' % board + ' >> %s/fpga_%s.qsf' % (quartus_dir,fpga)]

  for d in resolve(section,'verilog-define',config):
    qsf_cmds += ['echo "set_global_assignment -name VERILOG_MACRO %s"' % d + ' >> %s/fpga_%s.qsf' % (quartus_dir,fpga)]

  # Add imported verilog files
  for d in make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'imported-verilog-files',config))):
    qsf_cmds += ['echo "set_global_assignment -name VERILOG_FILE %s"' % d + ' >> %s/fpga_%s.qsf' % (quartus_dir,fpga)]

  for d in make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'imported-systemverilog-files',config))):
    qsf_cmds += ['echo "set_global_assignment -name SYSTEMVERILOG_FILE %s"' % d + ' >> %s/fpga_%s.qsf' % (quartus_dir,fpga)]

  stages = [(('create_qsf_file_fpga_%s' % fpga),qsf_cmds)]

  return stages


# This routine create the altera sdc file
def create_altera_sdc_file(section,config,board_support_dir,board,quartus_dir,fpga,sodimm,sed_progs):

  directive = 'quartus-sdc-file'
  if fpga != '':
    directive += '-' + fpga
  # create the .sdc file input to quartus synthesis
  sdc_file = resolve(section,directive,config)
  if not sdc_file:
    sdc_file = resolve(section,'quartus-sdc-file',config)
  if sdc_file:
    add_sodimm_to_sdc = False
  else:
    partition_for = resolve(section,'design-editor-partition-for',config)
    if partition_for in ['dn7002', 'dn7006', 'dn7406']:
      sdc_file = os.path.join(board_support_dir,'d%s_%s_synthesis_constraints' % (board,fpga.upper()))
    else:
      sdc_file = os.path.join(board_support_dir,'%s_%s_synthesis_constraints' % (board,fpga.upper()))
    add_sodimm_to_sdc = True
  sdc_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/fpga_%s.sdc ' % (sdc_file,quartus_dir,fpga)]
  sdc_supplement = resolve(section,'quartus-sdc-supplement-file',config)
  if sdc_supplement:
    sdc_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/fpga_%s.sdc' % (sdc_supplement,quartus_dir,fpga)]
  if sodimm != 'NONE':
    sdc_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_synthesis_constraints > %s/sodimm.sdc' % (board_support_dir,sodimm,quartus_dir)]

  stages = [(('create_sdc_file_fpga_%s' % fpga),sdc_cmds)]

  return stages

# This routine generates all of the stages to build .rbf file from
# Verilog source using the Intel Quartus tool flow.
def build_intel_stages(section,config):
  global JOBS

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()
  board = get_board(build_for)

  # this only applies to FPGA boards with Intel parts
  if not verify_intel_build_board_for(board):
    return []

  stages = []

  # determine the BLUESPECDIR path
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  # the path to the board-specific board support area
  bsup_dir = get_board_support_directory(section,config,bsdir)
  board_support_dir = get_board_support_subdirectory(section,config,bsdir,build_for)

  # determine the quartus synthesis area to use
  quartus_root_dir = resolve(section,'intel-directory',config)

  # setup the paths to search for Verilog files
  vdir = resolve(section,'verilog-directory',config)
  vdir = fix_path(vdir)
  vlog_lib_dirs = make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'verilog-lib-directories',config)))
  vlog_inc_dirs = make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'verilog-inc-directories',config)))
  vlog_dirs = [vdir] + vlog_lib_dirs + vlog_inc_dirs

  bsup_dir_root = get_board_support_directory_root(section,config)
  timing_script = os.path.join(bsup_dir_root,'scripts/intel_timing')

  # determine the SODIMM style to use
  sodimm = 'NONE'
  sodimm = resolve(section,'sodimm-style',config).upper()

  # Cleanup and create directories for quartus synthesized data
  stages += setup_intel_dir(quartus_root_dir,sodimm)

  # Name of top bsv module
  top_module = resolve(section,'top-module',config)
  # top_module = get_board_top_module(section,config,build_for,"0")

  # determine the clock period of the scemi clock and the memory clock (if used)
  scemiperiod  = get_scemi_clock_period(section,config)
  memoryperiod = get_fpga_memory_period(section, config, build_for)

  # this group of commands creates the script file which drives
  # the quartus synthesis.  It starts with a template file and
  # some SODIMM-specific constraint files in the board support area
  # and combines these -- modified by some substitutions via sed --
  # into the final .qsf file.
  sed_progs = ['s+__VDIR__+%s+g' % vdir,
               's+__BLUESPECDIR__+%s+g' % bsdir,
               's+__BOARD__+%s+g' % board,
               's+__TOP_MODULE__+%s+g' % top_module,
               's+__SODIMM_STYLE__+%s_SODIMM_STYLE+g' % sodimm,
               's+__SCEMI_CLOCK_PERIOD__+%1.3f+g' % scemiperiod,
               's+__SCEMI_CLOCK_PERIOD2__+%1.3f+g' % (scemiperiod/2),
               's+__SCEMI_CLOCK_DBL_PERIOD__+%1.3f+g' % (scemiperiod*2),
               's+__MEM_CLOCK_PERIOD__+%1.3f+g' % memoryperiod,
               's+__MEM_CLOCK_PERIOD2__+%1.3f+g' % (memoryperiod/2)]

  syn_stages = []

  # Create script file
  stages += create_intel_tcl_file(section,config,board_support_dir,
                                  board,quartus_root_dir,"XXX",sodimm,sed_progs,vlog_dirs)

  # these stages run the quartus commands to synthesize all of the way
  # to a final .rbf file
  syn_stages += [('quartus_sh',\
                  ['cd %s && quartus_sh -t quartus_script.tcl' % (quartus_root_dir)])]

  stages += syn_stages

  return stages

def create_intel_tcl_file(section,config,board_support_dir,board,quartus_dir,fpga,sodimm,sed_progs,vlog_dirs):
  tcl_file = resolve(section,'quartus-tcl-file',config)
  if tcl_file:
    user_specified = True
  else:
    user_specified = False
    tcl_file = os.path.join(board_support_dir,'quartus_script_template.tcl')
  tcl_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/quartus_script.tcl ' % (tcl_file,quartus_dir)]
  tcl_supplement = resolve(section,'quartus-tcl-supplement-file',config)
  if tcl_supplement:
    tcl_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/quartus_script.tcl' % (tcl_supplement,quartus_dir)]
  if not user_specified:
    sdc_file = resolve(section,'quartus-sdc-file',config)
    if not sdc_file:
      sdc_file = os.path.join(board_support_dir,'quartus_sdc_template.sdc')
    tcl_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/quartus.sdc ' % (sdc_file,quartus_dir)]
    sdc_supplement = resolve(section,'quartus-sdc-supplement-file',config)
    if sdc_supplement:
      tcl_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/quartus.sdc' % (sdc_supplement,quartus_dir)]

    for d in vlog_dirs:
      tcl_cmds += ['echo "set_global_assignment -name SEARCH_PATH %s" >> %s/quartus_script.tcl' % (d, quartus_dir)]
    tcl_cmds += ['echo "set_global_assignment -name SDC_FILE quartus.sdc" >> %s/quartus_script.tcl' % (quartus_dir)]
    tcl_cmds += ['echo "execute_flow -compile" >> %s/quartus_script.tcl' % (quartus_dir)]
    tcl_cmds += ['echo "project_close" >> %s/quartus_script.tcl' % (quartus_dir)]

  stages = [('create_tcl_file',tcl_cmds)]
  return stages


def import_from(dir,files):
  return [ '--import ' + os.path.join(dir,f) for f in files ]

def ngc_from(dir,files):
  return [ '--ngcfile ' + os.path.join(dir,f) for f in files ]

def exclude_from(files):
  return [ '--exclude ' + f for f in files ]

def dcp_from(dir,files):
  return [ '--dcpfile ' + os.path.join(dir,f) for f in files ]

def build_xilinx_stages(section,config):

  # identify build platform (bluesim, 7002, etc.)
  build_for = resolve(section,'build-for',config).lower()
  board = get_board(build_for)

  # this only applies to FPGA boards with Xilinx parts
  if not verify_xilinx_build_board_for(board):
    return []

  stages = []

  # determine the SODIMM style to use
  sodimm = resolve(section,'sodimm-style',config).upper()

  # determine if planAhead is the target or ISE
  plan_ahead = resolve(section,'xilinx-use-planahead',config)

  # determine if readback is included
  readback = doingReadback(section,config)

  # determine if OOC synthesis is requested
  ooc = resolve(section,'xilinx-ooc-synthesis',config)

  # determine the xilinx synthesis area to use
  xilinx_dir = resolve(section,'xilinx-directory',config)
  xilinx_dir = fix_rel_path(section,config,xilinx_dir)

  # make cleanup stages to remove any remains of prior synthesis runs
  cleanup_extensions = ['prj', 'scr', 'cmd', 'srp', 'ngc', 'ngd', 'ncd', 'bit', 'twx', 'ace', 'drc']
  if xilinx_dir != '.':
    stages += [('xilinx_cleanup',[xilinx_dir],\
                                 [])]
  else:
    stages += [('xilinx_cleanup',[],\
                                 ['*.%s' % ext for ext in cleanup_extensions])]

  # a stage to create the xilinx synthesis area
  if xilinx_dir != '.':
    stages += [('make_xilinx_directory', ['mkdir -p %s' % xilinx_dir])]

  # determine the BLUESPECDIR path
  bsdir = os.getenv('BLUESPECDIR')
  if not bsdir:
    print "Warning: BLUESPECDIR environment variable is not set"
    bsdir = '$BLUESPECDIR'
  bsdir = fix_path(bsdir)

  # the path to the board-specific board support area
  bsup_dir_root = get_board_support_directory_root(section,config)
  bsup_dir = get_board_support_directory(section,config,bsdir)
  board_support_dir = get_board_support_subdirectory(section,config,bsdir,build_for)

  # setup the paths to search for Verilog files
  vdir = resolve(section,'verilog-directory',config)
  vdir = fix_rel_path(section,config,vdir)
  vdir = fix_path(vdir)
  vlog_lib_dirs = make_abs(PROJECT_ROOT, map(fix_path, resolve(section,'verilog-lib-directories',config)))
  board_vdirs = [ board_support_dir + '/verilog'
                , board_support_dir + '/verilog/endpoint_blk_plus_v1_14/source'
                , board_support_dir + '/verilog/ddr2_v3_5/user_design/rtl'
                ]
  if verilog_modified(section, config):
    vlog_edithdl_dir = verilog_last(section,config)
    vlog_edithdl_dir = fix_path(vlog_edithdl_dir)
    vlog_dirs = '{ ' + ' '.join([vdir] + vlog_lib_dirs + [vlog_edithdl_dir] + board_vdirs) + ' }'
  else:
    vlog_dirs = '{ ' + ' '.join([vdir] + vlog_lib_dirs + board_vdirs) + ' }'

  # determine the name of the top design module
  top_module = resolve(section,'top-module',config)
  top_file = ""
  if top_module.startswith("'mk-' prefix"):
    top_file = resolve(section,'top-file',config)
    (dirname,filename) = os.path.split(top_file)
    (root,ext) = os.path.splitext(filename)
    top_module = 'mk' + root
  # If the hdleditor flow is active then change the top_module to top_module_EDITED
  if verilog_modified(section, config):
    top_module += verilog_suffix(section, config)

  # If using the hypersilicon B2000T board, setup top fpga info
  if board == 'B2000T' or board == 'RPP2SPLIT':
    top_fpga_file   = get_board_top_fpga_file(section,config,bsdir,board,build_for,'a')
    top_fpga_module = get_board_top_fpga_module(section,config,build_for,'a')
  else:
    top_fpga_file   = top_file
    top_fpga_module = top_module

  # determine the clock period of the scemi clock and the memory clock (if used)
  scemiperiod  = get_scemi_clock_period(section,config)
  memoryperiod = get_fpga_memory_period(section, config, build_for)

  # OOC synthesis does not use constraints, need to be programmed,
  # or use a 'default' wrapper script
  #
  if not ooc:
    # this group of commands creates the .ucf file which drives
    # the xilinx synthesis constraints.  It starts with a template file
    # and some SODIMM-specific constraint files in the board support area
    # and combines these -- modified by some substitutions via sed --
    # into the final .ucf file.
    sed_progs = ['s+__VDIRS__+%s+g' % vlog_dirs,
                 's+__VDIR__+%s+g' % vdir,
                 's+__BLUESPECDIR__+%s+g' % bsdir,
                 's+__BOARD__+%s+g' % board,
                 's+__TOP_FPGA_FILE__+%s+g' % top_fpga_file,
                 's+__TOP_FPGA_MODULE__+%s+g' % top_fpga_module,
                 's+__TOP_MODULE__+%s+g' % top_module,
                 's+__PROJECT_ROOT__+%s+g' % PROJECT_ROOT,
                 's+__SODIMM_STYLE__+%s_SODIMM_STYLE+g' % sodimm,
                 's+__SCEMI_CLOCK_PERIOD__+%1.3f+g' % scemiperiod,
                 's+__SCEMI_CLOCK_PERIOD2__+%1.3f+g' % (scemiperiod/2),
                 's+__SCEMI_CLOCK_DBL_PERIOD__+%1.3f+g' % (scemiperiod*2),
                 's+__MEM_CLOCK_PERIOD__+%1.3f+g' % memoryperiod,
                 's+__MEM_CLOCK_PERIOD2__+%1.3f+g' % (memoryperiod/2),
                 's+__PLANAHEAD_PROJECT_SETUP__+source %s.pa.tcl+g' % top_fpga_module
                 ]

    if verify_vivado_build_board_for(board):
      xdc_file = resolve(section,'xilinx-xdc-file',config)
      if xdc_file:
        add_sodimm_to_xdc = False
      else:
        add_sodimm_to_xdc = True
        xdc_file = os.path.join(board_support_dir,'default.xdc.template')
      xdc_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.xdc' % (xdc_file,xilinx_dir)]
      if sodimm != 'NONE' and add_sodimm_to_xdc:
        xdc_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_synthesis_constraints >> %s/default.xdc' % (board_support_dir,sodimm,xilinx_dir)]
      xdc_supplement = resolve(section,'xilinx-xdc-supplement-file',config)
      if xdc_supplement:
        xdc_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/default.xdc' % (xdc_supplement,xilinx_dir)]
      stages += [('create_xdc_file',xdc_cmds)]
    else:
      ucf_file = resolve(section,'xilinx-ucf-file',config)
      if ucf_file:
        add_sodimm_to_ucf = False
      else:
        add_sodimm_to_ucf = True
        ucf_file = os.path.join(board_support_dir,'default.ucf.template')
      ucf_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.ucf' % (ucf_file,xilinx_dir)]
      if sodimm != 'NONE' and add_sodimm_to_ucf:
        ucf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_synthesis_constraints >> %s/default.ucf' % (board_support_dir,sodimm,xilinx_dir)]
      ucf_supplement = resolve(section,'xilinx-ucf-supplement-file',config)
      if ucf_supplement:
        ucf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/default.ucf' % (ucf_supplement,xilinx_dir)]
      stages += [('create_ucf_file',ucf_cmds)]

      xcf_file = resolve(section,'xilinx-xcf-file',config)
      if xcf_file:
        xcf_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.xcf' % (xcf_file,xilinx_dir)]
      else:
        xcf_file = os.path.join(board_support_dir,'default.xcf.template')
        xcf_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.xcf' % (xcf_file,xilinx_dir)]
        # Add in standard Bluespec xcf commands if not overridden
        xcf_file = os.path.join(bsdir,'Verilog','Bluespec.xcf')
        xcf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/default.xcf' % (xcf_file,xilinx_dir)]

      if sodimm != 'NONE':
        xcf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s/%s_xcf_constraints >> %s/default.xcf' % (board_support_dir,sodimm,xilinx_dir)]
      xcf_supplement = resolve(section,'xilinx-xcf-supplement-file',config)
      if xcf_supplement:
        xcf_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/default.xcf' % (xcf_supplement,xilinx_dir)]
      stages += [('create_xcf_file',xcf_cmds)]

    if os.path.exists(os.path.join(board_support_dir, 'program.cmd.template')):
      program_file = os.path.join(board_support_dir,'program.cmd.template')
      program_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/program.cmd' % (program_file,xilinx_dir)]
      stages += [('create_program_file',program_cmds)]

    if os.path.exists(os.path.join(board_support_dir, 'program.tcl.template')):
      program_file = os.path.join(board_support_dir,'program.tcl.template')
      program_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/program.tcl' % (program_file,xilinx_dir)]
      stages += [('create_program_file_vivado',program_cmds)]

    if os.path.exists(os.path.join(board_support_dir, 'promgen.cmd.template')):
      promgen_file = os.path.join(board_support_dir,'promgen.cmd.template')
      promgen_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/promgen.cmd' % (promgen_file,xilinx_dir)]
      stages += [('create_promgen_file',promgen_cmds)]

    if os.path.exists(os.path.join(board_support_dir, 'flash.cmd.template')):
      flash_file = os.path.join(board_support_dir,'flash.cmd.template')
      flash_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/flash.cmd' % (flash_file,xilinx_dir)]
      stages += [('create_flash_file',flash_cmds)]

    if os.path.exists(os.path.join(board_support_dir, 'tb1.xdc.template')):
      tb1_file = os.path.join(board_support_dir,'tb1.xdc.template')
      tb1_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/tb1.xdc' % (tb1_file,xilinx_dir)]
      stages += [('create_tb1_file',tb1_cmds)]

    if os.path.exists(os.path.join(board_support_dir, 'tb2.xdc.template')):
      tb2_file = os.path.join(board_support_dir,'tb2.xdc.template')
      tb2_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/tb2.xdc' % (tb2_file,xilinx_dir)]
      stages += [('create_tb2_file',tb2_cmds)]

    if plan_ahead:
      patcl_file = resolve(section,'xilinx-patcl-file',config)
      if not patcl_file:
        patcl_file = os.path.join(board_support_dir, 'default.pa.tcl.template')
      patcl_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.pa.tcl' % (patcl_file,xilinx_dir)]
      if readback:
        rtl_tcl_file = os.path.join(board_support_dir, 'default.rtl.tcl.template')
        patcl_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.rtl.tcl' % (rtl_tcl_file,xilinx_dir)]
        icap_fsm_file = os.path.join(bsup_dir, 'xilinx/verilog/icap_fsm.txt')
        patcl_cmds += ['cp %s %s/' % (icap_fsm_file, xilinx_dir)]
        icap_fsm7_file = os.path.join(bsup_dir, 'xilinx/verilog/icap_fsm7.txt')
        patcl_cmds += ['cp %s %s/' % (icap_fsm7_file, xilinx_dir)]
      patcl_supplement = resolve(section,'xilinx-patcl-supplement-file',config)
      if patcl_supplement:
        patcl_cmds += ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s >> %s/default.pa.tcl' % (patcl_supplement,xilinx_dir)]
      stages += [('create_patcl_file',patcl_cmds)]
    else:
      scr_file = resolve(section,'xilinx-scr-file',config)
      if not scr_file:
        scr_file = os.path.join(board_support_dir,'default.scr.template')
        scr_cmds = ['sed ' + ' '.join(['-e "%s"' % p for p in sed_progs]) + ' %s > %s/default.scr' % (scr_file,xilinx_dir)]
        stages += [('create_scr_file',scr_cmds)]

  # determine which Xilinx part is being used for this board
  part    = ''
  device  = ''
  package = ''
  speed   = ''
  family  = ''
  if board == 'ML507':
    part    = 'xc5vfx70tff1136-1'
    device  = 'xc5vfx70t'
    package = 'ff1136'
    speed   = '1'
    family  = 'virtex5'
  elif board == 'XUPV5':
    part    = 'xc5vlx110tff1136-1'
    device  = 'xc5vlx110t'
    package = 'ff1136'
    speed   = '1'
    family  = 'virtex5'
  elif board == 'ML605':
    part    = 'xc6vlx240tff1156-1'
    device  = 'xc6vlx240t'
    package = 'ff1156'
    speed   = '1'
    family  = 'virtex6'
  elif board == 'KC705':
    part    = 'xc7k325t-ffg900-2'
    device  = 'xc7k325t'
    package = 'ffg900'
    speed   = '2'
    family  = 'kintex7'
  elif board == 'VC707':
    part    = 'xc7vx485t-ffg1761-2'
    device  = 'xc7vx485t'
    package = 'ffg1761'
    speed   = '2'
    family  = 'virtex7'
  elif board == 'VC709':
    part    = 'xc7vx690t-ffg1761-2'
    device  = 'xc7vx690t'
    package = 'ffg1761'
    speed   = '2'
    family  = 'virtex7'
  elif board == 'KCU105':
    part    = 'xcku040-ffva1156-2-e'
    device  = 'xcku040'
    package = 'ffva1156'
    speed   = '2'
    family  = 'kintexU'
  elif board == 'VCU108':
    part    = 'xcvu095-ffva2104-2-e'
    device  = 'xcvu095'
    package = 'ffva2104'
    speed   = '2'
    family  = 'virtexU'
  elif board == '10GHXTLL':
    part    = 'xc6vhx565tff1923-2'
    device  = 'xc6vhx565t'
    package = 'ff1923'
    speed   = '2'
    family  = 'virtex6'
  elif board == '10GK7LL':
    part    = 'xc7k410t-ffg676-2'
    device  = 'xc7k410t'
    package = 'ffg676'
    speed   = '2'
    family  = 'kintex7'
  elif board == 'DH2000TQ':
    part    = 'xc7v2000t-1flg1925'
    device  = 'xc7v2000t'
    package = 'flg1925'
    speed   = '1'
    family  = 'virtex7'
  elif board == 'B2000T':
    part    = 'xc7v2000t-1flg1925'
    device  = 'xc7v2000t'
    package = 'flg1925'
    speed   = '1'
    family  = 'virtex7'
  elif board == 'PDV72KR2':
    part    = 'xc7v2000t-1flg1925'
    device  = 'xc7v2000t'
    package = 'flg1925'
    speed   = '1'
    family  = 'virtex7'
  elif board == 'DNV7F2A':
    part    = 'xc7v2000t-1fhg1761'
    device  = 'xc7v2000t'
    package = 'fhg1761'
    speed   = '1'
    family  = 'virtex7'
  elif board == 'RPP2':
    part    = 'xc7v2000t-1fhg1761'
    device  = 'xc7v2000t'
    package = 'fhg1761'
    speed   = '1'
    family  = 'virtex7'
  elif board == 'RPP2SPLIT':
    part    = 'xc7v2000t-1fhg1761'
    device  = 'xc7v2000t'
    package = 'fhg1761'
    speed   = '1'
    family  = 'virtex7'
  elif board == 'DNVUF4A':
    part    = 'xcvu440-flga2892-1-c'
    device  = 'xcvu440'
    package = 'flga2892'
    speed   = '1'
    family  = 'virtexU'
  elif board == 'KLVUF4A':
    part    = 'xcvu440-flga2892-2-e'
    device  = 'xcvu440'
    package = 'flga2892'
    speed   = '1'
    family  = 'virtexU'

  # the prepare_project_files stage uses the prepare_xst_project
  # script to create the .prj and .scr files used as input to the xst
  # synthesis tool.
  if plan_ahead:
    prep_script = os.path.join(bsup_dir_root,'scripts/prepare_pa_project')
  else:
    prep_script = os.path.join(bsup_dir_root,'scripts/prepare_xst_project')
  prep_options = []
  prep_options += ['--project-root', PROJECT_ROOT]
  bdir = resolve(section,'binary-directory',config)
  bdir = fix_rel_path(section,config,bdir)
  if bdir != '.':
    prep_options += ['--bdir',bdir]
  vdir = resolve(section,'verilog-directory',config)
  vdir = fix_rel_path(section,config,vdir)
  if vdir != '.':
    prep_options += ['--vdir',vdir]
  if verilog_modified(section, config):
    if vlog_edithdl_dir != '.':
      prep_options += ['--edir',vlog_edithdl_dir]
  if xilinx_dir != '.':
    prep_options += ['--outdir',xilinx_dir]
  scemi_type = resolve(section,'scemi-type',config)

  # Compute the BSC -p argument to pass to the prep script
  # XXX This is duplicated in two other places
  src_dirs = []
  src_dir = resolve(section,'bsv-source-directory',config)
  if src_dir != '.':
    src_dirs += [src_dir]
  gsrc_dir = resolve(section,'bsv-generated-source-directory',config)
  gsrc_dir = fix_rel_path(section,config,gsrc_dir);
  if gsrc_dir != '.':
    src_dirs += [gsrc_dir]
  src_dirs += resolve(section,'bsv-source-directories',config)
  src_dirs += resolve(section,'verilog-lib-directories',config)
  if len(src_dirs) != 0:
    prep_options += ['--bpath', ':'.join(src_dirs) + ':+']

  # Get the pre-compile status
  precompiled = resolve(section,'xilinx-use-precompiled',config)

  if board == 'ML605' and precompiled:
    prep_options += ['--vlib','%s/bluenoc/xilinx/ML605/precompile' % bsup_dir_root]

  for d in make_abs(PROJECT_ROOT, resolve(section,'verilog-lib-directories',config)):
    prep_options += ['--vlib',d]

  for d in make_abs(PROJECT_ROOT, resolve(section,'verilog-inc-directories',config)):
    prep_options += ['--idir',d]

  for d in resolve(section,'verilog-define',config):
    prep_options += ['--define',d]
  prep_options += ['--define', 'BSV_TOP=%s' % top_module]
  if sodimm == 'DDR3' and (board == 'B2000T' or board == 'RPP2SPLIT'):
    prep_options += ['--define', 'DDR3_SODIMM_STYLE']

  if board == 'B2000T' or board == 'RPP2SPLIT':
    prep_options += ['--top-fpga-file', top_fpga_file]
    prep_options += ['--top-fpga-module', top_fpga_module]

  create_logic = False;
  bitgen_opts  = resolve(section,'xilinx-bitgen-options',config)
  for o in resolve(section,'xilinx-bitgen-options',config):
    if o == '-l':
      create_logic = True;
      prep_options += [o]

  if readback:
    if not create_logic:
      prep_options += ['-l']
    prep_options += ['--readback']
  else:
    if resolve(section,'xilinx-preserve-signals',config):
      prep_options += ['--preserve']

  synth_strategy = get_xilinx_synth_strategy(section, config, board)
  prep_options += ['--synth-strategy','"%s"' % synth_strategy]

  impl_strategy = get_xilinx_impl_strategy(section, config, board)
  prep_options += ['--impl-strategy','"%s"' % impl_strategy]

  pd_socket = resolve(section,'prodesign-pcie-socket',config)
  prep_options += ['--prodesign-socket', '%s' % pd_socket]

  imported_vlog = make_abs(PROJECT_ROOT,resolve(section,'imported-verilog-files',config))
  prep_options += import_from("",imported_vlog)

  imported_svlog = make_abs(PROJECT_ROOT,resolve(section,'imported-systemverilog-files',config))
  prep_options += import_from("",imported_svlog)

  imported_vhdlog = make_abs(PROJECT_ROOT,resolve(section,'imported-vhdl-files',config))
  prep_options += import_from("",imported_vhdlog)

  # Get the infrastructure style
  style = resolve(section,'scemi-infrastructure-style',config)

  if scemi_type == 'PCIE_VIRTEX5':
    if style == 'BLUENOC':
      ip_dir = os.path.join(board_support_dir, 'verilog/endpoint_blk_plus_v1_14/source')
    else:
      ip_dir = os.path.join(board_support_dir, 'verilog/integrated_blk_v1_7/source')
    prep_options += import_from(ip_dir,[ 'endpoint_blk_plus_v1_14.v'
                                       , 'bram_common.v'
                                       , 'cfg_wr_enable.v'
                                       , 'cmm_decoder.v'
                                       , 'cmm_errman_cnt_en.v'
                                       , 'cmm_errman_cnt_nfl_en.v'
                                       , 'cmm_errman_cor.v'
                                       , 'cmm_errman_cpl.v'
                                       , 'cmm_errman_ftl.v'
                                       , 'cmm_errman_nfl.v'
                                       , 'cmm_errman_ram4x26.v'
                                       , 'cmm_errman_ram8x26.v'
                                       , 'cmm_intr.v'
                                       , 'extend_clk.v'
                                       , 'pcie_blk_cf_arb.v'
                                       , 'pcie_blk_cf_err.v'
                                       , 'pcie_blk_cf_mgmt.v'
                                       , 'pcie_blk_cf_pwr.v'
                                       , 'pcie_blk_cf.v'
                                       , 'pcie_blk_if.v'
                                       , 'pcie_blk_ll_arb.v'
                                       , 'pcie_blk_ll_credit.v'
                                       , 'pcie_blk_ll_oqbqfifo.v'
                                       , 'pcie_blk_ll_tx_arb.v'
                                       , 'pcie_blk_ll_tx.v'
                                       , 'pcie_blk_ll.v'
                                       , 'pcie_blk_plus_ll_rx.v'
                                       , 'pcie_blk_plus_ll_tx.v'
                                       , 'pcie_clocking.v'
                                       , 'pcie_ep.v'
                                       , 'pcie_gt_wrapper_top.v'
                                       , 'pcie_gt_wrapper.v'
                                       , 'pcie_gtx_wrapper.v'
                                       , 'pcie_mim_wrapper.v'
                                       , 'pcie_reset_logic.v'
                                       , 'pcie_soft_int.v'
                                       , 'pcie_top.v'
                                       , 'prod_fixes.v'
                                       , 'sync_fifo.v'
                                       , 'tlm_rx_data_snk_bar.v'
                                       , 'tlm_rx_data_snk_mal.v'
                                       , 'tlm_rx_data_snk_pwr_mgmt.v'
                                       , 'tlm_rx_data_snk.v'
                                       , 'tx_sync_gtp.v'
                                       , 'tx_sync_gtx.v'
                                       , 'use_newinterrupt.v'
                                       ])
  if scemi_type == 'PCIE_VIRTEX6':
    if style == 'BLUENOC' and precompiled:
      ip_dir = os.path.join(board_support_dir, 'precompile')
      prep_options += ngc_from(ip_dir, ['xilinx_v6_pcie_wrapper.ngc', 'mkPCIEtoBNoC_4.ngc'])
      prep_options += import_from(ip_dir, ['xilinx_v6_pcie_wrapper.v', 'mkPCIEtoBNoC_4.v'])
      prep_options += exclude_from([  'xilinx_v6_pcie_wrapper.v'
                                    , 'mkPCIEtoBNoC_4.v'
                                    , 'mkTLPArbiter.v'
                                    , 'mkTLPDispatcher.v'
                                    ])
    else:
      if style == 'BLUENOC':
        ip_dir = os.path.join(board_support_dir, 'verilog/v6_pcie_v1_7/source')
      else:
        ip_dir = os.path.join(board_support_dir, 'verilog/integrated_blk_v1_7/source')

      prep_options += import_from(ip_dir, [ 'gtx_drp_chanalign_fix_3752_v6.v'
                                          , 'gtx_rx_valid_filter_v6.v'
                                          , 'gtx_tx_sync_rate_v6.v'
                                          , 'gtx_wrapper_v6.v'
                                          , 'pcie_2_0_v6.v'
                                          , 'pcie_brams_v6.v'
                                          , 'pcie_bram_top_v6.v'
                                          , 'pcie_bram_v6.v'
                                          , 'pcie_clocking_v6.v'
                                          , 'pcie_endpoint.v'
                                          , 'pcie_gtx_v6.v'
                                          , 'pcie_pipe_lane_v6.v'
                                          , 'pcie_pipe_misc_v6.v'
                                          , 'pcie_pipe_v6.v'
                                          , 'pcie_reset_delay_v6.v'
                                          , 'pcie_upconfig_fix_3451_v6.v'
                                          ])
      ip_dir = os.path.join(bsdir, 'BSVSource/Xilinx')
      prep_options += import_from(ip_dir, [ 'xilinx_v6_pcie_wrapper.v'
                                            ])

  if board == '10GK7LL':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])

    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v1_10/source')
    prep_options += import_from(ip_dir, [ 'xilinx_k7_pcie_wrapper.v'
                                        , 'pcie_7x_v1_10.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx_null_gen.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx_pipeline.v'
                                        , 'pcie_7x_v1_10_axi_basic_top.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx_pipeline.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx_thrtl_ctl.v'
                                        , 'pcie_7x_v1_10_gt_rx_valid_filter_7x.v'
                                        , 'pcie_7x_v1_10_gt_top.v'
                                        , 'pcie_7x_v1_10_gt_wrapper.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_drp.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_rate.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_reset.v'
                                        , 'pcie_7x_v1_10_pcie_7x.v'
                                        , 'pcie_7x_v1_10_pcie_bram_7x.v'
                                        , 'pcie_7x_v1_10_pcie_bram_top_7x.v'
                                        , 'pcie_7x_v1_10_pcie_brams_7x.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_lane.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_misc.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_pipeline.v'
                                        , 'pcie_7x_v1_10_pcie_top.v'
                                        , 'pcie_7x_v1_10_pipe_clock.v'
                                        , 'pcie_7x_v1_10_pipe_drp.v'
                                        , 'pcie_7x_v1_10_pipe_eq.v'
                                        , 'pcie_7x_v1_10_pipe_rate.v'
                                        , 'pcie_7x_v1_10_pipe_reset.v'
                                        , 'pcie_7x_v1_10_pipe_sync.v'
                                        , 'pcie_7x_v1_10_pipe_user.v'
                                        , 'pcie_7x_v1_10_pipe_wrapper.v'
                                        , 'pcie_7x_v1_10_qpll_drp.v'
                                        , 'pcie_7x_v1_10_qpll_reset.v'
                                        , 'pcie_7x_v1_10_qpll_wrapper.v'
                                        , 'pcie_7x_v1_10_rxeq_scan.v'
                                        ])

  if board == 'KC705':
    # use the pre-synthesized PCIe-to-BNoC bridge, to avoid Vivado bug
    ip_dir = os.path.join(board_support_dir, 'verilog')
    prep_options += import_from(ip_dir, [ 'mkPCIEtoBNoCFull_4.v' ])
    # if style == 'BLUENOC' and precompiled:
    #   ip_dir = os.path.join(board_support_dir, 'precompile')
    #   prep_options += dcp_from(ip_dir, ['mkPCIEtoBNoC_4.dcp', 'xilinx_k7_pcie_wrapper.dcp'])
    #   prep_options += import_from(ip_dir, ['mkPCIEtoBNoC_4.v', 'xilinx_k7_pcie_wrapper.v'])
    #   prep_options += exclude_from([  'xilinx_k7_pcie_wrapper.v'
    #                                 , 'mkPCIEtoBNoC_4.v'
    #                                 , 'mkTLPArbiter.v'
    #                                 , 'mkTLPDispatcher.v'
    #                                 ])
    # else:
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v1_10/source')
    prep_options += import_from(ip_dir, [ 'xilinx_k7_pcie_wrapper.v'
                                        , 'pcie_7x_v1_10.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx_null_gen.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx_pipeline.v'
                                        , 'pcie_7x_v1_10_axi_basic_top.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx_pipeline.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx_thrtl_ctl.v'
                                        , 'pcie_7x_v1_10_gt_rx_valid_filter_7x.v'
                                        , 'pcie_7x_v1_10_gt_top.v'
                                        , 'pcie_7x_v1_10_gt_wrapper.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_drp.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_rate.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_reset.v'
                                        , 'pcie_7x_v1_10_pcie_7x.v'
                                        , 'pcie_7x_v1_10_pcie_bram_7x.v'
                                        , 'pcie_7x_v1_10_pcie_bram_top_7x.v'
                                        , 'pcie_7x_v1_10_pcie_brams_7x.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_lane.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_misc.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_pipeline.v'
                                        , 'pcie_7x_v1_10_pcie_top.v'
                                        , 'pcie_7x_v1_10_pipe_clock.v'
                                        , 'pcie_7x_v1_10_pipe_drp.v'
                                        , 'pcie_7x_v1_10_pipe_eq.v'
                                        , 'pcie_7x_v1_10_pipe_rate.v'
                                        , 'pcie_7x_v1_10_pipe_reset.v'
                                        , 'pcie_7x_v1_10_pipe_sync.v'
                                        , 'pcie_7x_v1_10_pipe_user.v'
                                        , 'pcie_7x_v1_10_pipe_wrapper.v'
                                        , 'pcie_7x_v1_10_qpll_drp.v'
                                        , 'pcie_7x_v1_10_qpll_reset.v'
                                        , 'pcie_7x_v1_10_qpll_wrapper.v'
                                        , 'pcie_7x_v1_10_rxeq_scan.v'
                                        ])

  if board == 'VC707':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v1_10/source')
    prep_options += import_from(ip_dir, [ 'xilinx_v7_pcie_wrapper.v'
                                        , 'pcie_7x_v1_10.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx_null_gen.v'
                                        , 'pcie_7x_v1_10_axi_basic_rx_pipeline.v'
                                        , 'pcie_7x_v1_10_axi_basic_top.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx_pipeline.v'
                                        , 'pcie_7x_v1_10_axi_basic_tx_thrtl_ctl.v'
                                        , 'pcie_7x_v1_10_gt_rx_valid_filter_7x.v'
                                        , 'pcie_7x_v1_10_gt_top.v'
                                        , 'pcie_7x_v1_10_gt_wrapper.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_rate.v'
                                        , 'pcie_7x_v1_10_gtp_pipe_reset.v'
                                        , 'pcie_7x_v1_10_pcie_7x.v'
                                        , 'pcie_7x_v1_10_pcie_bram_7x.v'
                                        , 'pcie_7x_v1_10_pcie_bram_top_7x.v'
                                        , 'pcie_7x_v1_10_pcie_brams_7x.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_lane.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_misc.v'
                                        , 'pcie_7x_v1_10_pcie_pipe_pipeline.v'
                                        , 'pcie_7x_v1_10_pcie_top.v'
                                        , 'pcie_7x_v1_10_pipe_clock.v'
                                        , 'pcie_7x_v1_10_pipe_drp.v'
                                        , 'pcie_7x_v1_10_pipe_eq.v'
                                        , 'pcie_7x_v1_10_pipe_rate.v'
                                        , 'pcie_7x_v1_10_pipe_reset.v'
                                        , 'pcie_7x_v1_10_pipe_sync.v'
                                        , 'pcie_7x_v1_10_pipe_user.v'
                                        , 'pcie_7x_v1_10_pipe_wrapper.v'
                                        , 'pcie_7x_v1_10_qpll_drp.v'
                                        , 'pcie_7x_v1_10_qpll_reset.v'
                                        , 'pcie_7x_v1_10_qpll_wrapper.v'
                                        , 'pcie_7x_v1_10_rxeq_scan.v'
                                        ])
  if board == 'VC709':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_7x_v3_0/source')
    prep_options += import_from(ip_dir, [ 'pcie3_7x_v3_0_gt_common.v'
                                        , 'pcie3_7x_v3_0_gt_top.v'
                                        , 'pcie3_7x_v3_0_gt_wrapper.v'
                                        , 'pcie3_7x_v3_0_pcie_3_0_7vx.v'
                                        , 'pcie3_7x_v3_0_pcie_7vx.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx_16k.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx_8k.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx_cpl.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx_rep.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx_rep_8k.v'
                                        , 'pcie3_7x_v3_0_pcie_bram_7vx_req.v'
                                        , 'pcie3_7x_v3_0_pcie_force_adapt.v'
                                        , 'pcie3_7x_v3_0_pcie_init_ctrl_7vx.v'
                                        , 'pcie3_7x_v3_0_pcie_pipe_lane.v'
                                        , 'pcie3_7x_v3_0_pcie_pipe_misc.v'
                                        , 'pcie3_7x_v3_0_pcie_pipe_pipeline.v'
                                        , 'pcie3_7x_v3_0_pcie_tlp_tph_tbl_7vx.v'
                                        , 'pcie3_7x_v3_0_pcie_top.v'
                                        , 'pcie3_7x_v3_0_pipe_clock.v'
                                        , 'pcie3_7x_v3_0_pipe_drp.v'
                                        , 'pcie3_7x_v3_0_pipe_eq.v'
                                        , 'pcie3_7x_v3_0_pipe_rate.v'
                                        , 'pcie3_7x_v3_0_pipe_reset.v'
                                        , 'pcie3_7x_v3_0_pipe_sync.v'
                                        , 'pcie3_7x_v3_0_pipe_user.v'
                                        , 'pcie3_7x_v3_0_pipe_wrapper.v'
                                        , 'pcie3_7x_v3_0_qpll_drp.v'
                                        , 'pcie3_7x_v3_0_qpll_reset.v'
                                        , 'pcie3_7x_v3_0_qpll_wrapper.v'
                                        , 'pcie3_7x_v3_0_rxeq_scan.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_7x_v3_0/synth')
    prep_options += import_from(ip_dir, [ 'xilinx_v7_pcie3_wrapper.v'
                                        , 'pcie3_7x_v3_0.v'
                                        ])

  if board == 'VCU108':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_2/source')
    prep_options += import_from(ip_dir, [ 'pcie3_ultrascale_v4_2_bram_16k.v'
                                        , 'pcie3_ultrascale_v4_2_bram_8k.v'
                                        , 'pcie3_ultrascale_v4_2_bram_cpl.v'
                                        , 'pcie3_ultrascale_v4_2_bram_rep_8k.v'
                                        , 'pcie3_ultrascale_v4_2_bram_rep.v'
                                        , 'pcie3_ultrascale_v4_2_bram_req_8k.v'
                                        , 'pcie3_ultrascale_v4_2_bram_req.v'
                                        , 'pcie3_ultrascale_v4_2_bram.v'
                                        , 'pcie3_ultrascale_v4_2_gt_channel.v'
                                        , 'pcie3_ultrascale_v4_2_gt_common.v'
                                        , 'pcie3_ultrascale_v4_2_gtwizard_top.v'
                                        , 'pcie3_ultrascale_v4_2_init_ctrl.v'
                                        , 'pcie3_ultrascale_v4_2_ltr_decode.v'
                                        , 'pcie3_ultrascale_v4_2_pcie3_uscale_core_top.v'
                                        , 'pcie3_ultrascale_v4_2_pcie3_uscale_top.v'
                                        , 'pcie3_ultrascale_v4_2_pcie3_uscale_wrapper.v'
                                        , 'pcie3_ultrascale_v4_2_phy_clk.v'
                                        , 'pcie3_ultrascale_v4_2_phy_rst.v'
                                        , 'pcie3_ultrascale_v4_2_phy_rxeq.v'
                                        , 'pcie3_ultrascale_v4_2_phy_sync_cell.v'
                                        , 'pcie3_ultrascale_v4_2_phy_sync.v'
                                        , 'pcie3_ultrascale_v4_2_phy_txeq.v'
                                        , 'pcie3_ultrascale_v4_2_phy_wrapper.v'
                                        , 'pcie3_ultrascale_v4_2_pipe_lane.v'
                                        , 'pcie3_ultrascale_v4_2_pipe_misc.v'
                                        , 'pcie3_ultrascale_v4_2_pipe_pipeline.v'
                                        , 'pcie3_ultrascale_v4_2_rxcdrhold.v'
                                        , 'pcie3_ultrascale_v4_2_sys_clk_gen.v'
                                        , 'pcie3_ultrascale_v4_2_tph_tbl.v'
                                        ])

  if board == 'KCU105':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_V4_2/source')
    prep_options += import_from(ip_dir, [ 'pcie3_ultrascale_V4_2_bram_16k.v'
                                        , 'pcie3_ultrascale_V4_2_bram_8k.v'
                                        , 'pcie3_ultrascale_V4_2_bram_cpl.v'
                                        , 'pcie3_ultrascale_V4_2_bram_rep_8k.v'
                                        , 'pcie3_ultrascale_V4_2_bram_rep.v'
                                        , 'pcie3_ultrascale_V4_2_bram_req_8k.v'
                                        , 'pcie3_ultrascale_V4_2_bram_req.v'
                                        , 'pcie3_ultrascale_V4_2_bram.v'
                                        , 'pcie3_ultrascale_V4_2_gt_channel.v'
                                        , 'pcie3_ultrascale_V4_2_gt_common.v'
                                        , 'pcie3_ultrascale_V4_2_gtwizard_top.v'
                                        , 'pcie3_ultrascale_V4_2_init_ctrl.v'
                                        , 'pcie3_ultrascale_V4_2_ltr_decode.v'
                                        , 'pcie3_ultrascale_V4_2_pcie3_uscale_core_top.v'
                                        , 'pcie3_ultrascale_V4_2_pcie3_uscale_top.v'
                                        , 'pcie3_ultrascale_V4_2_pcie3_uscale_wrapper.v'
                                        , 'pcie3_ultrascale_V4_2_phy_clk.v'
                                        , 'pcie3_ultrascale_V4_2_phy_rst.v'
                                        , 'pcie3_ultrascale_V4_2_phy_rxeq.v'
                                        , 'pcie3_ultrascale_V4_2_phy_sync_cell.v'
                                        , 'pcie3_ultrascale_V4_2_phy_sync.v'
                                        , 'pcie3_ultrascale_V4_2_phy_txeq.v'
                                        , 'pcie3_ultrascale_V4_2_phy_wrapper.v'
                                        , 'pcie3_ultrascale_V4_2_pipe_lane.v'
                                        , 'pcie3_ultrascale_V4_2_pipe_misc.v'
                                        , 'pcie3_ultrascale_V4_2_pipe_pipeline.v'
                                        , 'pcie3_ultrascale_V4_2_rxcdrhold.v'
                                        , 'pcie3_ultrascale_V4_2_sys_clk_gen.v'
                                        , 'pcie3_ultrascale_V4_2_tph_tbl.v'
                                        ])

    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_V4_2/synth')
    prep_options += import_from(ip_dir, [ 'xilinx_ultrascale_pcie3_wrapper.v'
                                        , 'pcie3_ultrascale_V4_2.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_V4_2/ip_0/synth')
    prep_options += import_from(ip_dir, [ 'gtwizard_ultrascale_v1_5_gthe3_channel.v'
                                        , 'pcie3_ultrascale_V4_2_gt_gthe3_channel_wrapper.v'
                                        , 'pcie3_ultrascale_V4_2_gt_gtwizard_gthe3.v'
                                        , 'pcie3_ultrascale_V4_2_gt_gtwizard_top.v'
                                        , 'pcie3_ultrascale_V4_2_gt.v'
                                        ])

    # use the pre-synthesized PCIe-to-BNoC bridge, to avoid Vivado bug
    ip_dir = os.path.join(board_support_dir, 'verilog')
    prep_options += import_from(ip_dir, [ 'mkPCIE3toBNoCFull_4.v' ])

  if board == 'DH2000TQ':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v2_2/pcie_7x_v2_2/source')
    prep_options += import_from(ip_dir, [ 'pcie_7x_v2_2_axi_basic_rx.v'
                                        , 'pcie_7x_v2_2_axi_basic_rx_null_gen.v'
                                        , 'pcie_7x_v2_2_axi_basic_rx_pipeline.v'
                                        , 'pcie_7x_v2_2_axi_basic_top.v'
                                        , 'pcie_7x_v2_2_axi_basic_tx.v'
                                        , 'pcie_7x_v2_2_axi_basic_tx_pipeline.v'
                                        , 'pcie_7x_v2_2_axi_basic_tx_thrtl_ctl.v'
                                        , 'pcie_7x_v2_2_core_top.v'
                                        , 'pcie_7x_v2_2_gt_common.v'
                                        , 'pcie_7x_v2_2_gt_rx_valid_filter_7x.v'
                                        , 'pcie_7x_v2_2_gt_top.v'
                                        , 'pcie_7x_v2_2_gt_wrapper.v'
                                        , 'pcie_7x_v2_2_gtp_pipe_drp.v'
                                        , 'pcie_7x_v2_2_gtp_pipe_rate.v'
                                        , 'pcie_7x_v2_2_gtp_pipe_reset.v'
                                        , 'pcie_7x_v2_2_pcie_7x.v'
                                        , 'pcie_7x_v2_2_pcie_bram_7x.v'
                                        , 'pcie_7x_v2_2_pcie_bram_top_7x.v'
                                        , 'pcie_7x_v2_2_pcie_brams_7x.v'
                                        , 'pcie_7x_v2_2_pcie_pipe_lane.v'
                                        , 'pcie_7x_v2_2_pcie_pipe_misc.v'
                                        , 'pcie_7x_v2_2_pcie_pipe_pipeline.v'
                                        , 'pcie_7x_v2_2_pcie_top.v'
                                        , 'pcie_7x_v2_2_pipe_drp.v'
                                        , 'pcie_7x_v2_2_pipe_clock.v'
                                        , 'pcie_7x_v2_2_pipe_eq.v'
                                        , 'pcie_7x_v2_2_pipe_rate.v'
                                        , 'pcie_7x_v2_2_pipe_reset.v'
                                        , 'pcie_7x_v2_2_pipe_sync.v'
                                        , 'pcie_7x_v2_2_pipe_user.v'
                                        , 'pcie_7x_v2_2_pipe_wrapper.v'
                                        , 'pcie_7x_v2_2_qpll_drp.v'
                                        , 'pcie_7x_v2_2_qpll_reset.v'
                                        , 'pcie_7x_v2_2_qpll_wrapper.v'
                                        , 'pcie_7x_v2_2_rxeq_scan.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v2_2/synth')
    prep_options += import_from(ip_dir, [ 'xilinx_v7_pcie_wrapper.v'
                                        , 'pcie_7x_v2_2.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v2_2/source')
    prep_options += import_from(ip_dir, [ 'pcie_7x_v2_2_top.v'
                                        ])
  if board == 'B2000T' or board == 'RPP2SPLIT':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = board_support_dir

  if board == 'PDV72KR2' or board == 'DNV7F2A' or board == 'RPP2':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v2_1/pcie_7x_v2_1/source')
    prep_options += import_from(ip_dir, [ 'pcie_7x_v2_1_axi_basic_rx.v'
                                        , 'pcie_7x_v2_1_axi_basic_rx_null_gen.v'
                                        , 'pcie_7x_v2_1_axi_basic_rx_pipeline.v'
                                        , 'pcie_7x_v2_1_axi_basic_top.v'
                                        , 'pcie_7x_v2_1_axi_basic_tx.v'
                                        , 'pcie_7x_v2_1_axi_basic_tx_pipeline.v'
                                        , 'pcie_7x_v2_1_axi_basic_tx_thrtl_ctl.v'
                                        , 'pcie_7x_v2_1_core_top.v'
                                        , 'pcie_7x_v2_1_gt_rx_valid_filter_7x.v'
                                        , 'pcie_7x_v2_1_gt_top.v'
                                        , 'pcie_7x_v2_1_gt_wrapper.v'
                                        , 'pcie_7x_v2_1_gtp_pipe_drp.v'
                                        , 'pcie_7x_v2_1_gtp_pipe_rate.v'
                                        , 'pcie_7x_v2_1_gtp_pipe_reset.v'
                                        , 'pcie_7x_v2_1_pcie_7x.v'
                                        , 'pcie_7x_v2_1_pcie_bram_7x.v'
                                        , 'pcie_7x_v2_1_pcie_bram_top_7x.v'
                                        , 'pcie_7x_v2_1_pcie_brams_7x.v'
                                        , 'pcie_7x_v2_1_pcie_pipe_lane.v'
                                        , 'pcie_7x_v2_1_pcie_pipe_misc.v'
                                        , 'pcie_7x_v2_1_pcie_pipe_pipeline.v'
                                        , 'pcie_7x_v2_1_pcie_top.v'
                                        , 'pcie_7x_v2_1_pipe_clock.v'
                                        , 'pcie_7x_v2_1_pipe_drp.v'
                                        , 'pcie_7x_v2_1_pipe_eq.v'
                                        , 'pcie_7x_v2_1_pipe_rate.v'
                                        , 'pcie_7x_v2_1_pipe_reset.v'
                                        , 'pcie_7x_v2_1_pipe_sync.v'
                                        , 'pcie_7x_v2_1_pipe_user.v'
                                        , 'pcie_7x_v2_1_pipe_wrapper.v'
                                        , 'pcie_7x_v2_1_qpll_drp.v'
                                        , 'pcie_7x_v2_1_qpll_reset.v'
                                        , 'pcie_7x_v2_1_qpll_wrapper.v'
                                        , 'pcie_7x_v2_1_rxeq_scan.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v2_1/synth')
    prep_options += import_from(ip_dir, [ 'xilinx_v7_pcie_wrapper.v'
                                        , 'pcie_7x_v2_1.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie_7x_v2_1/source')
    prep_options += import_from(ip_dir, [ 'pcie_7x_v2_1_top.v'
                                        ])

  if board == 'DNVUF4A':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_1/source')
    prep_options += import_from(ip_dir, [ 'pcie3_ultrascale_v4_1_bram_16k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_8k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_cpl.v'
                                        , 'pcie3_ultrascale_v4_1_bram_rep_8k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_rep.v'
                                        , 'pcie3_ultrascale_v4_1_bram_req_8k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_req.v'
                                        , 'pcie3_ultrascale_v4_1_bram.v'
                                        , 'pcie3_ultrascale_v4_1_gt_channel.v'
                                        , 'pcie3_ultrascale_v4_1_gt_common.v'
                                        , 'pcie3_ultrascale_v4_1_gtwizard_top.v'
                                        , 'pcie3_ultrascale_v4_1_init_ctrl.v'
                                        , 'pcie3_ultrascale_v4_1_pcie3_uscale_core_top.v'
                                        , 'pcie3_ultrascale_v4_1_pcie3_uscale_top.v'
                                        , 'pcie3_ultrascale_v4_1_pcie3_uscale_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1_phy_clk.v'
                                        , 'pcie3_ultrascale_v4_1_phy_rst.v'
                                        , 'pcie3_ultrascale_v4_1_phy_rxeq.v'
                                        , 'pcie3_ultrascale_v4_1_phy_sync_cell.v'
                                        , 'pcie3_ultrascale_v4_1_phy_sync.v'
                                        , 'pcie3_ultrascale_v4_1_phy_txeq.v'
                                        , 'pcie3_ultrascale_v4_1_phy_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1_pipe_lane.v'
                                        , 'pcie3_ultrascale_v4_1_pipe_misc.v'
                                        , 'pcie3_ultrascale_v4_1_pipe_pipeline.v'
                                        , 'pcie3_ultrascale_v4_1_rxcdrhold.v'
#                                        , 'pcie3_ultrascale_v4_1_sys_clk_gen.v'
                                        , 'pcie3_ultrascale_v4_1_tph_tbl.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_1/synth')
    prep_options += import_from(ip_dir, [ 'xilinx_ultrascale_pcie3_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_1/ip_0/synth')
    prep_options += import_from(ip_dir, [ 'gtwizard_ultrascale_v1_5_gthe3_channel.v'
                                        , 'pcie3_ultrascale_v4_1_gt_gthe3_channel_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1_gt_gtwizard_gthe3.v'
                                        , 'pcie3_ultrascale_v4_1_gt_gtwizard_top.v'
                                        , 'pcie3_ultrascale_v4_1_gt.v'
                                        ])
    # use the pre-synthesized PCIe-to-BNoC bridge, to avoid Vivado bug
    ip_dir = os.path.join(board_support_dir, 'verilog')
    prep_options += import_from(ip_dir, [ 'mkPCIE3toBNoCFull_4.v' ])

  if board == 'KLVUF4A':
    if resolve(section, 'xilinx-readback-jtag',config):
      prep_options += import_from(bsdir, ['board_support/bluenoc/xilinx/verilog/internal_jtag.v'])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_1/source')
    prep_options += import_from(ip_dir, [ 'pcie3_ultrascale_v4_1_bram_16k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_8k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_cpl.v'
                                        , 'pcie3_ultrascale_v4_1_bram_rep_8k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_rep.v'
                                        , 'pcie3_ultrascale_v4_1_bram_req_8k.v'
                                        , 'pcie3_ultrascale_v4_1_bram_req.v'
                                        , 'pcie3_ultrascale_v4_1_bram.v'
                                        , 'pcie3_ultrascale_v4_1_gt_channel.v'
                                        , 'pcie3_ultrascale_v4_1_gt_common.v'
                                        , 'pcie3_ultrascale_v4_1_gtwizard_top.v'
                                        , 'pcie3_ultrascale_v4_1_init_ctrl.v'
                                        , 'pcie3_ultrascale_v4_1_pcie3_uscale_core_top.v'
                                        , 'pcie3_ultrascale_v4_1_pcie3_uscale_top.v'
                                        , 'pcie3_ultrascale_v4_1_pcie3_uscale_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1_phy_clk.v'
                                        , 'pcie3_ultrascale_v4_1_phy_rst.v'
                                        , 'pcie3_ultrascale_v4_1_phy_rxeq.v'
                                        , 'pcie3_ultrascale_v4_1_phy_sync_cell.v'
                                        , 'pcie3_ultrascale_v4_1_phy_sync.v'
                                        , 'pcie3_ultrascale_v4_1_phy_txeq.v'
                                        , 'pcie3_ultrascale_v4_1_phy_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1_pipe_lane.v'
                                        , 'pcie3_ultrascale_v4_1_pipe_misc.v'
                                        , 'pcie3_ultrascale_v4_1_pipe_pipeline.v'
                                        , 'pcie3_ultrascale_v4_1_rxcdrhold.v'
#                                        , 'pcie3_ultrascale_v4_1_sys_clk_gen.v'
                                        , 'pcie3_ultrascale_v4_1_tph_tbl.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_1/synth')
    prep_options += import_from(ip_dir, [ 'xilinx_ultrascale_pcie3_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1.v'
                                        ])
    ip_dir = os.path.join(board_support_dir, 'verilog/pcie3_ultrascale_v4_1/ip_0/synth')
    prep_options += import_from(ip_dir, [ 'gtwizard_ultrascale_v1_5_gthe3_channel.v'
                                        , 'pcie3_ultrascale_v4_1_gt_gthe3_channel_wrapper.v'
                                        , 'pcie3_ultrascale_v4_1_gt_gtwizard_gthe3.v'
                                        , 'pcie3_ultrascale_v4_1_gt_gtwizard_top.v'
                                        , 'pcie3_ultrascale_v4_1_gt.v'
                                        ])
    # use the pre-synthesized PCIe-to-BNoC bridge, to avoid Vivado bug
    ip_dir = os.path.join(board_support_dir, 'verilog')
    prep_options += import_from(ip_dir, [ 'mkPCIE3toBNoCFull_4.v' ])

  if board == '10GHXTLL':
    ip_dir = os.path.join(board_support_dir, 'verilog/sfp0')
    prep_options += import_from(ip_dir, [ 'sfp0_example_design.v'
                                        , 'sfp0_block.v'
                                        , 'sfp0_mod.v'
                                        , 'sfp0_management_arbiter.v'
                                        , 'v6gth0_wrapper.v'
                                        , 'v6gth0_wrapper_gth_init.v'
                                        , 'v6gth0_wrapper_gth_reset.v'
                                        , 'v6gth0_wrapper_gth_rx_pcs_cdr_reset.v'
                                        , 'v6gth0_wrapper_gth_tx_pcs_reset.v'
                                        , 'v6gth0_wrapper_quad.v'
                                        , 'v6gth0_wrapper_pulse_synchronizer.v'
                                        ])
    prep_options += ngc_from(ip_dir, [ 'sfp0.ngc' ])

    ip_dir = os.path.join(board_support_dir, 'verilog/sfp1')
    prep_options += import_from(ip_dir, [ 'sfp1_example_design.v'
                                        , 'sfp1_block.v'
                                        , 'sfp1_mod.v'
                                        , 'sfp1_management_arbiter.v'
                                        , 'v6gth1_wrapper.v'
                                        , 'v6gth1_wrapper_gth_init.v'
                                        , 'v6gth1_wrapper_gth_reset.v'
                                        , 'v6gth1_wrapper_gth_rx_pcs_cdr_reset.v'
                                        , 'v6gth1_wrapper_gth_tx_pcs_reset.v'
                                        , 'v6gth1_wrapper_quad.v'
                                        , 'v6gth1_wrapper_pulse_synchronizer.v'
                                        ])
    prep_options += ngc_from(ip_dir, [ 'sfp1.ngc' ])

    ip_dir = os.path.join(board_support_dir, 'verilog/sfp2')
    prep_options += import_from(ip_dir, [ 'sfp2_example_design.v'
                                        , 'sfp2_block.v'
                                        , 'sfp2_mod.v'
                                        , 'sfp2_management_arbiter.v'
                                        , 'v6gth2_wrapper.v'
                                        , 'v6gth2_wrapper_gth_init.v'
                                        , 'v6gth2_wrapper_gth_reset.v'
                                        , 'v6gth2_wrapper_gth_rx_pcs_cdr_reset.v'
                                        , 'v6gth2_wrapper_gth_tx_pcs_reset.v'
                                        , 'v6gth2_wrapper_quad.v'
                                        , 'v6gth2_wrapper_pulse_synchronizer.v'
                                        ])
    prep_options += ngc_from(ip_dir, [ 'sfp2.ngc' ])

  if sodimm == 'DDR2':
    if board == 'ML507' or board == 'XUPV5':
      ip_dir = os.path.join(board_support_dir, 'verilog/ddr2_v3_5/user_design/rtl')
      prep_options += import_from(ip_dir, [ 'ddr2_chipscope.v'
                                          , 'ddr2_ctrl.v'
                                          , 'ddr2_idelay_ctrl.v'
                                          , 'ddr2_infrastructure.v'
                                          , 'ddr2_mem_if_top.v'
                                          , 'ddr2_phy_calib.v'
                                          , 'ddr2_phy_ctl_io.v'
                                          , 'ddr2_phy_dm_iob.v'
                                          , 'ddr2_phy_dq_iob.v'
                                          , 'ddr2_phy_dqs_iob.v'
                                          , 'ddr2_phy_init.v'
                                          , 'ddr2_phy_io.v'
                                          , 'ddr2_phy_top.v'
                                          , 'ddr2_phy_write.v'
                                          , 'ddr2_top.v'
                                          , 'ddr2_usr_addr_fifo.v'
                                          , 'ddr2_usr_rd.v'
                                          , 'ddr2_usr_top.v'
                                          , 'ddr2_usr_wr.v'
                                          , 'ddr2_v3_5.v'
                                          ])
      ip_dir = os.path.join(board_support_dir, 'verilog/ddr2_v3_5')
      prep_options += import_from(ip_dir, [ 'ddr2_wrapper.v'
                                          ])
    if board == 'DH2000TQ':
      ip_dir = os.path.join(board_support_dir, 'verilog/ddr2_v2_0/ddr2_v2_0/user_design/rtl')
      prep_options += import_from(ip_dir, [ 'ddr2_wrapper.v'
                                          , 'ddr2_v2_0.v'
                                          , 'clocking/mig_7series_v2_0_clk_ibuf.v'
                                          , 'clocking/mig_7series_v2_0_infrastructure.v'
                                          , 'clocking/mig_7series_v2_0_iodelay_ctrl.v'
                                          , 'clocking/mig_7series_v2_0_tempmon.v'
                                          , 'controller/mig_7series_v2_0_arb_mux.v'
                                          , 'controller/mig_7series_v2_0_arb_row_col.v'
                                          , 'controller/mig_7series_v2_0_arb_select.v'
                                          , 'controller/mig_7series_v2_0_bank_cntrl.v'
                                          , 'controller/mig_7series_v2_0_bank_common.v'
                                          , 'controller/mig_7series_v2_0_bank_compare.v'
                                          , 'controller/mig_7series_v2_0_bank_mach.v'
                                          , 'controller/mig_7series_v2_0_bank_queue.v'
                                          , 'controller/mig_7series_v2_0_bank_state.v'
                                          , 'controller/mig_7series_v2_0_col_mach.v'
                                          , 'controller/mig_7series_v2_0_mc.v'
                                          , 'controller/mig_7series_v2_0_rank_cntrl.v'
                                          , 'controller/mig_7series_v2_0_rank_common.v'
                                          , 'controller/mig_7series_v2_0_rank_mach.v'
                                          , 'controller/mig_7series_v2_0_round_robin_arb.v'
                                          , 'ecc/mig_7series_v2_0_ecc_buf.v'
                                          , 'ecc/mig_7series_v2_0_ecc_dec_fix.v'
                                          , 'ecc/mig_7series_v2_0_ecc_gen.v'
                                          , 'ecc/mig_7series_v2_0_ecc_merge_enc.v'
                                          , 'ip_top/mig_7series_v2_0_mem_intfc.v'
                                          , 'ip_top/mig_7series_v2_0_memc_ui_top_std.v'
                                          , 'phy/mig_7series_v2_0_ddr_byte_group_io.v'
                                          , 'phy/mig_7series_v2_0_ddr_byte_lane.v'
                                          , 'phy/mig_7series_v2_0_ddr_calib_top.v'
                                          , 'phy/mig_7series_v2_0_ddr_if_post_fifo.v'
                                          , 'phy/mig_7series_v2_0_ddr_mc_phy.v'
                                          , 'phy/mig_7series_v2_0_ddr_mc_phy_wrapper.v'
                                          , 'phy/mig_7series_v2_0_ddr_of_pre_fifo.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_4lanes.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_dqs_found_cal.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_dqs_found_cal_hr.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_init.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_oclkdelay_cal.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_prbs_rdlvl.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_rdlvl.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_tempmon.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_top.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_wrcal.v'
                                          , 'phy/mig_7series_v2_0_ddr_phy_wrlvl_off_delay.v'
                                          , 'phy/mig_7series_v2_0_ddr_prbs_gen.v'
                                          , 'ui/mig_7series_v2_0_ui_cmd.v'
                                          , 'ui/mig_7series_v2_0_ui_rd_data.v'
                                          , 'ui/mig_7series_v2_0_ui_top.v'
                                          , 'ui/mig_7series_v2_0_ui_wr_data.v'
                                          ])

  if sodimm == 'DDR3' and board == '10GK7LL':
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v1_9/user_design/rtl')
    prep_options += import_from(ip_dir, [ 'ddr3_v1_9.v'
                                        , 'ddr3_wrapper.v'
                                        , 'clocking/mig_7series_v1_9_clk_ibuf.v'
                                        , 'clocking/mig_7series_v1_9_infrastructure.v'
                                        , 'clocking/mig_7series_v1_9_iodelay_ctrl.v'
                                        , 'clocking/mig_7series_v1_9_tempmon.v'
                                        , 'controller/mig_7series_v1_9_arb_mux.v'
                                        , 'controller/mig_7series_v1_9_arb_row_col.v'
                                        , 'controller/mig_7series_v1_9_arb_select.v'
                                        , 'controller/mig_7series_v1_9_bank_cntrl.v'
                                        , 'controller/mig_7series_v1_9_bank_common.v'
                                        , 'controller/mig_7series_v1_9_bank_compare.v'
                                        , 'controller/mig_7series_v1_9_bank_mach.v'
                                        , 'controller/mig_7series_v1_9_bank_queue.v'
                                        , 'controller/mig_7series_v1_9_bank_state.v'
                                        , 'controller/mig_7series_v1_9_col_mach.v'
                                        , 'controller/mig_7series_v1_9_mc.v'
                                        , 'controller/mig_7series_v1_9_rank_cntrl.v'
                                        , 'controller/mig_7series_v1_9_rank_common.v'
                                        , 'controller/mig_7series_v1_9_rank_mach.v'
                                        , 'controller/mig_7series_v1_9_round_robin_arb.v'
                                        , 'ecc/mig_7series_v1_9_ecc_buf.v'
                                        , 'ecc/mig_7series_v1_9_ecc_dec_fix.v'
                                        , 'ecc/mig_7series_v1_9_ecc_gen.v'
                                        , 'ecc/mig_7series_v1_9_ecc_merge_enc.v'
                                        , 'ip_top/mig_7series_v1_9_mem_intfc.v'
                                        , 'ip_top/mig_7series_v1_9_memc_ui_top_std.v'
                                        , 'phy/mig_7series_v1_9_ddr_byte_group_io.v'
                                        , 'phy/mig_7series_v1_9_ddr_byte_lane.v'
                                        , 'phy/mig_7series_v1_9_ddr_calib_top.v'
                                        , 'phy/mig_7series_v1_9_ddr_if_post_fifo.v'
                                        , 'phy/mig_7series_v1_9_ddr_mc_phy.v'
                                        , 'phy/mig_7series_v1_9_ddr_mc_phy_wrapper.v'
                                        , 'phy/mig_7series_v1_9_ddr_of_pre_fifo.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_4lanes.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_ck_addr_cmd_delay.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_dqs_found_cal.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_dqs_found_cal_hr.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_init.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_oclkdelay_cal.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_prbs_rdlvl.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_rdlvl.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_tempmon.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_top.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_wrcal.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_wrlvl.v'
                                        , 'phy/mig_7series_v1_9_ddr_prbs_gen.v'
                                        , 'ui/mig_7series_v1_9_ui_cmd.v'
                                        , 'ui/mig_7series_v1_9_ui_rd_data.v'
                                        , 'ui/mig_7series_v1_9_ui_top.v'
                                        , 'ui/mig_7series_v1_9_ui_wr_data.v'
                                        ])

  if sodimm == 'DDR3' and board == 'KC705':
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v1_9/user_design/rtl')
    prep_options += import_from(ip_dir, [ 'ddr3_v1_9.v'
                                        , 'ddr3_wrapper.v'
                                        , 'clocking/mig_7series_v1_9_clk_ibuf.v'
                                        , 'clocking/mig_7series_v1_9_infrastructure.v'
                                        , 'clocking/mig_7series_v1_9_iodelay_ctrl.v'
                                        , 'clocking/mig_7series_v1_9_tempmon.v'
                                        , 'controller/mig_7series_v1_9_arb_mux.v'
                                        , 'controller/mig_7series_v1_9_arb_row_col.v'
                                        , 'controller/mig_7series_v1_9_arb_select.v'
                                        , 'controller/mig_7series_v1_9_bank_cntrl.v'
                                        , 'controller/mig_7series_v1_9_bank_common.v'
                                        , 'controller/mig_7series_v1_9_bank_compare.v'
                                        , 'controller/mig_7series_v1_9_bank_mach.v'
                                        , 'controller/mig_7series_v1_9_bank_queue.v'
                                        , 'controller/mig_7series_v1_9_bank_state.v'
                                        , 'controller/mig_7series_v1_9_col_mach.v'
                                        , 'controller/mig_7series_v1_9_mc.v'
                                        , 'controller/mig_7series_v1_9_rank_cntrl.v'
                                        , 'controller/mig_7series_v1_9_rank_common.v'
                                        , 'controller/mig_7series_v1_9_rank_mach.v'
                                        , 'controller/mig_7series_v1_9_round_robin_arb.v'
                                        , 'ecc/mig_7series_v1_9_ecc_buf.v'
                                        , 'ecc/mig_7series_v1_9_ecc_dec_fix.v'
                                        , 'ecc/mig_7series_v1_9_ecc_gen.v'
                                        , 'ecc/mig_7series_v1_9_ecc_merge_enc.v'
                                        , 'ip_top/mig_7series_v1_9_mem_intfc.v'
                                        , 'ip_top/mig_7series_v1_9_memc_ui_top_std.v'
                                        , 'phy/mig_7series_v1_9_ddr_byte_group_io.v'
                                        , 'phy/mig_7series_v1_9_ddr_byte_lane.v'
                                        , 'phy/mig_7series_v1_9_ddr_calib_top.v'
                                        , 'phy/mig_7series_v1_9_ddr_if_post_fifo.v'
                                        , 'phy/mig_7series_v1_9_ddr_mc_phy.v'
                                        , 'phy/mig_7series_v1_9_ddr_mc_phy_wrapper.v'
                                        , 'phy/mig_7series_v1_9_ddr_of_pre_fifo.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_4lanes.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_ck_addr_cmd_delay.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_dqs_found_cal.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_dqs_found_cal_hr.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_init.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_oclkdelay_cal.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_prbs_rdlvl.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_rdlvl.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_tempmon.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_top.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_wrcal.v'
                                        , 'phy/mig_7series_v1_9_ddr_phy_wrlvl.v'
                                        , 'phy/mig_7series_v1_9_ddr_prbs_gen.v'
                                        , 'ui/mig_7series_v1_9_ui_cmd.v'
                                        , 'ui/mig_7series_v1_9_ui_rd_data.v'
                                        , 'ui/mig_7series_v1_9_ui_top.v'
                                        , 'ui/mig_7series_v1_9_ui_wr_data.v'
                                        ])

  if sodimm == 'DDR4' and board == 'KCU105':
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr4_1')
    prep_options += import_from(ip_dir, [ 'ddr4_1.dcp'
                                        , 'ddr4_1.v'
                                        ])

  if sodimm == 'DDR3' and board == 'VC707':
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v2_0/ddr3_v2_0/user_design/rtl')
    prep_options += import_from(ip_dir, [ 'ddr3_v2_0.v'
                                        , 'ddr3_v2_0_mig.v'
                                        , 'ddr3_wrapper.v'
                                        , 'clocking/mig_7series_v2_0_clk_ibuf.v'
                                        , 'clocking/mig_7series_v2_0_infrastructure.v'
                                        , 'clocking/mig_7series_v2_0_iodelay_ctrl.v'
                                        , 'clocking/mig_7series_v2_0_tempmon.v'
                                        , 'controller/mig_7series_v2_0_arb_mux.v'
                                        , 'controller/mig_7series_v2_0_arb_row_col.v'
                                        , 'controller/mig_7series_v2_0_arb_select.v'
                                        , 'controller/mig_7series_v2_0_bank_cntrl.v'
                                        , 'controller/mig_7series_v2_0_bank_common.v'
                                        , 'controller/mig_7series_v2_0_bank_compare.v'
                                        , 'controller/mig_7series_v2_0_bank_mach.v'
                                        , 'controller/mig_7series_v2_0_bank_queue.v'
                                        , 'controller/mig_7series_v2_0_bank_state.v'
                                        , 'controller/mig_7series_v2_0_col_mach.v'
                                        , 'controller/mig_7series_v2_0_mc.v'
                                        , 'controller/mig_7series_v2_0_rank_cntrl.v'
                                        , 'controller/mig_7series_v2_0_rank_common.v'
                                        , 'controller/mig_7series_v2_0_rank_mach.v'
                                        , 'controller/mig_7series_v2_0_round_robin_arb.v'
                                        , 'ecc/mig_7series_v2_0_ecc_buf.v'
                                        , 'ecc/mig_7series_v2_0_ecc_dec_fix.v'
                                        , 'ecc/mig_7series_v2_0_ecc_gen.v'
                                        , 'ecc/mig_7series_v2_0_ecc_merge_enc.v'
                                        , 'ecc/mig_7series_v2_0_fi_xor.v'
                                        , 'ip_top/mig_7series_v2_0_mem_intfc.v'
                                        , 'ip_top/mig_7series_v2_0_memc_ui_top_std.v'
                                        , 'phy/mig_7series_v2_0_ddr_byte_group_io.v'
                                        , 'phy/mig_7series_v2_0_ddr_byte_lane.v'
                                        , 'phy/mig_7series_v2_0_ddr_calib_top.v'
                                        , 'phy/mig_7series_v2_0_ddr_if_post_fifo.v'
                                        , 'phy/mig_7series_v2_0_ddr_mc_phy.v'
                                        , 'phy/mig_7series_v2_0_ddr_mc_phy_wrapper.v'
                                        , 'phy/mig_7series_v2_0_ddr_of_pre_fifo.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_4lanes.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_ck_addr_cmd_delay.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_dqs_found_cal.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_dqs_found_cal_hr.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_init.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_oclkdelay_cal.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_prbs_rdlvl.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_rdlvl.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_tempmon.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_top.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_wrcal.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_wrlvl.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_wrlvl_off_delay.v'
                                        , 'phy/mig_7series_v2_0_ddr_prbs_gen.v'
                                        , 'ui/mig_7series_v2_0_ui_cmd.v'
                                        , 'ui/mig_7series_v2_0_ui_rd_data.v'
                                        , 'ui/mig_7series_v2_0_ui_top.v'
                                        , 'ui/mig_7series_v2_0_ui_wr_data.v'
                                        ])

  if sodimm == 'DDR3' and board == 'VC709':
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v2_1/ddr3_v2_1/user_design/rtl')
    prep_options += import_from(ip_dir, [ 'ddr3_v2_1.v'
                                        , 'ddr3_v2_1_mig.v'
                                        , 'ddr3_wrapper.v'
                                        , 'clocking/mig_7series_v2_1_clk_ibuf.v'
                                        , 'clocking/mig_7series_v2_1_infrastructure.v'
                                        , 'clocking/mig_7series_v2_1_iodelay_ctrl.v'
                                        , 'clocking/mig_7series_v2_1_tempmon.v'
                                        , 'controller/mig_7series_v2_1_arb_mux.v'
                                        , 'controller/mig_7series_v2_1_arb_row_col.v'
                                        , 'controller/mig_7series_v2_1_arb_select.v'
                                        , 'controller/mig_7series_v2_1_bank_cntrl.v'
                                        , 'controller/mig_7series_v2_1_bank_common.v'
                                        , 'controller/mig_7series_v2_1_bank_compare.v'
                                        , 'controller/mig_7series_v2_1_bank_mach.v'
                                        , 'controller/mig_7series_v2_1_bank_queue.v'
                                        , 'controller/mig_7series_v2_1_bank_state.v'
                                        , 'controller/mig_7series_v2_1_col_mach.v'
                                        , 'controller/mig_7series_v2_1_mc.v'
                                        , 'controller/mig_7series_v2_1_rank_cntrl.v'
                                        , 'controller/mig_7series_v2_1_rank_common.v'
                                        , 'controller/mig_7series_v2_1_rank_mach.v'
                                        , 'controller/mig_7series_v2_1_round_robin_arb.v'
                                        , 'ecc/mig_7series_v2_1_ecc_buf.v'
                                        , 'ecc/mig_7series_v2_1_ecc_dec_fix.v'
                                        , 'ecc/mig_7series_v2_1_ecc_gen.v'
                                        , 'ecc/mig_7series_v2_1_ecc_merge_enc.v'
                                        , 'ecc/mig_7series_v2_1_fi_xor.v'
                                        , 'ip_top/mig_7series_v2_1_mem_intfc.v'
                                        , 'ip_top/mig_7series_v2_1_memc_ui_top_std.v'
                                        , 'phy/mig_7series_v2_1_ddr_byte_group_io.v'
                                        , 'phy/mig_7series_v2_1_ddr_byte_lane.v'
                                        , 'phy/mig_7series_v2_1_ddr_calib_top.v'
                                        , 'phy/mig_7series_v2_1_ddr_if_post_fifo.v'
                                        , 'phy/mig_7series_v2_1_ddr_mc_phy.v'
                                        , 'phy/mig_7series_v2_1_ddr_mc_phy_wrapper.v'
                                        , 'phy/mig_7series_v2_1_ddr_of_pre_fifo.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_4lanes.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_ck_addr_cmd_delay.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_dqs_found_cal.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_dqs_found_cal_hr.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_init.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_oclkdelay_cal.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_prbs_rdlvl.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_rdlvl.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_tempmon.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_top.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_wrcal.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_wrlvl.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_wrlvl_off_delay.v'
                                        , 'phy/mig_7series_v2_1_ddr_prbs_gen.v'
                                        , 'ui/mig_7series_v2_1_ui_cmd.v'
                                        , 'ui/mig_7series_v2_1_ui_rd_data.v'
                                        , 'ui/mig_7series_v2_1_ui_top.v'
                                        , 'ui/mig_7series_v2_1_ui_wr_data.v'
                                        ])

  if sodimm == 'DDR3' and (board == 'DNV7F2A' or board == 'RPP2' or board == 'RPP2SPLIT'):
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v2_0/ddr3_v2_0/user_design/rtl')
    prep_options += import_from(ip_dir, [ 'ddr3_v2_0.v'
                                        , 'ddr3_wrapper.v'
                                        , 'clocking/mig_7series_v2_0_clk_ibuf.v'
                                        , 'clocking/mig_7series_v2_0_infrastructure.v'
                                        , 'clocking/mig_7series_v2_0_iodelay_ctrl.v'
                                        , 'clocking/mig_7series_v2_0_tempmon.v'
                                        , 'controller/mig_7series_v2_0_arb_mux.v'
                                        , 'controller/mig_7series_v2_0_arb_row_col.v'
                                        , 'controller/mig_7series_v2_0_arb_select.v'
                                        , 'controller/mig_7series_v2_0_bank_cntrl.v'
                                        , 'controller/mig_7series_v2_0_bank_common.v'
                                        , 'controller/mig_7series_v2_0_bank_compare.v'
                                        , 'controller/mig_7series_v2_0_bank_mach.v'
                                        , 'controller/mig_7series_v2_0_bank_queue.v'
                                        , 'controller/mig_7series_v2_0_bank_state.v'
                                        , 'controller/mig_7series_v2_0_col_mach.v'
                                        , 'controller/mig_7series_v2_0_mc.v'
                                        , 'controller/mig_7series_v2_0_rank_cntrl.v'
                                        , 'controller/mig_7series_v2_0_rank_common.v'
                                        , 'controller/mig_7series_v2_0_rank_mach.v'
                                        , 'controller/mig_7series_v2_0_round_robin_arb.v'
                                        , 'ecc/mig_7series_v2_0_ecc_buf.v'
                                        , 'ecc/mig_7series_v2_0_ecc_dec_fix.v'
                                        , 'ecc/mig_7series_v2_0_ecc_gen.v'
                                        , 'ecc/mig_7series_v2_0_ecc_merge_enc.v'
                                        , 'ip_top/mig_7series_v2_0_mem_intfc.v'
                                        , 'ip_top/mig_7series_v2_0_memc_ui_top_std.v'
                                        , 'phy/mig_7series_v2_0_ddr_byte_group_io.v'
                                        , 'phy/mig_7series_v2_0_ddr_byte_lane.v'
                                        , 'phy/mig_7series_v2_0_ddr_calib_top.v'
                                        , 'phy/mig_7series_v2_0_ddr_if_post_fifo.v'
                                        , 'phy/mig_7series_v2_0_ddr_mc_phy.v'
                                        , 'phy/mig_7series_v2_0_ddr_mc_phy_wrapper.v'
                                        , 'phy/mig_7series_v2_0_ddr_of_pre_fifo.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_4lanes.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_ck_addr_cmd_delay.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_dqs_found_cal.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_dqs_found_cal_hr.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_init.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_oclkdelay_cal.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_prbs_rdlvl.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_rdlvl.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_tempmon.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_top.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_wrcal.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_wrlvl.v'
                                        , 'phy/mig_7series_v2_0_ddr_phy_wrlvl_off_delay.v'
                                        , 'phy/mig_7series_v2_0_ddr_prbs_gen.v'
                                        , 'ui/mig_7series_v2_0_ui_cmd.v'
                                        , 'ui/mig_7series_v2_0_ui_rd_data.v'
                                        , 'ui/mig_7series_v2_0_ui_top.v'
                                        , 'ui/mig_7series_v2_0_ui_wr_data.v'
                                        ])

  if sodimm == 'DDR3' and board == 'B2000T':
    ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v2_1/ddr3_v2_1/user_design/rtl')
    prep_options += import_from(ip_dir, [ 'ddr3_v2_1.v'
                                        , 'ddr3_v2_1_mig.v'
                                        , 'ddr3_wrapper.v'
                                        , 'clocking/mig_7series_v2_1_clk_ibuf.v'
                                        , 'clocking/mig_7series_v2_1_infrastructure.v'
                                        , 'clocking/mig_7series_v2_1_iodelay_ctrl.v'
                                        , 'clocking/mig_7series_v2_1_tempmon.v'
                                        , 'controller/mig_7series_v2_1_arb_mux.v'
                                        , 'controller/mig_7series_v2_1_arb_row_col.v'
                                        , 'controller/mig_7series_v2_1_arb_select.v'
                                        , 'controller/mig_7series_v2_1_bank_cntrl.v'
                                        , 'controller/mig_7series_v2_1_bank_common.v'
                                        , 'controller/mig_7series_v2_1_bank_compare.v'
                                        , 'controller/mig_7series_v2_1_bank_mach.v'
                                        , 'controller/mig_7series_v2_1_bank_queue.v'
                                        , 'controller/mig_7series_v2_1_bank_state.v'
                                        , 'controller/mig_7series_v2_1_col_mach.v'
                                        , 'controller/mig_7series_v2_1_mc.v'
                                        , 'controller/mig_7series_v2_1_rank_cntrl.v'
                                        , 'controller/mig_7series_v2_1_rank_common.v'
                                        , 'controller/mig_7series_v2_1_rank_mach.v'
                                        , 'controller/mig_7series_v2_1_round_robin_arb.v'
                                        , 'ecc/mig_7series_v2_1_ecc_buf.v'
                                        , 'ecc/mig_7series_v2_1_ecc_dec_fix.v'
                                        , 'ecc/mig_7series_v2_1_ecc_gen.v'
                                        , 'ecc/mig_7series_v2_1_ecc_merge_enc.v'
                                        , 'ecc/mig_7series_v2_1_fi_xor.v'
                                        , 'ip_top/mig_7series_v2_1_mem_intfc.v'
                                        , 'ip_top/mig_7series_v2_1_memc_ui_top_std.v'
                                        , 'phy/mig_7series_v2_1_ddr_byte_group_io.v'
                                        , 'phy/mig_7series_v2_1_ddr_byte_lane.v'
                                        , 'phy/mig_7series_v2_1_ddr_calib_top.v'
                                        , 'phy/mig_7series_v2_1_ddr_if_post_fifo.v'
                                        , 'phy/mig_7series_v2_1_ddr_mc_phy.v'
                                        , 'phy/mig_7series_v2_1_ddr_mc_phy_wrapper.v'
                                        , 'phy/mig_7series_v2_1_ddr_of_pre_fifo.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_4lanes.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_ck_addr_cmd_delay.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_dqs_found_cal.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_dqs_found_cal_hr.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_init.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_oclkdelay_cal.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_prbs_rdlvl.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_rdlvl.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_tempmon.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_top.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_wrcal.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_wrlvl.v'
                                        , 'phy/mig_7series_v2_1_ddr_phy_wrlvl_off_delay.v'
                                        , 'phy/mig_7series_v2_1_ddr_prbs_gen.v'
                                        , 'ui/mig_7series_v2_1_ui_cmd.v'
                                        , 'ui/mig_7series_v2_1_ui_rd_data.v'
                                        , 'ui/mig_7series_v2_1_ui_top.v'
                                        , 'ui/mig_7series_v2_1_ui_wr_data.v'
                                        ])

  if sodimm == 'DDR3' and board == 'ML605':
    if precompiled:
      ip_dir = os.path.join(board_support_dir, 'precompile')
      prep_options += ngc_from(ip_dir, ['ddr3_wrapper.ngc'])
      prep_options += import_from(ip_dir, ['ddr3_wrapper.v'])
      prep_options += exclude_from(['ddr3_wrapper.v'])
    else:
      ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v3_5/user_design/rtl')
      prep_options += import_from(ip_dir, [ 'controller/arb_mux.v'
                                          , 'controller/arb_row_col.v'
                                          , 'controller/arb_select.v'
                                          , 'controller/bank_cntrl.v'
                                          , 'controller/bank_common.v'
                                          , 'controller/bank_compare.v'
                                          , 'controller/bank_mach.v'
                                          , 'controller/bank_queue.v'
                                          , 'controller/bank_state.v'
                                          , 'controller/col_mach.v'
                                          , 'controller/mc.v'
                                          , 'controller/rank_cntrl.v'
                                          , 'controller/rank_common.v'
                                          , 'controller/rank_mach.v'
                                          , 'controller/round_robin_arb.v'
                                          , 'ecc/ecc_buf.v'
                                          , 'ecc/ecc_dec_fix.v'
                                          , 'ecc/ecc_gen.v'
                                          , 'ecc/ecc_merge_enc.v'
                                          , 'ip_top/clk_ibuf.v'
                                          , 'ip_top/ddr2_ddr3_chipscope.v'
                                          , 'ip_top/infrastructure.v'
                                          , 'ip_top/iodelay_ctrl.v'
                                          , 'ip_top/mem_intfc.v'
                                          , 'ip_top/memc_ui_top.v'
                                          , 'ip_top/ddr3_v3_5.v'
                                          , 'phy/circ_buffer.v'
                                          , 'phy/phy_ck_iob.v'
                                          , 'phy/phy_clock_io.v'
                                          , 'phy/phy_control_io.v'
                                          , 'phy/phy_data_io.v'
                                          , 'phy/phy_dly_ctrl.v'
                                          , 'phy/phy_dm_iob.v'
                                          , 'phy/phy_dq_iob.v'
                                          , 'phy/phy_dqs_iob.v'
                                          , 'phy/phy_init.v'
                                          , 'phy/phy_pd.v'
                                          , 'phy/phy_pd_top.v'
                                          , 'phy/phy_rdclk_gen.v'
                                          , 'phy/phy_rdctrl_sync.v'
                                          , 'phy/phy_rddata_sync.v'
                                          , 'phy/phy_rdlvl.v'
                                          , 'phy/phy_read.v'
                                          , 'phy/phy_top.v'
                                          , 'phy/phy_write.v'
                                          , 'phy/phy_wrlvl.v'
                                          , 'phy/rd_bitslip.v'
                                          , 'ui/ui_cmd.v'
                                          , 'ui/ui_rd_data.v'
                                          , 'ui/ui_top.v'
                                          , 'ui/ui_wr_data.v'
                                          ])
      ip_dir = os.path.join(board_support_dir, 'verilog/ddr3_v3_5')
      prep_options += import_from(ip_dir, [ 'ddr3_wrapper.v'
                                            ])

  # determine top module file
  top_vfile = top_module + '.v'
  if verilog_modified(section, config):
    if (top_vfile.startswith('/') == 0):
      # open the top verilog file
      try:
        openfile = file(top_vfile)
      # handle file / IO errors
      except IOError, ioerror:
        top_vfile = vlog_edithdl_dir + '/' + top_vfile
      else:
        if (openfile):
          openfile.close()

  if not (board == 'B2000T' or board == 'RPP2SPLIT'):
    prep_options += ['--vfile', top_vfile]

  # If OOC synthesis is selected, just run the prep script with --ooc
  # Otherwise, run the prep script with no additional flag; and,
  # if readback is requested, then do a second run with the --rtl flag
  #
  ooc = resolve(section,'xilinx-ooc-synthesis',config)
  if ooc:
    prep_options += ['--ooc']
    if readback:
      raise DirectiveError('not supported with xilinx-ooc-synthesis', section, 'xilinx-readback')

  prep_cmd = '%s %s %s %s %s %s %s %s %s' % (prep_script,' '.join(prep_options),top_module,board,part,family,device,package,speed)
  stages += [('prepare_project_files',[prep_cmd])]

  if readback:
    prep_options += ['--rtl']
    rtl_cmd  = '%s %s %s %s %s %s %s %s %s' % (prep_script,' '.join(prep_options),top_module,board,part,family,device,package,speed)
    stages += [('prepare_project_files',[rtl_cmd])]
    # the RTL synthesis will operate on a version of the design which is
    # tweaked to preserve as any many user names as possible; here we add
    # a stage to generate that version of the RTL
    stages += build_elab_source_stages(section,config)

  timing_script = os.path.join(bsup_dir_root,'scripts/xilinx_timing')

  # these stages run the Xilinx tools to synthesize all of the way to
  # a final .ace file
  ucf_file = 'default.ucf'
  xcf_file = 'default.xcf'

  cmds = []

  cmds += ['cd %s' % xilinx_dir]
  if board == '10GHXTLL':
    cmds += ['ln -sf %s .' % os.path.join(board_support_dir, 'verilog/sfp0/sfp0.ngc')]
    cmds += ['ln -sf %s .' % os.path.join(board_support_dir, 'verilog/sfp1/sfp1.ngc')]
    cmds += ['ln -sf %s .' % os.path.join(board_support_dir, 'verilog/sfp2/sfp2.ngc')]

  # commands to create the xrf file
  #   first build the "create_xrf" program, then run it
  #   XXX this duplicates some of "build_cpp_stages"
  cxx_cmd = resolve(section,'c++-compiler',config)
  readback_inc = os.path.join(bsdir, 'Readback')
  readback_lib = os.path.join(readback_inc, cxx_family(bsdir))
  xrf_cxx_incflags = '-I %s' % readback_inc
  xrf_cxx_libflags = '-L%s -lreadback -lz' % readback_lib
  xrf_src = os.path.join(readback_inc, 'create_xrf.cxx')
  xrf_exe = os.path.join(xilinx_dir, 'create_xrf')
  cmd_xrf_compile = '%s -o %s %s %s %s' % (cxx_cmd, xrf_exe, xrf_src, xrf_cxx_incflags, xrf_cxx_libflags)
  if board == 'B2000T':
    xrf_top_module = top_fpga_module;
  else:
    xrf_top_module = top_module;
  cmd_xrf = '%s %s %s' % (xrf_exe, xilinx_dir, xrf_top_module);

  if plan_ahead:
    if verify_vivado_build_board_for(board):
      # Vivado execution stages
      if ooc:
        cmds += ['vivado -mode batch -source %s.ooc.tcl' % top_module]
      else:
        if readback:
          cmds += ['vivado -mode batch -source default.rtl.tcl']
        cmds += ['vivado -mode batch -source default.pa.tcl']
      stages += [('vivado', [' && '.join(cmds)])]
      # Readback XRF stage
      if readback:
        stages += [('create_xrf', [cmd_xrf_compile, cmd_xrf])]
      # Timing check stage
      if not ooc:
        stages += [('timing_check', ['%s vivado %s/%s/%s.runs/impl_1/%s_timing_summary_routed.rpt' % (timing_script,xilinx_dir,top_fpga_module,top_fpga_module,top_fpga_module)])]
    else:
      if readback:
        cmds += ['planAhead -mode batch -source default.rtl.tcl']
      cmds += ['planAhead -mode batch -source default.pa.tcl']
      stages += [('plan_ahead', [' && '.join(cmds)])]
      stages += [('timing_check', ['%s planahead %s/%s/%s.runs/impl_1/%s.twr' % (timing_script,xilinx_dir,top_fpga_module,top_fpga_module,top_fpga_module)])]

  else:
    xst_opts = resolve(section,'xilinx-xst-options',config)
    stages += [('xst_compile',['cd %s && xst -ifn default.scr -ofn %s.srp %s' % (xilinx_dir,top_module,' '.join(xst_opts))])]

    ngdbuild_opts = resolve(section,'xilinx-ngdbuild-options',config)
    cmds += ['ngdbuild %s -uc %s -p %s %s.ngc %s.ngd' % (' '.join(ngdbuild_opts),ucf_file,part,top_module,top_module)]
    stages += [('translate_and_build',[' && '.join(cmds)])]

    map_opts = resolve(section,'xilinx-map-options',config)
    stages += [('map_to_device',['cd %s && map -o %s_map.ncd -p %s %s %s.ngd %s.pcf' % (xilinx_dir,top_module,part,' '.join(map_opts),top_module,top_module)])]

    par_opts = resolve(section,'xilinx-par-options',config)
    stages += [('place_and_route',['cd %s && par %s %s_map.ncd %s.ncd %s.pcf' % (xilinx_dir,' '.join(par_opts),top_module,top_module,top_module)])]

    trce_opts = resolve(section,'xilinx-trce-options',config)
    stages += [('timing_analysis',['cd %s && trce %s -xml %s.twx %s.ncd %s.pcf' % (xilinx_dir,' '.join(trce_opts),top_module,top_module,top_module)])]

    bitgen_file = os.path.join(board_support_dir,'bitgen.ut')
    bitgen_opts = resolve(section,'xilinx-bitgen-options',config)
    stages += [('gen_bit_file',['cd %s && bitgen %s -f %s %s.ncd' % (xilinx_dir,' '.join(bitgen_opts),bitgen_file,top_module)])]

    stages += [('timing_check', ['%s trce %s/%s.twr' % (timing_script,xilinx_dir,top_module)])]

  prog_FPGA = resolve(section,'program-FPGA',config)
  impact_opts = resolve(section,'xilinx-impact-options',config)
  if prog_FPGA:
    cmds = []
    pre_cmd  = resolve(section,'pre-program-command',config)
    post_cmd = resolve(section,'post-program-command',config)
    if pre_cmd:
      cmds += [pre_cmd]
    cmds += ['cd %s && impact %s -batch %s_jtag.cmd' % (xilinx_dir,' '.join(impact_opts),top_module)]
    if post_cmd:
      cmds += [post_cmd]
    stages += [('program_board', cmds)]
  elif not verify_vivado_build_board_for(board):
    stages += [('gen_ace_file',['cd %s && impact %s -batch %s_ace.cmd' % (xilinx_dir,' '.join(impact_opts),top_module)])]

  return stages


# This routine builds stages which run shell commands.  These stages
# are created using the special run-shell* directives.  A directive
# named like run-shell-stage-N specifies the Nth command to run in the
# named stage.
def build_shell_stages(section,config):

  if section not in config:
    return []

  # parse all run-shell* directives in the section
  # the result is a list of ((s,n),cmd) tuples, where s is the stage
  # name, n is the command number, and cmd is the shell command to
  # execute.
  shell_cmds = [ (parse_shell_directive(k),v) for (k,v) in config[section] if k.startswith('run-shell') ]

  # group cmds by stage
  stage_groups = {}
  for ((s,n),cmd) in shell_cmds:
    (status,res) = subst_env_vars(section,cmd)
    if status == 'ok':
      cmd = elim_escapes(res)
    else:
      raise DirectiveError(res, section, "")

    if s in stage_groups:
      stage_groups[s] += [(n,cmd)]
    else:
      stage_groups[s] = [(n,cmd)]

  # find the order to execute stages in (using stage-order if provided)
  stage_order = resolve(section,'stage-order',config)
  if len(stage_order) == 0:
    stage_order = stage_groups.keys()

  # build the stages for the target in order, with commands ordered by number
  stages = []
  for s in stage_order:
    if s in stage_groups:
      cmd_list = stage_groups[s]
      cmd_list.sort()
      cmds = [ cmd for (n,cmd) in cmd_list ]
      stages += [ (s,cmds) ]

  return stages

################################################################################
###
################################################################################

# an easy way to checif an executable exists
def which(program):
    def is_exe(fpath):
        return os.path.exists(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

def verilog_modified (section,config):
  run_design_editor = resolve(section,'run-design-editor',config)
  return run_design_editor

def verilog_last (section,config):
  run_design_editor = resolve(section,'run-design-editor',config)
  if run_design_editor:
    dir = resolve(section,'design-editor-output-directory',config)
    dir = fix_rel_path(section,config,dir)
    return dir
  else:
    dir = resolve(section,'verilog-directory',config)
    dir = fix_rel_path(section,config,dir)
    return dir

def verilog_last2 (section,config):
  dir = resolve(section,'verilog-directory',config)
  dir = fix_rel_path(section,config,dir)
  return dir

def verilog_post_edit (section,config):
  run_design_editor = resolve(section,'run-design-editor',config)
  if (run_design_editor):
    dir = resolve(section,'design-editor-output-directory',config)
    dir = fix_rel_path(section,config,dir)
    return dir
  else:
    dir = resolve(section,'verilog-directory',config)
    dir = fix_rel_path(section,config,dir)
    return dir

def verilog_suffix (section,config):
  run_design_editor = resolve(section,'run-design-editor',config)
  if run_design_editor:
   return "_EDITED"
  else:
   return ""

def partition_verilog_suffix (section,config):
  partition_for = resolve(section,'design-editor-partition-for',config)
  if partition_for:
   return "_EDITED"
  else:
   return ""

def cosim_suffix (section,config):
  return "_COSIM"

# Routine to convert build directives to stage commands This routine
# will go through the project file configuration and generate the full
# set of stage lists for the target.  Because stages can contain
# pre-targets, sub-targets and post-targets, the resulting stage
# structure is a tree.  The stage tree also contains information on
# conditional execution of stages based on skip-target-when and
# skip-target-unless directives.
#
# The output of this routine is a tree in which each node
# consists of a 7-tuple:
#
#   (section,condition,skip_type,pre_tree,stage_list,sub_tree,post_tree)
#
# where the items have the following meaning:
#
#   section      the name of the section for this node
#   condition    a shell command used to determine whether this section
#                should be executed.  can be None for unconditional
#                execution
#   skip_type    when condition is not None, skip_type of True means to
#                skip execution when the condition command returns zero
#                and a skip_type of False means to skip execution when the
#                condition command returns non-zero.
#   pre_tree     a tree of nodes to execute before this node's stage list
#   stage_list   a list of (stage_name,command_list,logdir) tuples to
#                execute as the stages for this node
#   sub_tree     a tree of nodes to execute after this node's stage list
#   post_tree    a tree of nodes to execute after this node's sub_tree
#
def build_stage_list(section,config):
  # build pre-targets
  pre_target_sequence = []
  pre_targets = resolve(section,'pre-targets',config)
  ok_targets = all_targets(config)
  for s in pre_targets:
    if s.lower() not in ok_targets:
      raise BadTarget(s)
    pre_target_sequence += [build_stage_list(s,config)]

  # build sub-targets
  sub_target_sequence = []
  sub_targets = resolve(section,'sub-targets',config)
  for s in sub_targets:
    sub_target_sequence += [build_stage_list(s,config)]

  # build stages for the target itself
  stages = []
  shell_stages = build_shell_stages(section,config)
  if len(shell_stages) == 0:
    if len(sub_targets) == 0:
      stages += build_directory_stages(section,config)
      stages += build_semu_wrapper_stages(section,config)
      stages += build_bsc_compile_stages(section,config)
      stages += build_scemi_link_stages(section,config)
      stages += build_semu_testbench_stages(section,config)
      stages += build_edithdl_stages(section,config,'')
      stages += build_partition_edithdl_stages(section,config)
      stages += build_bsc_link_stages(section,config)
      stages += build_bsc_cosim_link_stages(section,config)
      stages += build_workstation_stages(section,config)
      stages += build_cosim_bspec_stages(section,config)
      stages += build_cpp_stages(section,config)
      stages += build_altera_stages(section,config)
      stages += build_intel_stages(section,config)
      stages += build_xilinx_stages(section,config)

  else:
    stages += shell_stages

  # add log directory information
  logdir = make_abs(PROJECT_ROOT,[resolve(section,'log-directory',config)])[0]
  logdir = fix_rel_path(section,config,logdir)
  logged_stages = []
  for stg in stages:
    if len(stg) == 2:
      logged_stages += [(stg[0],stg[1],logdir)]
    else:
      logged_stages += [(stg[0],stg[1],stg[2],logdir)]

  # build post-targets
  post_target_sequence = []
  post_targets = resolve(section,'post-targets',config)
  ok_targets = all_targets(config)
  for s in post_targets:
    if s.lower() not in ok_targets:
      raise BadTarget(s)
    post_target_sequence += [build_stage_list(s,config)]

  # handle the skip directives, if present
  skip_when = resolve(section,'skip-target-when',config)
  skip_unless = resolve(section,'skip-target-unless',config)
  if skip_when != None and skip_unless != None:
    raise DirectiveError('conflicts with skip-target-unless', section, 'skip-target-when')
  if skip_when:
    return (section,skip_when,True,pre_target_sequence,logged_stages,sub_target_sequence,post_target_sequence)
  elif skip_unless:
    return (section,skip_unless,False,pre_target_sequence,logged_stages,sub_target_sequence,post_target_sequence)
  else:
    return (section,None,None,pre_target_sequence,logged_stages,sub_target_sequence,post_target_sequence)

# Flatten the build sequence into a linear list of stages.  Given the
# tree of nodes produces by build_stage_list, this routine returns a
# list of the nodes flattened by a depth-first walk recursing over the
# tree.  This is only used for informing the user about the stage list
# for each target.  Execution is actually based on the
# filter_build_sequence routine, which handles the conditional stage
# execution, --from and --to.
def flatten_stage_list(build_sequence):
  stages = []
  for (name,cmd,status,pre_tgts,local_stages,sub_tgts,post_tgts) in build_sequence:
    stages += flatten_stage_list(pre_tgts)
    stages += local_stages
    stages += flatten_stage_list(sub_tgts)
    stages += flatten_stage_list(post_tgts)
  return stages

# Take a build sequence and convert it into a flat, conditional run
# list that has been filtered based on the --from and --to options.
# Given the tree of nodes generated from build_stage_list, this
# routine uses a stack-based algorithm to inject test conditions and
# apply the --from and --to constraints.  The result is a linear stage
# sequence called a run list, suitable for execution by the
# execute_build_commands routine.
def filter_build_sequence(opts,build_sequence):

  stack = [ ('seq',seq,'') for seq in build_sequence ]
  skipping = False
  start_matched = None
  end_matched = None
  run_this = (opts.first_stage == 'start')
  run_list = []
  count = 0
  current_condition = None
  last_tgt_path = None
  new_tgt_path = ''
  if opts.first_stage == 'start':
    start_matched = count
  tgt_stack = []
  cond_stack = []
  while len(stack) != 0:
    # handle the top item on the stack
    (key,value,tgt_path) = stack[0]
    if key == 'seq':
      (name,cmd,skip_if_zero,pre_tgts,stages,sub_tgts,post_tgts) = value
      last_tgt_path = new_tgt_path
      if tgt_path == '':
        new_tgt_path = name
      else:
        new_tgt_path = tgt_path + '.' + name
      # mark end of target
      while len(tgt_stack) > 0 and not new_tgt_path.startswith(tgt_stack[0]):
        run_list += [('end-target',cond_stack[0],tgt_stack[0])]
        tgt_stack = tgt_stack[1:]
        cond_stack = cond_stack[1:]
      # test for skipping
      if cmd != None:
        run_list += [('test-condition',new_tgt_path,cmd)]
        current_condition = (new_tgt_path,skip_if_zero)
      else:
        current_condition = None
      # mark start of target
      run_list += [('start-target',current_condition,new_tgt_path)]
      tgt_stack = [new_tgt_path] + tgt_stack
      cond_stack = [current_condition] + cond_stack
      # break up the build sequence
      stack = [('seq',tgt,new_tgt_path) for tgt in pre_tgts]  +\
              [('stage',stg,new_tgt_path) for stg in stages]  +\
              [('seq',tgt,new_tgt_path) for tgt in sub_tgts]  +\
              [('seq',tgt,new_tgt_path) for tgt in post_tgts] +\
              stack[1:]
    elif key == 'stage':
      # only keep stages between --from and --to
      count += 1
      name = value[0]
      stack = stack[1:]
      if name == opts.first_stage:
        start_matched = count
        run_this = True
      if run_this:
        if len(value) == 3:
          cmds   = value[1]
          logdir = value[2]
          if len(cmds) != 0:
            run_list += [('execute',current_condition,name,cmds,logdir)]
        else:
          del_dirs = value[1]
          del_pats = value[2]
          logdir   = value[3]
          run_list += [('cleanup',current_condition,name,del_dirs,del_pats,logdir)]
      if name == opts.last_stage:
        end_matched = count
        run_this = False

  while len(tgt_stack) > 0:
    run_list += [('end-target',cond_stack[0],tgt_stack[0])]
    tgt_stack = tgt_stack[1:]
    cond_stack = cond_stack[1:]

  if opts.last_stage == 'finish':
    end_matched = count + 1

  if start_matched == None:
    raise BadStage(opts.first_stage, 'from')
  if end_matched == None:
    raise BadStage(opts.last_stage, 'to')
  if end_matched < start_matched:
    raise BadStage()

  return run_list

# Execute the selected commands in the run list, with logging, etc
#
# The run list consists of a linear sequence of tuples, where the
# first element of the tuple acts a tag to define the meaning and
# shape of the rest of the tuple.  A typical run list would look
# something like:
#
#   ('start-target', None, 'sequence')
#   ('start-target', None, 'sequence.write_files')
#   ('start-target', None, 'sequence.write_files.step1')
#   ('execute', None, 'pre-wait', ['sleep 2'], 'logs')
#   ('execute', None, 'write', ['echo "Step1" > file1.txt', 'echo "not tested yet" > result.txt'], 'logs')
#   ('execute', None, 'post-wait', ['sleep 2'], 'logs')
#   ('end-target', None, 'sequence.write_files.step1')
#   ('start-target', None, 'sequence.write_files.step2')
#   ('execute', None, 'run-shell', ['echo "Step2" > file2.txt'], 'logs')
#   ('end-target', None, 'sequence.write_files.step2')
#   ('end-target', None, 'sequence.write_files')
#   ('start-target', None, 'sequence.test_files')
#   ('test-condition', 'sequence.test_files.step3', 'test file1.txt -ot file2.txt')
#   ('start-target', ('sequence.test_files.step3', False), 'sequence.test_files.step3')
#   ('execute', ('sequence.test_files.step3', False), 'run-shell', ['echo "file1.txt is older than file2.txt" > result.txt'], 'logs')
#   ('end-target', ('sequence.test_files.step3', False), 'sequence.test_files.step3')
#   ('test-condition', 'sequence.test_files.step4', 'test file1.txt -ot file2.txt')
#   ('start-target', ('sequence.test_files.step4', True), 'sequence.test_files.step4')
#   ('execute', ('sequence.test_files.step4', True), 'run-shell', ['echo "file1.txt is newer than file2.txt" > result.txt'], 'logs')
#   ('end-target', ('sequence.test_files.step4', True), 'sequence.test_files.step4')
#   ('end-target', None, 'sequence.test_files')
#   ('end-target', None, 'sequence')]
#
#
# A 'test-condition' tuple contains a condition-name and a shell command.
# When it is processed, the command is executed and its return value is
# stored as an association with the given condition-name.
#
# All of the other entries can contain condition information, which
# will be None for an uncoditional entry or a 2-tuple of
# (condition-name,run-value) for a conditional entry.  When the
# condition is present, the result of a prior 'test-condition' command
# will be looked up using the condition-name.  If it does not match
# the run-value, then the current entry will be ignored.
#
# A 'start-target' tuple contains condition information and a target
# name.
#
# An 'execute' tuple contains condition information, a stage name, and
# a list of commands.
#
# An 'end-target' tuple contains condition information and a target
# name.
#
# A 'cleanup' tuple contains condition information, a stage name,
# a list of directories and a list of file glob patterns.
def execute_build_commands(opts,run_list):

  condition = {}
  tgt = None
  clean_dirs = set()
  clean_pats = set()

  # process each entry in the run list in order
  for entry in run_list:

    action = entry[0]

    # check if this entry should be skipped
    if action == 'start-target' or action == 'end-target' or action == 'execute' or action == 'cleanup':
      cond = entry[1]
      if cond == None:
        skip = False
      else:
        # look up the result of the condition test by name.
        # if the command exit status doesn't match the run_value
        # then skip this entry.
        (name,run_value) = cond
        skip = (name in condition and condition[name] != run_value)
    else:
      skip = False

    # handle the action
    if action == 'start-target':
      # starting a new target, print a message (either building or skipping)
      tgt = entry[2]
      if skip:
        print "Skipping target %s..." % tgt
      else:
        print "Building target %s..." % tgt
    elif action == 'end-target':
      # end of a target, print a message (either built or skipped)
      name = entry[2]
      if skip:
        print "End of skipped target %s." % name
      else:
        print "Done building target %s." % name
    elif action == 'test-condition':
      # for a test condition, execute the command and record the exit status
      # also print the conditional test and its result for the user
      name = entry[1]
      cmd = entry[2]
      print '??? test: %s' % cmd
      if not opts.dry_run:
        test1 = subprocess.Popen(cmd, shell=True, stdout=None, stdin=None, stderr=None)
        test1.wait()
        status = test1.returncode
        print '??? exit-status: %d' % status
        condition[name] = (status != 0)
    elif action == 'cleanup':
      # for a cleanup entry, find all of the directories and matching files
      # and execute a stage on-the-fly to delete all of them.
      stage = entry[2]
      del_dirs = entry[3]
      del_pats = entry[4]
      logdir = entry[5]
      ds = [d for d in del_dirs if d not in clean_dirs]
      ps = [p for p in del_pats if p not in clean_pats]
      cmds = []
      if len(ds) != 0:
        clean_dirs.update(ds)
        cmds += ['rm -rf %s' % ' '.join(ds)]
      if len(ps) != 0:
        clean_pats.update(ps)
        cmds += ['rm -f %s' % ' '.join(ps)]
      if len(cmds) != 0:
        do_stage(opts,tgt,stage,cmds,logdir,skip)
    elif action == 'execute':
      # for an execute entry, execute a stage with all of its commands
      stage = entry[2]
      cmds = entry[3]
      logdir = entry[4]
      do_stage(opts,tgt,stage,cmds,logdir,skip)


# This routine actually executes the commands in a stage (if not
# skipped).  It handles the shell execution, logging the output,
# testing the return value and providing status messages for the user.
def do_stage(opts,tgt,stage,cmds,logdir,skip=False):
  if skip:
    for c in cmds:
      print '*** skip: %s' % c
  else:
    if not opts.dry_run:
      logfile=os.path.join(logdir,'%s_%s.log' % (tgt,stage))
      try:
        os.makedirs(logdir)
      except OSError, err:
        pass
      try:
        os.remove(logfile)
      except OSError, err:
        pass
    print '>>> Entering stage %s.' % stage
    for c in cmds:
      print '*** exec: %s' % c
      if not opts.dry_run:
        p1 = subprocess.Popen(c, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if opts.verbose:
          sink=None
        else:
          sink=file('/dev/null','w')
        p2 = subprocess.Popen(['tee', '-a', logfile], stdin=p1.stdout, stdout=sink, stderr=sink)
        p2.communicate()
        if sink:
          sink.close()
        p1.wait()
        if p1.returncode != 0:
          print '!!! Stage %s command encountered an error -- aborting build.' % stage
          print '!!! Look in the log file at %s for more information.' % logfile
          raise BuildError(tgt,stage,c)
    print '<<< Exiting stage %s.' % stage

# This routine handles the reading and parsing of a init file
def process_init_file(config,init_filename):
  try:
    init_file = file(init_filename)
  except:
    raise
  else:
    try:
      config = parse_project_file(config,init_file,init_filename)
      init_file.close()
      return config
    except:
      init_file.close()
      raise

# This routine handles the reading and parsing of a project file
def process_project_file(config,project_filename):
  try:
    project_file = file(project_filename)
  except:
    raise NoProjectBldFile(('No %s file found.' % project_filename))
  else:
    try:
      config = parse_project_file(config,project_file,project_filename)
      project_file.close()
      return config
    except:
      project_file.close()
      raise

# This routine resolves include-files directives into the global dictionary
def build_target_config(config,target):
  for entry in config[target]:
    (directive,val) = entry
    if directive == 'include-files':
      for incfile in val:
        print "Processing %s..." % incfile
        config = process_project_file(config,incfile)

  return config

# ##################################################################
# Top-level program sequencing

# The main entry point for the program
def main(argv=None):
  global PROJECT_ROOT
  global CURRENT_TARGET
  global JOBS

  if argv is None:
    argv = sys.argv

  try:
    # process command line arguments
    parser = mkOptionParser()
    opts, iargs = parser.parse_args()

    # Turn all the target arguments to lowercase
    args = []
    for a in iargs:
      args += [a.lower()]

    # handle the --doc option
    if opts.print_doc:
      print_documentation()
      return 1

    # handle the --jobs option
    global JOBS_QUICK
    if opts.no_depends:
      JOBS_QUICK = 1

    if int(opts.make_jobs) > 0:
      JOBS = int(opts.make_jobs)

    # handle the --skip-fpga option
    global SKIP_FPGA
    if opts.skip_fpga:
      SKIP_FPGA = opts.skip_fpga.split(',')

    # handle --init
    config = {}
    if opts.init_file:
      init_file = opts.init_file
      try:
        PROJECT_ROOT = os.path.dirname(fix_path(os.path.join(os.getcwd(), init_file)))
        config = process_init_file(config, init_file)
      except IOError, ioerror:
        if ioerror.filename:
          print >>sys.stderr, '%s: %s' % (ioerror.filename,ioerror.strerror)
        else:
          print >>sys.stderr, 'IOError: %s' % ioerror.strerror
          return 1
        return 1
      except ProjectFileError, parseerror:
        if parseerror.filename:
          prefix = '%s:%d:' % (parseerror.filename, parseerror.lineno)
        else:
          prefix = 'line %d:' % parseerror.lineno
        print >>sys.stderr, prefix, 'Error:', parseerror.msg
        print >>sys.stderr, prefix, '   In:', parseerror.text
        return 1

      try:
        write_project_bld_file(config, opts.project_file, opts.init_file)
        return 0
      except IOError, ioerror:
        if ioerror.filename:
          print >>sys.stderr, '%s: %s' % (ioerror.filename,ioerror.strerror)
        else:
          print >>sys.stderr, 'IOError: %s' % ioerror.strerror
          return 1
      except ProjectFileError, parseerror:
        if parseerror.filename:
          prefix = '%s:%d:' % (parseerror.filename, parseerror.lineno)
        else:
          prefix = 'line %d:' % parseerror.lineno
        print >>sys.stderr, prefix, 'Error:', parseerror.msg
        print >>sys.stderr, prefix, '   In:', parseerror.text
        return 1
    #else:
    #  raise ProjectFileExist(opts.project_file)


    if opts.transactor_build:
      init_file = opts.transactor_build
      try:
        PROJECT_ROOT = os.path.dirname(fix_path(os.path.join(os.getcwd(), init_file)))
        config = process_init_file(config, init_file)
      except IOError, ioerror:
        if ioerror.filename:
          print >>sys.stderr, '%s: %s' % (ioerror.filename,ioerror.strerror)
        else:
          print >>sys.stderr, 'IOError: %s' % ioerror.strerror
          return 1
        return 1

      try:
        write_project_transactor_generator_bld_file(config, opts.project_file, init_file)
        return 0
      except IOError, ioerror:
        if ioerror.filename:
          print >>sys.stderr, '%s: %s' % (ioerror.filename,ioerror.strerror)
        else:
          print >>sys.stderr, 'IOError: %s' % ioerror.strerror
          return 1
      except ProjectFileError, parseerror:
        if parseerror.filename:
          prefix = '%s:%d:' % (parseerror.filename, parseerror.lineno)
        else:
          prefix = 'line %d:' % parseerror.lineno
        print >>sys.stderr, prefix, 'Error:', parseerror.msg
        print >>sys.stderr, prefix, '   In:', parseerror.text
        return 1

    # parse the project build file
    config = {}
    try:
      PROJECT_ROOT = os.path.dirname(fix_path(os.path.join(os.getcwd(),opts.project_file)))
      config = process_project_file(config, opts.project_file)
      # Process optional testbench.bld.
      # This is a special semu .bld file for specifying one or more testbenches for the build
      # process.  If it exists, then the project file is processed, otherwise skip without error.
      if file_exist("testbench.bld"):
        process_project_file(config, "testbench.bld")
      # Another optional svtarget.bld
      if file_exist("svtarget.bld"):
        process_project_file(config, "svtarget.bld")
    # handle file / IO errors
    except IOError, ioerror:
      if ioerror.filename:
        print >>sys.stderr, '%s: %s' % (ioerror.filename,ioerror.strerror)
      else:
        print >>sys.stderr, 'IOError: %s' % ioerror.strerror
      return 1
    except ProjectFileError, parseerror:
      if parseerror.filename:
        prefix = '%s:%d:' % (parseerror.filename, parseerror.lineno)
      else:
        prefix = 'line %d:' % parseerror.lineno
      print >>sys.stderr, prefix, 'Error:', parseerror.msg
      print >>sys.stderr, prefix, '   In:', parseerror.text
      return 1

    try:
      if opts.list_targets:
        # handle the --list option
        list_targets(config, args)
      else:
        # determine which targets we want to build
        targets = []
        if len(args) == 0:
          default_targets = resolve('default','default-targets',config)
          if len(default_targets) == 0:
            # if there is only one valid target, use it
            possible_targets = valid_targets(config)
            if len(possible_targets) == 1:
              targets = possible_targets
            else:
              raise BadTarget()
          else:
            # we have a list of default targets to use
            targets = default_targets
        else:
          # we have an explicit list of targets to use
          targets = args

        ok_targets = valid_targets(config)
        for tgt in targets:
          if tgt.lower() not in ok_targets:
            raise BadTarget(tgt)

        # build up the list of stages to run for each target
        build_sequence = []
        orig_config    = copy.deepcopy(config)
        for tgt in targets:
          CURRENT_TARGET = tgt
          config = copy.deepcopy(orig_config)
          config = build_target_config(config, tgt.lower())
          build_sequence.append(build_stage_list(tgt.lower(),config))

          # if I've used the -q switch, then start from compile_for_??? stage by default
          if opts.no_depends:
            print ">>> Warning: skipping dependency build/home/sallen/bsc/inst/bin/build due to -q switch <<<"
            build_for = resolve(tgt.lower(),'build-for',config).lower()
            if (opts.first_stage == 'start'):
              if (build_for == 'bluesim'):
                opts.first_stage = 'compile_for_bluesim'
              else:
                opts.first_stage = 'compile_for_verilog'

        # select commands based on --from and --to
        run_list = filter_build_sequence(opts,build_sequence)

        # execute the selected commands
        execute_build_commands(opts,run_list)

      # a successful return code
      return 0

    # handle invalid targets, list valid choices
    except BadTarget, bad_tgt:
      if not bad_tgt.target_name:
        print >>sys.stderr, 'Error: You must supply a valid build target name.'
      else:
        print >>sys.stderr, 'Error: Unknown target \'%s\'' % bad_tgt.target_name
      msg = 'Valid targets are:'
      choices = valid_targets(config)
      choices.sort()
      for tgt in choices:
          msg += '\n  ' + tgt
      print >>sys.stderr, msg
      return 1
    # handle invalid stages, list valid choices
    except BadStage, bad_stg:
      if not bad_stg.stage_name:
        print >>sys.stderr, 'Error: No stages selected (are --from and --to swapped?)'
      elif not bad_stg.stage_purpose:
        print >>sys.stderr, 'Error: No %s stage' % bad_stg.target_name
      else:
        print >>sys.stderr, 'Error: Failed to match \'--%s %s\' option' % (bad_stg.stage_purpose, bad_stg.stage_name)
      msg = 'Use the --list option to see valid stages.'
      print >>sys.stderr, msg
      return 1
    # Handle errors in directive resolution
    except DirectiveError, directive_err:
      msg = 'Error: directive %s in section %s: %s' % (directive_err.name, directive_err.section, directive_err.msg)
      print >>sys.stderr, msg
      return 1
    # Handle errors from build commands (message was printed where exception was raised)
    except BuildError, bld_err:
      return 1

  # Handle command-line option errors
  except Usage, usage:
    if usage.msg:
      print >>sys.stderr, usage.msg
      print >>sys.stderr, 'for help use --help'
    return usage.status

  # Handle command-line option errors
  except NoProjectBldFile, target:
    if target.target_name:
      print >>sys.stderr, target.target_name
      if target.target_name == 'No project.bld file found.':
        print >>sys.stderr, ' -> To generate an initial project.bld file, please edit init.bld and run "build --init".'
        write_default_init_file()
    return 0

  # Handle command-line option errors
  except ProjectFileExist, target:
    if target.target_name:
      print >>sys.stderr, target.target_name, ' exists, cannot write over existing project file. Use --initforce if you really want to.'
    return 1

# For non-interactive invocations, call main() and use its return value
# as the exit code.
if __name__ == '__main__':
  sys.exit(main())
