#!/usr/bin/perl
################################################################################
# Bluespec, Inc
# Author: Steve Allen (sallen@bluespec.com)
#
# create a vhdl wrapper around a bluespec generated verilog file.
# This simply scans the input/output ports, creates
#  vhdl component for the verilog block, then connects
# the vhdl pins to the verilog
#
################################################################################
# default values (unset - determine from code itself)
$callname = $0;
$arch   = "";
$entity = "";
$nodates = 0;
$nocomments = 0;
$version = "1.0";

######################################################################
use Getopt::Long;
GetOptions( "verbose!"=>\$verboseornoverbose,
            "arch=s"  =>\$arch,
            "nodates!" =>\$nodates,
            "nocomments!" =>\$nocomments,
            "entity=s"=>\$entity );

if ($#ARGV != 0) {
    &usage;
}

######################################################################
if ($nocomments == 1) {
    $echoComment = 0;
} else {
    $echoComment = 1;
}

while (<>) {
    $orig = $_;  # might need this later

    if (($echoComment == 1) && m@^//@ ) {
        # echo the first comments at head of file
        s@//(.*)$@--$1@;
        if (($nodates==1) && /^-- (Auto translated|Generated by|On )/) {
            ;
        } else {
            $comments .= $_;  # save comments for printing later
        }
    }
        
    # remove comments for easy scanning
    s@//.*$@@;   # remove comments 

    if (/^\s*endmodule/) {
        last;

    } elsif (/^\s*module ([\w_]+)/) {
        $echoComment = 0;
        if ($arch eq "") {
            # get arch name from module, if switch didn't specify it
            $arch      = $1;
        }
        if ($entity eq "") {
            $entity    = $arch;

            # if switch doesn't specify entity, start with arch
            # (which in this case I presume is from a bsv generated block)
            # so there's a chance it starts with "mk".. in which case
            # the arch is mkFoo and the entity is Foo
            # otherwise, use arch name, and just and "e" from front of it
            # want to do something different? then specify it
            if ($entity !~ s/^mk//) {
                $entity = "entity_$arch";
            }
        }
        # TODO: command line option

    } elsif (s/^\s+inout\s+//) {
        die "inout pins not allowed yet...";

    } elsif (s/^\s+(in|out)put\s+//) {
        $dir = $1;
        readUptoSemi();

        s/\s+//ig;        # remove all spaces

        # get size info, delete it from line in progress
        if (s/^\[(\d+):(\d+)]//) {
            die "Range of [x:0] only for now!\n  $orig" if ($2 != 0);
            $sz = $1 - $2 + 1;
        } else {
            $sz = 1;
        }

        # clean extra spaces out, and split on ,

        @p = split(',');

        # we now have a nice list of each port for this input/output
        foreach $item (@p) {
            push( @portList, $item );
            $dir{$item}  = $dir;
            $size{$item} = $sz;
        }
    }
}

######################################################################
# now look through the list of ports we created and create
# the vhdl, verilog, etc stuff that we need        s/\s+//ig;
foreach $port ( @portList ) {
    if ($size{$port} == 1) {
        $type = "std_logic";
    } else {
        $h = $size{$port} - 1;
        $type = "std_logic_vector($h downto 0)";
    }

    # entityList
    $l = sprintf "    %-20s   : %-3s   %s", $port, $dir{$port}, $type;
    push( @elist, $l );
    push( @clist, "  $l" );

    # port connections
    $l = sprintf "      %-20s => %s", $port, $port;
    push( @plist, $l );
}

######################################################################
print "-- Auto translated from verilog to vhdl by $callname version $version\n" if ($nodates == 0);

print $comments;

print "library IEEE;\n" .
      "  use IEEE.std_logic_1164.all;\n" .
      "\n" .
      "entity $entity is\n" .
      "port (\n" .
      (join(";\n", @elist)) .
      "\n);\n" .
      "end $entity;\n" .
      "\n";

print "architecture rtl of $entity is\n" .
      "\n" .
      "  component $arch is\n" .
      "    port (\n" .
      (join(";\n", @clist)) .
      "\n" .
      "    );\n" .
      "  end component $arch;\n" .
      "\n" ;

print "begin\n" .
      "  bs_r2m : $arch\n" .
      "    port map (\n" .
      (join(",\n", @plist)) .
      "\n" .
      "    );\n" .
      "end rtl ;\n";

######################################################################
sub readUptoSemi {
    while (!/;/) {
        my $l = <>;
        $l =~ s@//.*$@@;   # remove comments
        $_ .= $l;
    }
    s/;//ig;  # remove semicolon when we find it
}

######################################################################
sub usage {
    print "
usage: $callname [-arch=name] [-entity=name] [-nodates] [-nocomments] file.v

       -arch=name      specify name for architecture [optional]
       -entity=name    specify name for entity       [optional]
       -nodates        don't print out comments with dates, paths, etc
       -nocomments     don't print out comments at all
       file.v          verilog file

  The the first module found in file.v is scanned for input and output
  pins (inouts are not scanned at the moment).  This are built into a
  vhdl wrapper with the arch name taken from the switch or from the
  module name (in a Bluespec generated verilog case, this will probably
  be 'mkFoo' or something like that)..  If the entity name is not
  specified then it is take by removing the leading 'mk' from the arch
  name (i.e. mkFoo for the rtl/arch and Foo for the entity).  If the
  arch name is not mkSomething, then it simply puts an 'e' in front of
  the arch name..  If you really really care, set both -arch and -entity
  yourself :)
";

    exit(1);
}
