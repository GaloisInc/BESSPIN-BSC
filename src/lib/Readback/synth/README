---------------------------------------------------------------------------

Readback Synthesis
------------------

Synthesizing a design for Readback involves generating

  (*) a bitfile with as many source signals preserved as possible, and

  (*) an XRF file which correlates source names to the bit locations in the
      bitfile (to be used by the software side)

The XRF is constructed from four output files during synthesis:

  (A) an EDIF file generated from synthesis of a variant of the Verilog
      to preserve all the source names (sometimes called the "RTL" EDIF);

  (B) an EDIF file generated from synthesis of the actual design;

  (C) the log from Vivado during synthesis of the actual design (referred
      to as the "slog" file), to be parsed for messages about signals which
      are constant or unused; and

  (D) a Logic Location (LL) file indicating the bit locations of each signal
      in the actual implementation.

This is achieved in three steps:

  (1) Run Vivado to generate #A (an EDIF file with source-name info).
      This is run on a variant of the design, which is generated by taking
      the original Verilog and adding a "keep" attribute on all of the
      signals (and adding a no-op operation to any signals which are just
      aliases).  The EDIF is generated after the "synth" stage, so no "impl"
      stage is needed here.

  (2) Run complete Vivado synthesis ("synth" and "impl" stages) on the
      original design to generate the bitfile, #B, #C, and #D.  During
      this run, a number of optimazations are disabled, to preserve as
      many useful signals in the hardware as possible.  The limit on log
      messages is also increased, so that the "slog" file contains as
      much as information as possible.

  (3) Compile and run "create_xrf", to generate the XRF from the four
      output files.

These three steps are described in more detail below.

[TODO: An example Makefile and synthesis script are included in this
directory for convenience.]

---------------------------------------------------------------------------
Synthesis step #1: Vivado source-info run

The synthesis script for this Vivado run is the following:

    create_project <PROJNAME> <PROJDIR> -part <PART>
    set_property design_mode RTL [current_fileset -srcset]

    add_files <RTLDIR>

    # if using JTAG Readback
    add_file $env(BLUESPECDIR)/board_support/bluenoc/xilinx/verilog/internal_jtag.v

    set_property top <TOPMOD> [get_property srcset [current_run]]

    synth_design -rtl -name rtl_1
    write_edif ./<TOPMOD>.rtl

As the last two lines indicate, this runs "synth" and then generates an
EDIF file (relative to the directory where Vivado is run or to an absolute
location).

The script expects to find the files in <RTLDIR> (the "build" script uses
the name "elab_source").  Those files need to be generated from the original
Verilog using a Perl script from the Bluespec release called "edit_for_elab".

The script "edit_for_elab" takes a Verilog file and generates a copy of
that file with "keep" attributes added to each signal and with no-ops added
to aliases assignments (to prevent such alias signals from being ignored).
The script can be run on one file, but it is typically run on all the files
by invoking it with "-f" to provide a list of source files:

    mkdir <RTLDIR>
    edit_for_elab -f files.txt <RTLDIR>

The list and the invocation can be done before running Vivado, or they can
be done inside the Vivado script.  For example:

    set fp [open files.txt w]
    # Add all the files from a directory
    foreach f [glob $env(BLUESPECDIR)/Verilog/*.v] { puts $fp $f }
    foreach f [glob $env(BLUESPECDIR)/Verilog.Vivado/*.v] { puts $fp $f }
    foreach f [glob $env(BLUESPECDIR)/Libraries/*.v] { puts $fp $f }
    # Add an individual file
    puts $fp $srcdir/verilog/ASSIGN1.v
    foreach f [glob $srcdir/hdl/*.v] { puts $fp $f }
    close $fp

    file mkdir elab_source
    exec edit_for_elab -f files.txt elab_source

The "edit_for_elab" script does not recurse into directories, so each file
must be explicitly named.  (This might be a useful improvement to the script.)

The "internal_jtag.v" file from "board_support" could also be included in
this list, rather than added separately, if readback of the signals in that
module are desired.

---------------------------------------------------------------------------
Synthesis step #2: Vivado bitfile run

The synthesis script for this Vivado run is the following:

    # In place of hardcoding, define some commonly used paths and names:

    # Where to place the generated bitfile
    set bitdir .

    # Where to place the generated files needed for "create_xrf" (Readback)
    set xrfdir .

    # Project name and subdirectory
    set projname <PROJNAME>
    set projdir <PROJDIR>

    # Top module name
    set topmod <TOPMOD>

    create_project $projname $projdir -part <PART>
    set_property design_mode RTL [current_fileset -srcset]

    add_files $env(BLUESPECDIR)/Verilog
    add_files $env(BLUESPECDIR)/Verilog.Vivado
    add_files $env(BLUESPECDIR)/Libraries
    # Add the user files
    add_files ...

    # if using JTAG Readback
    add_file $env(BLUESPECDIR)/board_support/bluenoc/xilinx/verilog/internal_jtag.v

    # Include any design-specific constraint files
    read_xdc ...

    set_property top $topmod [get_property srcset [current_run]]

    # --------------------
    # For Readback

    # This memory image is needed from the Bluespec release
    # (it will be copied into the synth directory,
    # but we make a local copy for convenience)
    file copy -force \
        $env(BLUESPECDIR)/board_support/bluenoc/xilinx/verilog/icap_fsm7.txt \
	./

    # Generate an LL file (needed for creating Readback XRF)
    set_property STEPS.WRITE_BITSTREAM.ARGS.LOGIC_LOCATION_FILE true [get_runs impl_1]

    # Preserve signals during synthesis
    set_property STEPS.SYNTH_DESIGN.ARGS.KEEP_EQUIVALENT_REGISTERS true [get_runs synth_1]
    set_property STEPS.SYNTH_DESIGN.ARGS.NO_LC true [get_runs synth_1]
    set_property STEPS.SYNTH_DESIGN.ARGS.FLATTEN_HIERARCHY none [get_runs synth_1]
    set_property STEPS.SYNTH_DESIGN.ARGS.FSM_EXTRACTION off [get_runs synth_1]

    # For Readback XRF, we use messages in the Vivado log, so increase the
    # message limit, to ensure that we get all the messages
    set_param messaging.defaultLimit 200000

    # Before synth, copy the memory file into the synth directory
    set fp [open pre_synth.tcl w]
    puts $fp "file copy -force ../../../icap_fsm7.txt ."
    close $fp
    set_property STEPS.SYNTH_DESIGN.TCL.PRE ../../../pre_synth.tcl [get_runs synth_1]

    # After impl, write an EDF file (needed for creating Readback XRF)
    set fp [open post_synth.tcl w]
    puts $fp "write_edif -force ../../../$topmod.edf"
    close $fp
    set_property STEPS.OPT_DESIGN.TCL.POST ../../../post_synth.tcl [get_runs impl_1]

    # --------------------

    set_property strategy {Vivado Synthesis Defaults} [get_runs synth_1]
    set_property strategy {Vivado Implementation Defaults} [get_runs impl_1]

    # Run the Synthesis stage
    launch_runs synth_1
    wait_on_run synth_1

    # Run the Implementation stage
    launch_runs impl_1 -to_step write_bitstream
    wait_on_run impl_1

    # For Readback copy the Vivado synth log to the current directory
    # (and name as needed for XRF)
    file copy -force $projdir/$projname.runs/synth_1/runme.log $xrfdir/$topmod.slog

    # For Readback, copy the LL file to the current directory
    file copy -force $projdir/$projname.runs/impl_1/$topmod.ll $xrfdir/$topmod.ll

    # Copy the generated bit file to the current directory (for programming)
    file copy -force $projdir/$projname.runs/impl_1/$topmod.bit $bitdir/$projname.bit

This version of the script uses the unedited source files and runs both
"synth" and "impl" stages.  Each stage creates it own subdirectory and
generates work files in that directory.  If the top-level script wants
command to be run during that process, it has to register a script of
those commands with Vivado, which will execute that script at the right
time.

For example, the Readback module contains a $readmem call to load the
contents of memory from a file.  That file needs to be in the synthesis
directory.  But the directory won't be created until the "synth" stage
runs, so we use a PRE command to copy the file into place.  In the example
above, the script for that is created dynamically, but it could also
pre-exist somewhere.

The other example is a POST script to be run at the end of the "impl"
stage to generate the EDIF file.  The top-level script could write the
EDIF, but it would need to open the implemented design; it's easier to
write it as a POST command, where the design is already open.

Each of these stages execute in a subdirectory, such as:
  $projdir/$projname.runs/impl_1
therefore, to find the PRE or POST script in the directory where Vivado
is run, we have to go up three directories:
  set_property STEPS.SYNTH_DESIGN.TCL.PRE ../../../pre_synth.tcl [get_runs synth_1]

The POST script can write the EDIF directly to where we want it, but the
other output files are three directories down.  So, at the end of the
script, we have a few commands to move the files ("slog", LL, and bitfile)
to more convenient locations.

---------------------------------------------------------------------------
Synthesis step #3: Create XRF

The "create_xrf" program is not pre-compiled in the release.  The "build"
script (when used to build to a design with Readback) has a stage for
compiling the program.  The program is not pre-compiled because it uses
the gzstream library, which has a GPL license.  That could be overcome
by providing enough source for the user to recompile with their own
library, but then we'd also need to provide different variants for 32 vs
64 bit etc, so it's easier to leave it this way for now.

The source for the program is at $(BLUESPECDIR)/Readback/create_xrf.cxx
and it can be compiled with following Makefile target:

  create_xrf: $(BLUESPECDIR)/Readback/create_xrf.cxx
	g++ \
		-o $@ \
		$^ \
		-I$(BLUESPECDIR)/Readback \
		-L$(BLUESPECDIR)/Readback/$(CXXFAMILY) \
		-lreadback \
		-lz \

where $@ is the target name and $^ is the dependencies.

The program is executed with the following command:

	./create_xrf <XRFDIR> <TOPMOD>

The first argument is a directory containing the four files and where
the output file will be placed.  The second argument is the name of the
top module and the expected basename of the four files:

  <TOPMOD>.rtl   =  the "rtl" EDIF
  <TOPMOD>.edf   =  the bitfile EDIF
  <TOPMOD>.ll    =  the LL
  <TOPMOD>.slog  =  the Vivado synthesis log

It generates the file <TOPMOD>.xrf in the <XRFDIR> directory.

---------------------------------------------------------------------------
