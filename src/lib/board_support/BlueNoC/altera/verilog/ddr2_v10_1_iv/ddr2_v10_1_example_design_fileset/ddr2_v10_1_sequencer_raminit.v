// megafunction wizard: %RAM initializer%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: ALTMEM_INIT 

// ============================================================
// File Name: sequencer_raminit.v
// Megafunction Name(s):
// 			ALTMEM_INIT
//
// Simulation Library Files(s):
// 			lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 10.0 Internal Build 139 02/18/2010 TO Full Version
// ************************************************************


//Copyright (C) 1991-2009 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


//altmem_init CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Stratix III" INIT_TO_ZERO="NO" NUMWORDS=4096 PORT_ROM_DATA_READY="PORT_USED" ROM_READ_LATENCY=1 WIDTH=32 WIDTHAD=12 clock datain dataout init init_busy ram_address ram_wren rom_address rom_data_ready rom_rden
//VERSION_BEGIN 10.0 cbx_altmem_init 2010:02:18:22:06:51:TO cbx_altsyncram 2010:02:18:22:06:51:TO cbx_cycloneii 2010:02:18:22:06:51:TO cbx_lpm_add_sub 2010:02:18:22:06:51:TO cbx_lpm_compare 2010:02:18:22:06:51:TO cbx_lpm_counter 2010:02:18:22:06:51:TO cbx_lpm_decode 2010:02:18:22:06:51:TO cbx_lpm_mux 2010:02:18:22:06:51:TO cbx_mgl 2010:02:18:22:28:03:TO cbx_stratix 2010:02:18:22:06:51:TO cbx_stratixii 2010:02:18:22:06:51:TO cbx_stratixiii 2010:02:18:22:06:51:TO cbx_util_mgl 2010:02:18:22:06:51:TO  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = lpm_compare 2 lpm_counter 2 reg 51 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  ddr2_v10_1_sequencer_raminit_meminit_46o
	( 
	clock,
	datain,
	dataout,
	init,
	init_busy,
	ram_address,
	ram_wren,
	rom_address,
	rom_data_ready,
	rom_rden) ;
	input   clock;
	input   [31:0]  datain;
	output   [31:0]  dataout;
	input   init;
	output   init_busy;
	output   [11:0]  ram_address;
	output   ram_wren;
	output   [11:0]  rom_address;
	input   rom_data_ready;
	output   rom_rden;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   [31:0]  datain;
	tri0   rom_data_ready;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[0:0]	capture_init;
	reg	[11:0]	delay_addr;
	wire	[11:0]	wire_delay_addr_ena;
	reg	[31:0]	delay_data;
	wire	[31:0]	wire_delay_data_ena;
	reg	[2:0]	prev_state;
	wire	[2:0]	wire_state_reg_d;
	reg	[2:0]	state_reg;
	wire	[2:0]	wire_state_reg_sclr;
	wire	[2:0]	wire_state_reg_sload;
	wire  wire_addr_cmpr_aeb;
	wire  wire_addr_cmpr_alb;
	wire  wire_wait_cmpr_aeb;
	wire  wire_wait_cmpr_alb;
	wire  [11:0]   wire_addr_ctr_q;
	wire  [0:0]   wire_wait_ctr_q;
	wire  [0:0]  addrct_eq_numwords;
	wire  [0:0]  addrct_lt_numwords;
	wire clken;
	wire  [31:0]  dataout_w;
	wire  [0:0]  done_state;
	wire  [0:0]  idle_state;
	wire  [0:0]  ram_write_state;
	wire  [0:0]  reset_state_machine;
	wire  [0:0]  rom_addr_state;
	wire  [0:0]  rom_data_capture_state;
	wire  [0:0]  state_machine_clken;

	// synopsys translate_off
	initial
		capture_init = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (clken == 1'b1)   capture_init <= ((init | capture_init) & (~ done_state));
	// synopsys translate_off
	initial
		delay_addr[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[0:0] == 1'b1)   delay_addr[0:0] <= wire_addr_ctr_q[0:0];
	// synopsys translate_off
	initial
		delay_addr[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[1:1] == 1'b1)   delay_addr[1:1] <= wire_addr_ctr_q[1:1];
	// synopsys translate_off
	initial
		delay_addr[2:2] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[2:2] == 1'b1)   delay_addr[2:2] <= wire_addr_ctr_q[2:2];
	// synopsys translate_off
	initial
		delay_addr[3:3] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[3:3] == 1'b1)   delay_addr[3:3] <= wire_addr_ctr_q[3:3];
	// synopsys translate_off
	initial
		delay_addr[4:4] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[4:4] == 1'b1)   delay_addr[4:4] <= wire_addr_ctr_q[4:4];
	// synopsys translate_off
	initial
		delay_addr[5:5] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[5:5] == 1'b1)   delay_addr[5:5] <= wire_addr_ctr_q[5:5];
	// synopsys translate_off
	initial
		delay_addr[6:6] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[6:6] == 1'b1)   delay_addr[6:6] <= wire_addr_ctr_q[6:6];
	// synopsys translate_off
	initial
		delay_addr[7:7] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[7:7] == 1'b1)   delay_addr[7:7] <= wire_addr_ctr_q[7:7];
	// synopsys translate_off
	initial
		delay_addr[8:8] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[8:8] == 1'b1)   delay_addr[8:8] <= wire_addr_ctr_q[8:8];
	// synopsys translate_off
	initial
		delay_addr[9:9] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[9:9] == 1'b1)   delay_addr[9:9] <= wire_addr_ctr_q[9:9];
	// synopsys translate_off
	initial
		delay_addr[10:10] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[10:10] == 1'b1)   delay_addr[10:10] <= wire_addr_ctr_q[10:10];
	// synopsys translate_off
	initial
		delay_addr[11:11] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_addr_ena[11:11] == 1'b1)   delay_addr[11:11] <= wire_addr_ctr_q[11:11];
	assign
		wire_delay_addr_ena = {12{(clken & rom_data_capture_state)}};
	// synopsys translate_off
	initial
		delay_data[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[0:0] == 1'b1)   delay_data[0:0] <= datain[0:0];
	// synopsys translate_off
	initial
		delay_data[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[1:1] == 1'b1)   delay_data[1:1] <= datain[1:1];
	// synopsys translate_off
	initial
		delay_data[2:2] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[2:2] == 1'b1)   delay_data[2:2] <= datain[2:2];
	// synopsys translate_off
	initial
		delay_data[3:3] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[3:3] == 1'b1)   delay_data[3:3] <= datain[3:3];
	// synopsys translate_off
	initial
		delay_data[4:4] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[4:4] == 1'b1)   delay_data[4:4] <= datain[4:4];
	// synopsys translate_off
	initial
		delay_data[5:5] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[5:5] == 1'b1)   delay_data[5:5] <= datain[5:5];
	// synopsys translate_off
	initial
		delay_data[6:6] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[6:6] == 1'b1)   delay_data[6:6] <= datain[6:6];
	// synopsys translate_off
	initial
		delay_data[7:7] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[7:7] == 1'b1)   delay_data[7:7] <= datain[7:7];
	// synopsys translate_off
	initial
		delay_data[8:8] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[8:8] == 1'b1)   delay_data[8:8] <= datain[8:8];
	// synopsys translate_off
	initial
		delay_data[9:9] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[9:9] == 1'b1)   delay_data[9:9] <= datain[9:9];
	// synopsys translate_off
	initial
		delay_data[10:10] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[10:10] == 1'b1)   delay_data[10:10] <= datain[10:10];
	// synopsys translate_off
	initial
		delay_data[11:11] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[11:11] == 1'b1)   delay_data[11:11] <= datain[11:11];
	// synopsys translate_off
	initial
		delay_data[12:12] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[12:12] == 1'b1)   delay_data[12:12] <= datain[12:12];
	// synopsys translate_off
	initial
		delay_data[13:13] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[13:13] == 1'b1)   delay_data[13:13] <= datain[13:13];
	// synopsys translate_off
	initial
		delay_data[14:14] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[14:14] == 1'b1)   delay_data[14:14] <= datain[14:14];
	// synopsys translate_off
	initial
		delay_data[15:15] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[15:15] == 1'b1)   delay_data[15:15] <= datain[15:15];
	// synopsys translate_off
	initial
		delay_data[16:16] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[16:16] == 1'b1)   delay_data[16:16] <= datain[16:16];
	// synopsys translate_off
	initial
		delay_data[17:17] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[17:17] == 1'b1)   delay_data[17:17] <= datain[17:17];
	// synopsys translate_off
	initial
		delay_data[18:18] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[18:18] == 1'b1)   delay_data[18:18] <= datain[18:18];
	// synopsys translate_off
	initial
		delay_data[19:19] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[19:19] == 1'b1)   delay_data[19:19] <= datain[19:19];
	// synopsys translate_off
	initial
		delay_data[20:20] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[20:20] == 1'b1)   delay_data[20:20] <= datain[20:20];
	// synopsys translate_off
	initial
		delay_data[21:21] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[21:21] == 1'b1)   delay_data[21:21] <= datain[21:21];
	// synopsys translate_off
	initial
		delay_data[22:22] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[22:22] == 1'b1)   delay_data[22:22] <= datain[22:22];
	// synopsys translate_off
	initial
		delay_data[23:23] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[23:23] == 1'b1)   delay_data[23:23] <= datain[23:23];
	// synopsys translate_off
	initial
		delay_data[24:24] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[24:24] == 1'b1)   delay_data[24:24] <= datain[24:24];
	// synopsys translate_off
	initial
		delay_data[25:25] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[25:25] == 1'b1)   delay_data[25:25] <= datain[25:25];
	// synopsys translate_off
	initial
		delay_data[26:26] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[26:26] == 1'b1)   delay_data[26:26] <= datain[26:26];
	// synopsys translate_off
	initial
		delay_data[27:27] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[27:27] == 1'b1)   delay_data[27:27] <= datain[27:27];
	// synopsys translate_off
	initial
		delay_data[28:28] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[28:28] == 1'b1)   delay_data[28:28] <= datain[28:28];
	// synopsys translate_off
	initial
		delay_data[29:29] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[29:29] == 1'b1)   delay_data[29:29] <= datain[29:29];
	// synopsys translate_off
	initial
		delay_data[30:30] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[30:30] == 1'b1)   delay_data[30:30] <= datain[30:30];
	// synopsys translate_off
	initial
		delay_data[31:31] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (wire_delay_data_ena[31:31] == 1'b1)   delay_data[31:31] <= datain[31:31];
	assign
		wire_delay_data_ena = {32{(clken & rom_data_capture_state)}};
	// synopsys translate_off
	initial
		prev_state = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (clken == 1'b1)   prev_state <= state_reg;
	// synopsys translate_off
	initial
		state_reg[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (state_machine_clken == 1'b1) 
			if (wire_state_reg_sclr[0:0] == 1'b1) state_reg[0:0] <= 1'b0;
			else if (wire_state_reg_sload[0:0] == 1'b1) state_reg[0:0] <= 1;
			else  state_reg[0:0] <= wire_state_reg_d[0:0];
	// synopsys translate_off
	initial
		state_reg[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (state_machine_clken == 1'b1) 
			if (wire_state_reg_sclr[1:1] == 1'b1) state_reg[1:1] <= 1'b0;
			else if (wire_state_reg_sload[1:1] == 1'b1) state_reg[1:1] <= 1;
			else  state_reg[1:1] <= wire_state_reg_d[1:1];
	// synopsys translate_off
	initial
		state_reg[2:2] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (state_machine_clken == 1'b1) 
			if (wire_state_reg_sclr[2:2] == 1'b1) state_reg[2:2] <= 1'b0;
			else if (wire_state_reg_sload[2:2] == 1'b1) state_reg[2:2] <= 1;
			else  state_reg[2:2] <= wire_state_reg_d[2:2];
	assign
		wire_state_reg_d = {(((~ state_reg[2]) & state_reg[1]) & state_reg[0]), ((~ state_reg[2]) & (state_reg[1] ^ state_reg[0])), ((~ state_reg[2]) & (~ state_reg[0]))};
	assign
		wire_state_reg_sclr = {{2{reset_state_machine}}, 1'b0},
		wire_state_reg_sload = {{2{1'b0}}, reset_state_machine};
	lpm_compare   addr_cmpr
	( 
	.aeb(wire_addr_cmpr_aeb),
	.agb(),
	.ageb(),
	.alb(wire_addr_cmpr_alb),
	.aleb(),
	.aneb(),
	.dataa(delay_addr),
	.datab({12{1'b1}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		addr_cmpr.lpm_width = 12,
		addr_cmpr.lpm_type = "lpm_compare";
	lpm_compare   wait_cmpr
	( 
	.aeb(wire_wait_cmpr_aeb),
	.agb(),
	.ageb(),
	.alb(wire_wait_cmpr_alb),
	.aleb(),
	.aneb(),
	.dataa(wire_wait_ctr_q),
	.datab(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		wait_cmpr.lpm_width = 1,
		wait_cmpr.lpm_type = "lpm_compare";
	lpm_counter   addr_ctr
	( 
	.clk_en(clken),
	.clock(clock),
	.cnt_en(ram_write_state),
	.cout(),
	.eq(),
	.q(wire_addr_ctr_q),
	.sclr(((~ state_reg[1]) & (~ state_reg[0])))
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.data({12{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		addr_ctr.lpm_direction = "UP",
		addr_ctr.lpm_modulus = 4096,
		addr_ctr.lpm_port_updown = "PORT_UNUSED",
		addr_ctr.lpm_width = 12,
		addr_ctr.lpm_type = "lpm_counter";
	lpm_counter   wait_ctr
	( 
	.clk_en(clken),
	.clock(clock),
	.cnt_en(rom_addr_state),
	.cout(),
	.eq(),
	.q(wire_wait_ctr_q),
	.sclr((~ rom_addr_state))
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.data({1{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		wait_ctr.lpm_direction = "UP",
		wait_ctr.lpm_modulus = 1,
		wait_ctr.lpm_port_updown = "PORT_UNUSED",
		wait_ctr.lpm_width = 1,
		wait_ctr.lpm_type = "lpm_counter";
	assign
		addrct_eq_numwords = wire_addr_cmpr_aeb,
		addrct_lt_numwords = wire_addr_cmpr_alb,
		clken = 1'b1,
		dataout = dataout_w,
		dataout_w = delay_data,
		done_state = ((state_reg[2] & (~ state_reg[1])) & (~ state_reg[0])),
		idle_state = (((~ state_reg[2]) & (~ state_reg[1])) & (~ state_reg[0])),
		init_busy = capture_init,
		ram_address = delay_addr,
		ram_wren = ram_write_state,
		ram_write_state = (((~ state_reg[2]) & state_reg[1]) & state_reg[0]),
		reset_state_machine = (ram_write_state & addrct_lt_numwords),
		rom_addr_state = (((~ state_reg[2]) & (~ state_reg[1])) & state_reg[0]),
		rom_address = wire_addr_ctr_q,
		rom_data_capture_state = (((~ state_reg[2]) & state_reg[1]) & (~ state_reg[0])),
		rom_rden = (((~ prev_state[2]) & (((~ prev_state[1]) & (~ prev_state[0])) | (prev_state[1] & prev_state[0]))) & (((~ state_reg[2]) & (~ state_reg[1])) & state_reg[0])),
		state_machine_clken = (clken & ((idle_state & capture_init) | ((rom_data_capture_state | done_state) | (capture_init & (((~ (rom_addr_state & (~ rom_data_ready))) | (rom_addr_state & rom_data_ready)) | (ram_write_state & addrct_eq_numwords))))));
endmodule //sequencer_raminit_meminit_46o
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module ddr2_v10_1_sequencer_raminit (
	clock,
	datain,
	init,
	rom_data_ready,
	dataout,
	init_busy,
	ram_address,
	ram_wren,
	rom_address,
	rom_rden);

	input	  clock;
	input	[31:0]  datain;
	input	  init;
	input	  rom_data_ready;
	output	[31:0]  dataout;
	output	  init_busy;
	output	[11:0]  ram_address;
	output	  ram_wren;
	output	[11:0]  rom_address;
	output	  rom_rden;

	wire [11:0] sub_wire0;
	wire  sub_wire1;
	wire [11:0] sub_wire2;
	wire [31:0] sub_wire3;
	wire  sub_wire4;
	wire  sub_wire5;
	wire [11:0] ram_address = sub_wire0[11:0];
	wire  ram_wren = sub_wire1;
	wire [11:0] rom_address = sub_wire2[11:0];
	wire [31:0] dataout = sub_wire3[31:0];
	wire  init_busy = sub_wire4;
	wire  rom_rden = sub_wire5;

	ddr2_v10_1_sequencer_raminit_meminit_46o	sequencer_raminit_meminit_46o_component (
				.clock (clock),
				.init (init),
				.datain (datain),
				.rom_data_ready (rom_data_ready),
				.ram_address (sub_wire0),
				.ram_wren (sub_wire1),
				.rom_address (sub_wire2),
				.dataout (sub_wire3),
				.init_busy (sub_wire4),
				.rom_rden (sub_wire5));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Stratix III"
// Retrieval info: CONSTANT: INIT_FILE STRING "UNUSED"
// Retrieval info: CONSTANT: INIT_TO_ZERO STRING "NO"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Stratix III"
// Retrieval info: CONSTANT: LPM_HINT STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altmem_init"
// Retrieval info: CONSTANT: NUMWORDS NUMERIC "4096"
// Retrieval info: CONSTANT: PORT_ROM_DATA_READY STRING "PORT_USED"
// Retrieval info: CONSTANT: ROM_READ_LATENCY NUMERIC "1"
// Retrieval info: CONSTANT: WIDTH NUMERIC "32"
// Retrieval info: CONSTANT: WIDTHAD NUMERIC "12"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: USED_PORT: datain 0 0 32 0 INPUT NODEFVAL "datain[31..0]"
// Retrieval info: CONNECT: @datain 0 0 32 0 datain 0 0 32 0
// Retrieval info: USED_PORT: dataout 0 0 32 0 OUTPUT NODEFVAL "dataout[31..0]"
// Retrieval info: CONNECT: dataout 0 0 32 0 @dataout 0 0 32 0
// Retrieval info: USED_PORT: init 0 0 0 0 INPUT NODEFVAL "init"
// Retrieval info: CONNECT: @init 0 0 0 0 init 0 0 0 0
// Retrieval info: USED_PORT: init_busy 0 0 0 0 OUTPUT NODEFVAL "init_busy"
// Retrieval info: CONNECT: init_busy 0 0 0 0 @init_busy 0 0 0 0
// Retrieval info: USED_PORT: ram_address 0 0 12 0 OUTPUT NODEFVAL "ram_address[11..0]"
// Retrieval info: CONNECT: ram_address 0 0 12 0 @ram_address 0 0 12 0
// Retrieval info: USED_PORT: ram_wren 0 0 0 0 OUTPUT NODEFVAL "ram_wren"
// Retrieval info: CONNECT: ram_wren 0 0 0 0 @ram_wren 0 0 0 0
// Retrieval info: USED_PORT: rom_address 0 0 12 0 OUTPUT NODEFVAL "rom_address[11..0]"
// Retrieval info: CONNECT: rom_address 0 0 12 0 @rom_address 0 0 12 0
// Retrieval info: USED_PORT: rom_data_ready 0 0 0 0 INPUT NODEFVAL "rom_data_ready"
// Retrieval info: CONNECT: @rom_data_ready 0 0 0 0 rom_data_ready 0 0 0 0
// Retrieval info: USED_PORT: rom_rden 0 0 0 0 OUTPUT NODEFVAL "rom_rden"
// Retrieval info: CONNECT: rom_rden 0 0 0 0 @rom_rden 0 0 0 0
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit.v TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit.qip TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit.bsf FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit_inst.v FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit_bb.v FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit.inc FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL sequencer_raminit.cmp FALSE TRUE
// Retrieval info: LIB_FILE: lpm
