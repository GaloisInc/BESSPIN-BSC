//-*- C++ -*-x
#pragma once

#include "TLMRequest.h"
#include "TLMResponse.h"
#include "../bsvxactors/XactorCore.h"
#include "dllexport.h"

/// data type to hold response payload size and discard status
class ResponseHandling {
public:
  unsigned m_payload;
  bool     m_discard;
  ResponseHandling () : m_payload(0), m_discard(false) {}
};

#ifdef _WIN32
template class DLLEXPORT WaitQueueT<ResponseHandling>;
#endif

///  Master Transactor: sends TLM requests; recevies TLM responses.
/// This xactor is the host side of a client master xactor.  It sesnds
/// TLMRequests to the client and reveives TLMResponses.  Templates are
/// used to address width (bits), data size width (bits), and the user data bit width (0,32, or 64).
template<unsigned int ADDRSIZE=32, unsigned int DATASIZE=32, unsigned int USERDSIZE=0>
class DLLEXPORT SlaveProxy : public XactorCore {

private:
  /// Local queue to understand what to expect from the response
  WaitQueueT<ResponseHandling>  m_responseQ;
  /// reporting level for messages generated by xactor
  XactorMsgLevelType m_requestCheckLevel;

public:
  ///  Constructor for SceMi based client.
  /// \param name -- symbolic name
  /// \param path -- scemi path, in params file
  SlaveProxy(const std::string &name, const std::string &path);

  ///  Constructor for SceMi based client. -- Pipes based
  /// \param name -- symbolic name
  /// \param path -- scemi path, in params file
  SlaveProxy(const std::string &name, const std::string &path, const XactorAdapter::SPipes type );

  ///  Constructor for SceMi based client. -- SceMiPort based
  /// \param name -- symbolic name
  /// \param path -- scemi path, in params file
  SlaveProxy(const std::string &name, const std::string &path, const XactorAdapter::SPorts type );

  ///  Blocking send method.
  /// This methods blocks until the Request has been
  /// successfully passed to the xactor
  /// \param req -- the TLMRequest to be sent
  /// \param discardResponse -- indicates if the reponse is will be discard (usually for write requests)
  void send (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req, bool discardResponse = false) ;

  ///  Non-blocking send.
  /// This method sends the Request if the xactor can accept its.
  /// \param req -- the TLMRequest to be sent
  /// \param discardResponse -- indicates if the reponse is will be discard (usually for write requests)
  /// \return  returns true if the Request has been sent
  bool sendNB (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req, bool discardResponse = false);

  ///  Timed-blocking send.
  /// This method tries to send the request but will timeout if the
  /// request has not been sent within delta time.
  /// \param req -- the TLMRequest to be sent
  /// \param seconds -- timeout delay in seconds
  /// \param microseconds -- delay in micro-seconds
  /// \param discardResponse -- indicates if the reponse is will be discard (usually for write requests)
  /// \return  returns true if the Request has been sent,  false if
  /// a timeout occurred.
  bool sendT (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req
              , const time_t seconds, const long microseconds=0,
              bool discardResponse = false);

  ///  Timed-blocking send.
  /// This method tries to send the request but will timeout if the
  /// request has not been sent within delta time.
  /// \param req -- the TLMRequest to be sent
  /// \param expiration -- absolute time for the timeout
  /// \param discardResponse -- indicates if the reponse is will be discard (usually for write requests)
  /// \return  returns true if the Request has been sent,  false if
  /// a timeout occurred.
  bool sendT (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req
              , struct timespec &expiration
              , bool discardResponse = false);

  /// Blocking receive.
  /// This method blocks until a response is received from the xactor.
  /// \param resp -- the TLMResponse received (this is populated by
  /// this call.)
  void receive (TLMResponse<DATASIZE,USERDSIZE > &resp) ;

  /// Non-Blocking receive.
  /// This method checks if a response is available from the xactor
  /// and returns it if it is.
  /// \param resp -- the TLMResponse received (this is populated by
  /// this call.)
  /// \return  returns true if the Response has been received
  bool receiveNB (TLMResponse<DATASIZE,USERDSIZE > &resp) ;

  /// Timed-Blocking receive.
  /// This method attempts to retrieve a message from the xactor,
  /// blocking until the message is received or the timeout expires.
  /// \param resp -- the TLMResponse received (this is populated by
  /// this call.)
  /// \param seconds -- timeout delay in seconds
  /// \param microseconds -- delay in micro-seconds
  /// \return  returns true if the Response has been received,  false if
  /// a timeout occurred.
  bool receiveT (TLMResponse<DATASIZE,USERDSIZE > &resp
                 , const time_t seconds, const long microseconds=0) ;

  /// Timed-Blocking receive.
  /// This method attempts to retrieve a message from the xactor,
  /// blocking until the message is received or the timeout expires.
  /// \param resp -- the TLMResponse received (this is populated by
  /// this call.)
  /// \param expiration -- absolute time for the timeout
  /// \return  returns true if the Response has been received,  false if
  /// a timeout occurred.
  bool receiveT (TLMResponse<DATASIZE,USERDSIZE > &resp
                 ,struct timespec &expiration) ;

  ///  Synchronous send/receive method.
  ///  This method blocks until the request is sent and  a response is
  ///  received from the xactor.
  /// \param req -- the TLMRequest to be sent
  /// \param resp -- the TLMResponse received (this is populated by
  /// this call.)
  void send (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req, TLMResponse<DATASIZE,USERDSIZE > &resp);


  ///  Synchronous send/receive method.
  ///  This method blocks until the request is sent and  a response is
  ///  received from the xactor.
  /// \param req -- the TLMRequest to be sent
  /// \param resp -- the TLMResponse received (this is populated by
  /// this call.)
  /// \param seconds -- timeout delay in seconds
  /// \param microseconds -- delay in micro-seconds
  /// \return  returns true if the request has been sent and response has been received
  bool sendT (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req, TLMResponse<DATASIZE,USERDSIZE > &resp
              , const time_t seconds, const long microseconds=0);

  /// Indicates if a Response can be received.
  /// This method determines if a full TLMResponse is available and returns 1,
  /// 0 otherwise.  Unlike the XactorCore version, this does not return the full
  /// count of data
  virtual unsigned canReceive ();

  /// Check the given request to see if it complies with the bus frabric of the
  /// transactor
  /// \param req -- the request to check
  /// \return returns true if the checks passed or were disabled
  bool checkTLMRequest (const TLMRequest<ADDRSIZE,DATASIZE,USERDSIZE > &req);

private:
  /// disabled copy constructor
  SlaveProxy (const SlaveProxy &);
  /// disabled copy constructor
  SlaveProxy & operator= (const SlaveProxy &);

protected:
  /// Utility function to locally store information about this request
  void queueExpectedResponse( const TLMRequest<ADDRSIZE, DATASIZE, USERDSIZE> & req, bool discard=false );

};
