#  Copyright 2007--2009 Bluespec, Inc.  All rights reserved.
# $Id$

package require types
package require utils

namespace eval ::SceMiMsg {
    variable Debug false
    variable MemberPrefix "m_"
    variable EnumPrefix "e_"
    variable TagPrefix "tag_"
    # List of BSV headers
    variable BSVHeaders   [list BitT BSVVectorT BSVVoid]
    variable BSVNoGenKind [list Vector Primary]
    variable BSVNoGenType [list Bool]
    variable BSVInclude "bsv_scemi.h"

    proc genHeader {OT} {
        upvar 1 $OT T
        set s [list \
                   "// Automatically generated by: [utils::unQualType [namespace current]]" \
                   "// DO NOT EDIT" \
                   "// C++ Class with SceMi Message passing for Bluespec type:  $T(Name)" \
                   "// Generated on: [clock format [clock seconds]]" \
                   "// Bluespec version: [::Bluetcl::version]" \
                   "" \
                   "#pragma once" \
                  ]
        join $s \n
    }

    proc genInclude {OT} {
        upvar 1 $OT T
        set s ""
        switch $T(Kind) {
            "Struct"      {append s [genIncludeStruct T]}
            "TaggedUnion" {append s [genIncludeStruct T]}
            "Enum"        {append s [genIncludeEnum T]}
            "Alias"       {append s [genIncludeAlias T]}
        }
        foreach f $T(Headers) {
            append s "#include \"$f.h\"" \n
        }
        return $s
    }
    proc genIncludeEnum {OT} {
        upvar 1 $OT T
        set s \n
        append s "#include \"bsv_scemi.h\"" \n
        return $s
    }
    proc genIncludeStruct {OT} {
        upvar 1 $OT T
        set s \n
        append s "#include \"bsv_scemi.h\"" \n
        return $s
    }
    proc genIncludeAlias {OT} {
        upvar 1 $OT T
        set s \n
        append s "#include \"bsv_scemi.h\"" \n
        return $s
    }

    proc genClass {OT} {
        upvar 1 $OT T
        switch $T(Kind) {
            "Enum"   {genEnumClass T}
            "Struct" {genStructClass T}
            "TaggedUnion" {genTaggedUnionClass T}
            "Alias"  {genAliasClass T}
            "Vector" {}
            default  {error "Error: Unexpected BSV type for SceMsg Generation: $T(Kind)" }
        }
    }
    proc genEnumClass {OT} {
        upvar 1 $OT T
        set s ""
        append s "/// C++ class representing the hardware enum $T(Name)." \n
        append s "/// This class has been automatically generated." \n
        append s "class $T(Class) : public BSVType {" \n
        append s " public:" \n
        append s [genEnumEnum T] \n
        append s "  $T(Enum_Root) [bsvToCppStructName val];" \n
        append s [genEnumConstr T] \n
        append s [genEnumMsgConstr T] \n
        #append s [genEnumCopyConstr T] \n
        append s [genEnumSetMsg T] \n
        append s [genEnumOperator T] \n
        append s [genEnumOperatorOS T] \n
        append s [genEnumGetName T] \n
        append s [genEnumBitString T] \n
        append s [genGetBSVType T] \n
        append s [genGetBitSize T] \n
        append s [genGetClassName T] \n
        append s [genGetKind T] \n
        append s [genGetNullMembers T] \n
        append s "};" \n
        return $s
    }

    proc genStructClass {OT} {
        upvar 1 $OT T
        set s ""
        append s "/// C++ class representing the hardware structure $T(Name)" \n
        append s "/// This class has been automatically generated." \n
        append s "class $T(Class) : public BSVType {" \n
        append s " public:" \n
        append s [genStructMembers T] \n
        append s [genDefaultConstr T] \n
        append s [genConstrMsg T] \n
	#append s [genCopyConstrMsg T] \n
        append s [genMsgConstr T] \n
        append s [genStructOperatorOS T] \n
        append s [genStructBitString T] \n
        append s [genGetBSVType T] \n
        append s [genGetBitSize T] \n
        append s [genGetClassName T] \n
        append s [genGetKind T] \n
        append s [genGetMembers T] \n
        append s "};" \n
        return $s
    }

    proc genTaggedUnionClass {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// C++ class representing the hardware tagged union $T(Name)" \n
        append s "/// This class has been automatically generated." \n
        append s "class $T(Class) : public BSVType {" \n
        append s " public:" \n \n
        append s [genTUEnum T] 
        append s [genTUMembers T]
        append s [genTUConstr T]
        append s [genTUMsgConstr T]
        #append s [genTUCopyConstr T]
        append s [genTUSetMsg T]
        append s [genTUOperatorOS T]
        append s [genGetBSVType T] \n
        append s [genGetBitSize T] \n
        append s [genTUBitString T] \n
        append s [genGetClassName T] \n
        append s [genGetKind T] \n
        append s [genGetTUTag T] \n
        append s [genGetMembers T] \n
        append s "};" \n
        return $s
    }

    proc genAliasClass {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// An alias or typedef name for $T(Subclass) to $T(Class)" \n
        append s "typedef $T(Subclass) $T(Class) ;" \n
        return $s
    }

    proc genEnumEnum {OT} {
        upvar 1 $OT T
        set s \n
        append s "enum $T(Enum_Root) {" \n "  "
        set mem [list]
        foreach m $T(members) {
            lappend mem [bsvToCppEnum $m]
        }
        append s "  " [join $mem ",\n    "] \n
        append s "  } ;" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Default constructor for enumeration" \n
        append s "$T(Class) ($T(Enum_Root) v = [bsvToCppEnum [utils::head $T(members)]])" \n
        append s ": [bsvToCppStructName val](v)" \n
        append s "{}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumMsgConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Constructor for enumeration from a SceMiMessageData object" \n
        append s "/// @param msg -- the scemi message object" \n
        append s "/// @param off -- the starting bit offset, updated to next bit position" \n
        append s "$T(Class) (const SceMiMessageDataInterface *msg, unsigned int & off) {" \n
        append s "  [bsvToCppStructName val] = ($T(Enum_Root)) msg->GetBitRange ( off, [expr $T(width) -1 ] );" \n
        append s "  off = off + $T(width);" \n
        append s "}" \n
	regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumCopyConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Constructor from string of '1' or '0'." \n
        append s "/// Error if one of the char is not either '1' or '0'" \n
        append s "$T(Class) (std::string &st) {" \n
	append s "  char *endp;" \n
	append s "  std::string est = st.substr(getBitSize());" \n
	append s "  m_val = (E_$T(Class))strtol(est.c_str(), &endp, 2);" \n
        append s "}" \n
	regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumSetMsg {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Converts enumeration into its bit representation for sending as a SceMi message" \n
        append s "/// @param msg -- the message object written into" \n
        append s "/// @param off -- bit position offset in message" \n
        append s "/// @return next free bit position in the message for writing" \n
        append s "unsigned int setMessageData( SceMiMessageDataInterface &msg, const unsigned int off) const {" \n
        append s "  msg.SetBitRange ( off, [expr $T(width) -1], (SceMiU32) [bsvToCppStructName val] );" \n
        append s "  return off + $T(width);" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumOperator {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// overload operator == for enumeration classes with values" \n
        append s "bool operator== (const $T(Enum_Root) &x) const { return m_val == x ;}" \n
        append s "/// overload operator != for enumeration classes with values" \n
        append s "bool operator!= (const $T(Enum_Root) &x) const { return m_val != x ;}" \n
        append s "/// overload operator == for enumeration classes" \n
        append s "bool operator== (const $T(Class) &x) const { return m_val == x.m_val ;}" \n
        append s "/// overload operator != for enumeration classes" \n
        append s "bool operator!= (const $T(Class) &x) const { return m_val != x.m_val ;}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }

    proc genEnumBitString {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Adds to the stream the bit representation of this object" \n
        append s "/// @param os -- the ostream object which to append" \n
        append s "/// @return the ostream object" \n
        append s "virtual std::ostream & getBitString (std::ostream &os) const {" \n
        append s "  unsigned int data = (unsigned int) [bsvToCppStructName val];" \n
        append s "  for ( unsigned int i = $T(width); i > 0; --i) {" \n
        append s "    unsigned int bitidx = i - 1;" \n
        append s "    bool v = 0 != (data & (0x1 << bitidx));" \n
        append s "    os << (v ? '1' : '0') ;" \n
        append s "  }" \n
        append s "return os;" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genStructMembers {OT} {
        upvar 1 $OT T
        set s "  "
        set m [list]
        foreach f [lreverse $T(fields)] {
            set ty $T(Class,$f)
            set mb $f
            lappend m "$ty [bsvToCppStructName $mb] ;"
        }
        append s [join $m "\n  "]
        return $s
    }
    proc genDefaultConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// A default constructor" \n
        append s "$T(Class) ()\n"
	if {[llength $T(fields)] > 0} {
	    append s "  : "
        }
        set fc [list]
        foreach f [lreverse $T(fields)] {
            set fconst " [bsvToCppStructName $f]\()"
            lappend fc $fconst
        }
        append s [join $fc "\n  ,"]
        append s "\n{}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genConstrMsg {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Constructor for object from a SceMiMessageData object" \n
        append s "/// @param msg -- the scemi message object" \n
        append s "/// @param off -- the starting bit offset, updated to next bit position" \n
        append s "$T(Class) ( const SceMiMessageDataInterface *msg, unsigned int &off )\n"
	if {[llength $T(fields)] > 0} {
	    append s "  : "
        }
        set fc [list]
        foreach f  [lreverse $T(fields)] {
            set fconst "[bsvToCppStructName $f]\(msg, off)"
            lappend fc $fconst
        }
        append s [join $fc "\n  , "] \n
        append s "{}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genCopyConstrMsg {OT} {
        upvar 1 $OT T
        set s \n
	append s "/// Constructor from string of '1' or '0'." \n
	append s "/// Error if one of the char is not either '1' or '0'" \n
	append s "$T(Class) ( std::string &st )" \n
	append s "{" \n
	set first 0
	set prev ""
        foreach f  [lreverse $T(fields)] {
	    if {$first == 0} {
		append s "  m_$f = st;" \n
		set first 1
	    } else {
		append s "  st = st.substr(m_$prev.getBitSize());" \n
		append s "  m_$f = st;" \n
	    }
	    set prev "$f"
        }
	append s "}" \n
        regsub -all {\n} $s "\n  " s
	return $s
    }
    proc genMsgConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Converts this object into its bit representation for sending as a SceMi message" \n
        append s "/// @param msg -- the message object written into" \n
        append s "/// @param off -- bit position off set in message" \n
        append s "/// @return next free bit position for writing" \n
        append s "unsigned int setMessageData (SceMiMessageDataInterface &msg, const unsigned int off=0) const {\n"
        append s "  unsigned int running = off;\n"

        set fc [list]
        foreach f [lreverse $T(fields)] {
            set fconst "running = [bsvToCppStructName $f].setMessageData( msg, running );"
            lappend fc $fconst
        }
        append s "  " [join $fc "\n  "] \n
        append s "  if (running != off + $T(width) ) {" \n
        append s "    std::cerr << \"Mismatch in sizes: \" << std::dec <<  running << \" vs \" << (off + $T(width)) << std::endl;" \n
        append s "  }" \n
        append s "  return running;" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genOverRidePutTo { object } {
        set s ""
        append s "  BSVType::PutTo * override = lookupPutToOverride ( $object.getClassName() );" \n
        append s "  if ( override != 0 ) {" \n
        append s "     return override(os, $object );" \n
        append s "  }" \n
        return $s
    }

    proc genStructOperatorOS {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// overload the put-to operator for $T(Class)" \n
        append s "friend std::ostream & operator<< (std::ostream &os, const $T(Class) &obj) {" \n
        append s [genOverRidePutTo obj ]
        append s "  os << \"{\" ;" "\n  "
        set os [list]
        foreach f $T(fields) {
            lappend os  "os << \"$f \" << obj.[bsvToCppStructName $f] ;"
        }
        append s [join $os "os << \" \" ;\n  "]
        append s "os << \"}\" ;" \n
        append s "  return os;" \n  "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumOperatorOS {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// overload the put-to operator for $T(Class)" \n
        append s "friend std::ostream & operator<< (std::ostream &os, const $T(Class) & e) {" \n
        append s [genOverRidePutTo e ]
        append s "  switch (e.[bsvToCppStructName val]) {" \n
        foreach m $T(members) {
            append s "    case [bsvToCppEnum $m]: os << \"$m\" ; break ;" \n
        }
        append s "    default: os << \"Enum value error for $T(Class): \" << (int) e.[bsvToCppStructName val] << \".\" ;" \n
        append s "  }" \n
        append s "  return os;" \n
        append s "};"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genEnumGetName {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Accessor for symbolic name of the class' enumeration value" \n
        append s "/// @return the name as a char *" \n
        append s "const char * getName() const {" \n
        append s "  const char *ret = \"\" ;" \n
        append s "  switch ([bsvToCppStructName val]) {" \n
        foreach m $T(members) {
            append s "    case [bsvToCppEnum $m]: ret = \"$m\" ; break ;" \n
        }
        append s "    default: std::cerr << \"Enum value error for $T(Class): \" << (int) [bsvToCppStructName val] << \".\" ;" \n
        append s "  }" \n
        append s "  return ret;" \n
        append s "};"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetNullMembers {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Accessor for the count of members in object" \n
        append s "virtual unsigned int getMemberCount() const {return 0;};" \n

        append s "/// Accessor to member objects" \n
        append s "/// @param idx -- member index" \n
        append s "/// @return BSVType * to this object or null" \n
        append s "virtual BSVType * getMember (unsigned int idx) {return 0;};" \n\n

        append s "/// Accessor for symbolic member names" \n
        append s "/// @param idx -- member index" \n
        append s "/// @return char* to this name or null" \n
        append s "virtual const char * getMemberName (unsigned int idx) const {return 0;};" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetMembers {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Accessor for the count of members in object" \n
        append s "virtual unsigned int getMemberCount() const {" \n
        append s "  return [llength $T(fields)];" \n
        append s "};" \n \n

        append s "/// Accessor to member objects" \n
        append s "/// @param idx -- member index" \n
        append s "/// @return BSVType * to this object or null" \n
        append s "virtual BSVType * getMember (unsigned int idx) {" \n
        append s "  switch (idx) {" \n
        set idx 0;
        foreach f $T(fields) {
            append s "    case $idx: return & [bsvToCppStructName $f];" \n
            incr idx
        }
        append s "    default: std::cerr << \"Index error in getMember for class $T(Class)\" << std::endl ;" \n
        append s "  };" \n
        append s "  return 0;" \n
        append s "};" \n \n

        append s "/// Accessor for symbolic member names" \n
        append s "/// @param idx -- member index" \n
        append s "/// @return char* to this name or null" \n
        append s "virtual const char * getMemberName (unsigned int idx) const {" \n
        append s "  switch (idx) {" \n
        set idx 0;
        foreach f $T(fields) {
            append s "    case $idx: return \"$f\";" \n
            incr idx
        }
        append s "    default: std::cerr << \"Index error in getMemberName for class $T(Class)\" << std::endl ;" \n
        append s "  };" \n
        append s "  return 0;" \n
        append s "};" \n \n

        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genStructBitString {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Adds to the stream the bit representation of this structure object" \n
        append s "/// @param os -- the ostream object which to append" \n
        append s "/// @return the ostream object" \n
        append s "virtual std::ostream & getBitString (std::ostream & os) const {" \n
        foreach f $T(fields) {
            append s "  [bsvToCppStructName $f].getBitString (os);" \n
        }
        append s "return os;" \n
        append s "}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genTUBitString {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Adds to the stream the bit representation of this tagged union object" \n
        append s "/// @param os -- the ostream object which to append" \n
        append s "/// @return the ostream object" \n
        append s "virtual std::ostream & getBitString (std::ostream & os) const {" \n
        if {$T(tagwidth) > 0} {
            append s "  for ( int i = [expr $T(tagwidth) - 1] ; i >= 0 ; --i) {" \n
            append s "     os << ( ((the_tag & (0x01 << i)) != 0) ? '1' : '0' ) ;" \n
            append s "  }" \n
            append s "  switch (the_tag) {" \n
            foreach f $T(fields) {
                append s "    case [bsvToTagEnum $f]:" \n
                set pad [expr $T(width) - ( $T(tagwidth) + $T(width,$f) ) ]
                if { $pad != 0 } {
                append s "      os << std::setw($pad) << std::setfill('0') << '0' ;" \n
                }
                append s "      [bsvToCppStructName $f].getBitString (os);" \n
                append s "      break;" \n
            }
            append s "    default:" \n
            set pad [expr $T(width) - $T(tagwidth) ]
            append s "      std::cerr << \"bad tag fields in $T(Class)::getBitString()\" << std::endl;" \n
            append s "      os << std::setw($pad) << std::setfill('0') << '0' ;" \n
            append s "      break;" \n
            append s "  }" \n
        } else {
            append s "  [bsvToCppStructName [utils::head $T(fields)]].getBitString(os);" \n
        }
        append s "return os;" \n
        append s "}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genFile {OT} {
        upvar 1 $OT T
        set s [list \
                   [genHeader T] \
                   [genInclude T] \
                   [genClass T] \
                   ]
        join $s \n
    }
    proc genTUEnum {OT} {
        upvar 1 $OT T
        set s ""
        append s "  // Enumeration type for the tag" \n
        append s "  enum TAG {" \n
        set tags [list]
        set v 0
        foreach fc $T(fields) {
            lappend tags "[bsvToTagEnum $fc]=$v"
            incr v
        }
        append s "    " [join $tags ",\n    "] \n
        append s "  };" \n \n
        return $s
    }
    proc genTUMembers {OT} {
        upvar 1 $OT T
        set s ""
        if {$T(tagwidth) > 0} {
            append s "  SceMiU32 the_tag;" \n
        }
        foreach fc $T(fields) {
            append s "  $T(Class,$fc) [bsvToCppStructName $fc];" \n
        }
        return $s
    }
    proc genTUConstMembers {OT} {
        upvar 1 $OT T
        set s "  :"
        if {$T(tagwidth) > 0} {
            append s " the_tag(0)" \n "  ,"
        }
        set cs [list]
        foreach fc $T(fields) {
            lappend cs " [bsvToCppStructName $fc] ()"
        }
        append s [join $cs "\n  ,"]
    }
    proc genTUConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "$T(Class) ()" \n
        append s [genTUConstMembers T] \n
        append s "{}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genTUMsgConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Constructor for tagged union from a SceMiMessageData object" \n
        append s "/// @param msg -- the scemi message object" \n
        append s "/// @param off -- the starting bit offset, updated to next bit position" \n
        append s "$T(Class) (const SceMiMessageDataInterface *msg, unsigned int &off)" \n
        append s [genTUConstMembers T] "  {\n"
        append s "  unsigned int tmpoff = off;" \n
        if {$T(tagwidth) > 0} {
            append s "  the_tag = msg->GetBitRange (off + [expr $T(width) - $T(tagwidth)], [expr $T(tagwidth) - 1]);" \n
        } else {
            append s "  SceMiU32 the_tag = 0;" \n
        }
        append s "  switch (the_tag) {" \n
        foreach fc $T(fields) {
            append s "    case [bsvToTagEnum $fc]: [bsvToCppStructName $fc] = $T(Class,$fc)(msg, tmpoff) ; break ;" \n
        }
        append s "    default: std::cerr << \"bad tag fields in $T(Class) constructor\" << std::endl;" \n
        append s "  };" \n
        append s "  off += $T(width);" \n
        append s "}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genTUCopyConstr {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Constructor from string of '1' or '0'." \n
        append s "/// Error if one of the char is not either '1' or '0'" \n
        append s "$T(Class) (std::string &st) {" \n
	append s "  char *endp;" \n
	append s "  std::string tst = st.substr(0, [expr $T(tagwidth)]);" \n
        append s "  the_tag = strtol(tst.c_str(), &endp, 2);" \n
        append s "  tst = st.substr([expr $T(tagwidth) + 1]);" \n
        append s "  switch (the_tag) {" \n
	foreach fc $T(fields) {
	    append s "    case [bsvToTagEnum $fc]: [bsvToCppStructName $fc] = tst ; break ;" \n
	}
	append s "    default: std::cerr << \"bad tag fields in $T(Class) copy constructor\" << std::endl;" \n
	append s "  }" \n
        append s "}" \n
	regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genTUSetMsg {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Converts into its bit representation for sending as a SceMi message" \n
        append s "/// @param msg -- the message object written into" \n
        append s "/// @param off -- bit position offset in message" \n
        append s "/// @return next free bit position in the message for writing" \n
        append s "unsigned int setMessageData (SceMiMessageDataInterface &msg, const unsigned int off=0) const {" \n
        if {$T(tagwidth) == 0} {
            append s "  SceMiU32 the_tag = 0;" \n
        } else {
            append s "  msg.SetBitRange(off + [expr $T(width) - $T(tagwidth)], [expr $T(tagwidth) - 1], the_tag);" \n
        }
        append s "  switch (the_tag) {" \n
        foreach fc $T(fields) {
            append s "    case [bsvToTagEnum $fc]: [bsvToCppStructName $fc].setMessageData (msg, off); break;" \n
        }
        append s "    default: std::cerr << \"bad tag fields in $T(Class) setMessageData\" << std::endl;" \n
        append s "  }" \n
        append s "  return off + $T(width);" \n
        append s "}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genTUOperatorOS {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// overload the put-to operator for $T(Class)" \n
        append s "friend std::ostream & operator<< (std::ostream &os, const $T(Class) &obj) {" \n
        append s [genOverRidePutTo obj]
         if {$T(tagwidth) == 0} {
             append s "  SceMiU32 tag = 0;" \n
         } else {
             append s "  SceMiU32 tag = obj.the_tag;" \n
         }
        append s "  switch (tag) {" \n
        foreach fc $T(fields) {
            append s "    case  [bsvToTagEnum $fc]: os << \"{$fc \" << obj.[bsvToCppStructName $fc] << \"}\" ; break;" \n
        }
        append s "    default: std::cerr << \"bad tag fields in $T(Class) operator<<\" << std::endl;" \n
        append s "  }" \n
        append s "  return os;" \n
        append s "}" \n
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetTUTag {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Accessor to the \"tag\" portion of the tagged union" \n
        append s "virtual SceMiU32 getTaggedUnionTag () const {" \n
        if { $T(tagwidth) != 0 } {
            append s "  return the_tag;" \n
        } else {
            append s "  return 0;" \n
        }
        append s "}" \n

        append s "/// returns the bit width of the tag portion of the tagged union" \n
        append s "virtual unsigned int getTaggedUnionTagWidth () const {" \n
        append s "  return $T(tagwidth);" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetBSVType {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Accessor for the BSVType name for this object" \n
        append s "/// @param os -- the ostream object which to append" \n
        append s "/// @return the ostream object" \n
        append s "virtual std::ostream & getBSVType (std::ostream & os) const {" \n
        append s "  os << \"$T(Name)\" ;" \n
        append s "  return os;" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetBitSize {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// Accessor on the size of the object in bits" \n
        append s "/// @return the bit size" \n
        append s "virtual unsigned int getBitSize () const {" \n
        append s "  return $T(width);" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetClassName {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// returns the class name for this object" \n
        append s "virtual const char * getClassName() const {" \n
        append s "  return \"$T(Class)\" ;" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    proc genGetKind {OT} {
        upvar 1 $OT T
        set s \n
        append s "/// returns the BSVKind for this object" \n
        append s "virtual BSVKind getKind() const {" \n
        append s "  return BSV_$T(Kind) ;" \n
        append s "}"
        regsub -all {\n} $s "\n  " s
        return $s
    }
    # Analyze type building
    proc analyzeType { type OutVar } {
        variable Debug
        upvar 1 $OutVar T
        catch "array unset T"
        if { [catch "Bluetcl::type full [list $type]" res] } {
            puts stderr "$res"
            error "Error: Cannot find or analysze Bluespec type: $type"
        }
        set T(Kind) [lindex $res 0]
        set T(Name) $type
        set T(Class) [bsvTypeToCppClass $T(Name) UNUSED]
        set T(Headers) [list]
        foreach el [lrange $res 2 end] {
            set f [lindex $el 0]
            set v [lindex $el 1]
            set T($f) $v
        }
        switch $T(Kind) {
            "Struct" {populateStruct T}
            "Enum"   {populateEnum T}
            "Alias"  {populateAlias T $res}
            "Vector" {populateVector T $res}
            "TaggedUnion" {populateTaggedUnion T}
            default  {error "Error: Unsupport kind for [utils::unQualType [namespace current]] Type: $type, Kind: $T(Kind)" }
        }
        if { $Debug } {
            puts "$type  ----------------------------------------"
            parray T
        }
        # type must be not be polymorphic and of fixed width.   Check that here
        # Aliases do not have width, but everything else must
        if { $T(Kind) != "Alias" && ![info exists T(width)]  } {
            error  "Error: Bluespec type $type is not a fixed width"
        }
    }

    # Details for a Struct
    proc populateStruct { OT } {
        upvar 1 $OT T
        set T(fields) [list]
	set T(AllTypes) [list]
        foreach mem $T(members) {
            set f [lindex $mem 1]
            lappend T(fields) $f
            set T(type,$f) [lindex $mem 0]
            lappend T(AllTypes) [lindex $mem 0]
            # conversion to class
            set T(Class,$f) [bsvTypeToCppClass $T(type,$f) UNUSED]
            # width
            if { [regexp {width ([0-9]+)} [lindex $mem 2] x wid ] } {
                set T(width,$f) $wid
            } else {
                error "Error: Unknown size on field $f of $T(Name)"
            }
        }
        set T(Headers) [bsvTypesToHeaders $T(AllTypes)]
    }
    proc populateTaggedUnion {OT} {
        upvar 1 $OT T
        populateStruct T
        set T(tagwidth)  [tagSize [llength $T(fields)]]
    }
    proc populateEnum {OT} {
        upvar 1 $OT T
        set T(Enum_Root) "E_$T(Class)"
        set T(Headers) [list]
    }
    proc populateAlias {OT res} {
        upvar 1 $OT T
        set T(Alias) [lindex $res 2]
        set T(Subclass) [bsvTypeToCppClass $T(Alias) UNUSED]
        set T(Headers) [bsvTypesToHeaders [list $T(Alias)]]
    }
    proc populateVector {OT res} {
        upvar 1 $OT T
        set T(Elem) [types::getElem $res]
        set T(Headers) [bsvTypesToHeaders [list $T(Elem)]]
    }

    proc tagSize { n } {
        if {$n >= 0} {
            return [ expr int (ceil ( log10($n) / log10(2) ))]
        } else {
            error "Error: Attempt at log2 of negative number $n"
        }
    }

    proc bsvTypeToCppClass {type Subs} {
        upvar 1 $Subs SUBS
        set type [utils::unQualType $type]
        if { [regexp {^(Bit|Int|UInt)\#\(([0-9]+)\)$} $type m t sz] } {
            set str "BitT<$sz>"
            if { $sz == 0 } {
                set str "BSVVoid"
            }
        } elseif { [regexp "^Bool$" $type] } {
             set str "BitT<1>"
        } elseif { [regexp {^Vector\#\(([0-9]+),[ ]*(.+)\)$} $type x n t] } {
            set t2 [bsvTypeToCppClass $t SUBS]
            lappend SUBS $t2
            set str "BSVVectorT<$n, $t2 >"
            if { $n == 0 } {
                set str "BSVVoid"
            }
        } elseif { [regexp {^void$} $type] } {
            set str "BSVVoid"
        } else {
            regsub -all {[ \{\}:,(\#\$)]+} $type "_" str
            set str [string trimright $str "_"]
        }
        return $str
    }
    proc bsvTypeToCppHeader {type} {
        variable BSVHeaders
        set class [bsvTypeToCppClass $type unused]
        regsub {(<.*>)} $class "" outer
        if { [lsearch $BSVHeaders $outer] != -1 } { return "" }
        return $outer
    }
    # This takes a list of types and returns a list of types -- possibly an empty list.
    proc bsvTypesToHeaders { types } {
        variable BSVHeaders
        array set HS [list]
        foreach f $types {
            bsvTypeToHeader $f HS
        }
        foreach n $BSVHeaders {
            array unset HS $n
        }
        lsort [array names HS]
    }
    # worker function -- not for export
    proc bsvTypeToHeader { t hset} {
        upvar 1 $hset HSET
        set subtypes [list]
        set c [bsvTypeToCppClass $t subtypes]
        regsub {<.*>} $c "" c
        set HSET($c) 0
        foreach x $subtypes {
            regsub {<.*>} $x "" x
            set HSET($x) 0
        }
    }
    proc bsvToCppStructName {fn} {
        variable MemberPrefix
        return $MemberPrefix$fn
    }
    proc bsvToCppEnum {en} {
        variable EnumPrefix
        return $EnumPrefix$en
    }
    proc bsvToTagEnum {f} {
        variable TagPrefix
        return $TagPrefix$f
    }

    proc genHeaderFile {outdir type } {
        variable BSVNoGenKind
        variable BSVNoGenType
        catch "array unset T"
        set T(xx) 1

        if { [catch "analyzeType [list $type] T" err] } {
            puts stderr "$err"
            error "Error: Cannot generate header file for Bluespec type $type"
        }
        if { [lsearch $BSVNoGenType $type] != -1 }    { return ""}
        if { [lsearch $BSVNoGenKind $T(Kind)] != -1 } { return ""}

        set fname "$T(Class).h"
        set fname [file join $outdir $fname]
        set oFILE [open "$fname" "w"]
        set f [genFile T]
        puts $oFILE $f
        close $oFILE
        puts "Header file $fname has been created."
        return $T(Class)
    }

    proc genAllHeaders { outdir types } {
        set res ""
        foreach t $types {
            append res " " [genHeaderFile $outdir $t]
        }
        return $res
    }

    proc genMetaHeaderFile {outdir types {fname "SceMiHeaders.h"}} {

        set fname [file join $outdir $fname]
        set oFILE [open "$fname" "w"]

        set X(Name) "All SceMi types"
        puts $oFILE [genHeader X]

	puts $oFILE ""
        foreach t $types {
	    puts $oFILE "\#include \"$t.h\" "

        }
        close $oFILE
        puts "Header file $fname has been created."
    }

    # TODO  figure out all the sub types
    # Support for Vectors and other buildin
    proc generateSceMiHeaders { OPTS types } {
        upvar 1 $OPTS OPT
        variable MemberPrefix
        variable EnumPrefix

        types::import_package false $OPT(-package)

        # Analysis all type to generate all nested types
        set allTypes [findAllNestedTypes $types]

        if {[info exists OPT(-memberPrefix)]} {
            set MemberPrefix $OPT(-memberPrefix)
        }
        if {[info exists OPT(-enumPrefix)]} {
            set EnumPrefix $OPT(-enumPrefix)
        }
        if {[info exists OPT(-tagPrefix)]} {
            set TagPrefix $OPT(-tagPrefix)
        }

        genAllHeaders $OPT(-outdir) $allTypes
    }

    proc findAllNestedTypes {types } {
        array set F [list]
        while {0 != [llength $types]} {
            set t [utils::head $types]
            set types [utils::tail $types]

            if { [catch "::Bluetcl::type full [list $t]" ft] } {
                puts stderr "$ft"
                continue
            }
            set kind [lindex $ft 0]
            set tn [utils::unQualType $t]

            if { $tn   == "Bool" } continue
            if { $kind == "Primary" } continue
            if { $kind == "List" } continue
            if { [info exists F($tn)] } { continue }

            switch $kind {
                "Struct" {
                    set F($tn) 1
                    foreach mem [types::getMembers $ft] {
                        lappend types [utils::fst $mem]
                    }
                }
                "Alias" {
                    set F($tn) 1
                    lappend types [lindex $ft 2]
                }
                "Enum" {
                    set F($tn) 1
                }
                "Vector" {
                    lappend types [types::getElem $ft]
                }
                "TaggedUnion" {
                    set F($tn) 1
                    foreach mem [types::getMembers $ft] {
                        lappend types [utils::fst $mem]
                    }
                }
                default { # ignore the rest
                }
            }
        }
        return [array names F]
    }
}
package provide SceMiMsg 1.0

